replicaCount: 1

image:
  repository: hazelcast-microservices/api-gateway
  tag: "latest"
  pullPolicy: IfNotPresent

# Image pull secrets (for private registries like ECR)
imagePullSecrets: []

service:
  type: ClusterIP
  port: 8080

# Ingress for external access to the gateway
ingress:
  enabled: true
  className: ""
  annotations: {}
  # Example nginx annotations:
  #   nginx.ingress.kubernetes.io/proxy-body-size: "10m"
  #   nginx.ingress.kubernetes.io/proxy-read-timeout: "60"
  hosts:
    - host: ""
      paths:
        - path: /
          pathType: Prefix
  tls: []
  #  - secretName: api-tls-cert
  #    hosts:
  #      - api.example.com

# JVM configuration (lighter than microservices — no embedded Hazelcast)
jvm:
  xms: "128m"
  xmx: "256m"
  opts: "-XX:+UseContainerSupport -XX:MaxRAMPercentage=75.0"

# Spring configuration
spring:
  profiles: "kubernetes"

# Upstream service URLs — defaults constructed from Release.Name in configmap template
services:
  account:
    url: ""
    port: 8081
  inventory:
    url: ""
    port: 8082
  order:
    url: ""
    port: 8083
  payment:
    url: ""
    port: 8084

# OpenTelemetry / tracing
tracing:
  enabled: true
  endpoint: "http://jaeger:4317"

# Health probes (gateway starts faster — no Jet pipeline)
probes:
  startup:
    initialDelaySeconds: 15
    periodSeconds: 5
    failureThreshold: 12
    timeoutSeconds: 3
  liveness:
    initialDelaySeconds: 0
    periodSeconds: 30
    failureThreshold: 3
    timeoutSeconds: 3
  readiness:
    initialDelaySeconds: 0
    periodSeconds: 10
    failureThreshold: 3
    timeoutSeconds: 3

# Init container — wait for at least one microservice before routing
initContainers:
  waitForServices:
    enabled: true
    image: busybox:1.36

# Horizontal Pod Autoscaler (requires metrics-server)
autoscaling:
  enabled: false
  minReplicas: 2
  maxReplicas: 5
  targetCPUUtilizationPercentage: 70
  # targetMemoryUtilizationPercentage: 80

# Pod Disruption Budget (useful when replicas > 1)
podDisruptionBudget:
  enabled: false
  maxUnavailable: 1

# Resource management (lighter than microservices — reverse proxy only)
resources:
  requests:
    memory: "128Mi"
    cpu: "250m"
  limits:
    memory: "256Mi"
    cpu: "500m"

# Service account
serviceAccount:
  create: true
  name: ""
  annotations: {}

# Pod scheduling
podAnnotations: {}
podSecurityContext: {}
securityContext: {}
nodeSelector: {}
tolerations: []
affinity: {}
