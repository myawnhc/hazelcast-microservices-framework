package com.theyawns.ecommerce.common.view;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.ecommerce.common.domain.Customer;
import com.theyawns.ecommerce.common.events.CustomerCreatedEvent;
import com.theyawns.ecommerce.common.events.CustomerStatusChangedEvent;
import com.theyawns.ecommerce.common.events.CustomerUpdatedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import com.theyawns.framework.view.ViewUpdater;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;

/**
 * ViewUpdater implementation for the Customer domain.
 * Handles applying customer events to the materialized view.
 *
 * <p>Supported events:
 * <ul>
 *   <li>{@link CustomerCreatedEvent} - Creates new customer entry</li>
 *   <li>{@link CustomerUpdatedEvent} - Updates customer information</li>
 *   <li>{@link CustomerStatusChangedEvent} - Changes customer status</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
public class CustomerViewUpdater extends ViewUpdater<String> {

    private static final Logger logger = LoggerFactory.getLogger(CustomerViewUpdater.class);

    /**
     * Creates a new CustomerViewUpdater.
     *
     * @param viewStore the view store to update
     */
    public CustomerViewUpdater(HazelcastViewStore<String> viewStore) {
        super(viewStore);
    }

    @Override
    protected String extractKey(GenericRecord eventRecord) {
        return getStringField(eventRecord, "key");
    }

    @Override
    protected GenericRecord applyEvent(GenericRecord eventRecord, GenericRecord currentState) {
        String eventType = getEventType(eventRecord);

        logger.debug("Applying event type: {} to customer view", eventType);

        return switch (eventType) {
            case CustomerCreatedEvent.EVENT_TYPE -> applyCustomerCreated(eventRecord);
            case CustomerUpdatedEvent.EVENT_TYPE -> applyCustomerUpdated(eventRecord, currentState);
            case CustomerStatusChangedEvent.EVENT_TYPE -> applyCustomerStatusChanged(eventRecord, currentState);
            default -> {
                logger.warn("Unknown event type: {}", eventType);
                yield currentState;
            }
        };
    }

    /**
     * Applies a CustomerCreatedEvent to create a new customer view entry.
     *
     * @param eventRecord the event record
     * @return the new customer view state
     */
    private GenericRecord applyCustomerCreated(GenericRecord eventRecord) {
        Instant now = Instant.now();
        return GenericRecordBuilder.compact(Customer.SCHEMA_NAME)
                .setString("customerId", getStringField(eventRecord, "key"))
                .setString("email", getStringField(eventRecord, "email"))
                .setString("name", getStringField(eventRecord, "name"))
                .setString("address", getStringField(eventRecord, "address"))
                .setString("phone", getStringField(eventRecord, "phone"))
                .setString("status", Customer.Status.ACTIVE.name())
                .setInt64("createdAt", now.toEpochMilli())
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a CustomerUpdatedEvent to update existing customer information.
     *
     * @param eventRecord the event record
     * @param currentState the current customer state
     * @return the updated customer view state
     */
    private GenericRecord applyCustomerUpdated(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.error("Cannot update non-existent customer: {}", getStringField(eventRecord, "key"));
            return null;
        }

        Instant now = Instant.now();
        String newName = getStringField(eventRecord, "name");
        String newAddress = getStringField(eventRecord, "address");
        String newPhone = getStringField(eventRecord, "phone");

        return GenericRecordBuilder.compact(Customer.SCHEMA_NAME)
                .setString("customerId", currentState.getString("customerId"))
                .setString("email", currentState.getString("email"))
                .setString("name", newName != null ? newName : currentState.getString("name"))
                .setString("address", newAddress != null ? newAddress : currentState.getString("address"))
                .setString("phone", newPhone != null ? newPhone : currentState.getString("phone"))
                .setString("status", currentState.getString("status"))
                .setInt64("createdAt", currentState.getInt64("createdAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a CustomerStatusChangedEvent to change customer status.
     *
     * @param eventRecord the event record
     * @param currentState the current customer state
     * @return the updated customer view state with new status
     */
    private GenericRecord applyCustomerStatusChanged(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.error("Cannot change status of non-existent customer: {}", getStringField(eventRecord, "key"));
            return null;
        }

        Instant now = Instant.now();
        String newStatus = getStringField(eventRecord, "newStatus");

        return GenericRecordBuilder.compact(Customer.SCHEMA_NAME)
                .setString("customerId", currentState.getString("customerId"))
                .setString("email", currentState.getString("email"))
                .setString("name", currentState.getString("name"))
                .setString("address", currentState.getString("address"))
                .setString("phone", currentState.getString("phone"))
                .setString("status", newStatus)
                .setInt64("createdAt", currentState.getInt64("createdAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }
}
