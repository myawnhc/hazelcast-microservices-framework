package com.theyawns.ecommerce.common.util;

import com.hazelcast.nio.serialization.FieldKind;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Utility for converting Hazelcast {@link GenericRecord} instances to {@link Map}.
 *
 * <p>Used by service controllers to serialize event store records into JSON-friendly
 * maps for the event-history REST endpoint. Supports all Compact Serialization field
 * types used by the framework.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
public final class GenericRecordConverter {

    private GenericRecordConverter() {
        // Utility class
    }

    /**
     * Converts a GenericRecord to a Map, reading each field based on its FieldKind.
     *
     * <p>Supported field kinds: STRING, INT32, INT64, FLOAT32, FLOAT64, BOOLEAN,
     * NULLABLE_INT32, NULLABLE_INT64, NULLABLE_FLOAT32, NULLABLE_FLOAT64,
     * NULLABLE_BOOLEAN, COMPACT (nested record), ARRAY_OF_COMPACT (array of records).
     *
     * @param record the GenericRecord to convert
     * @return a map of field names to values, or an empty map if record is null
     */
    public static Map<String, Object> toMap(GenericRecord record) {
        if (record == null) {
            return Map.of();
        }

        Set<String> fieldNames = record.getFieldNames();
        Map<String, Object> result = new LinkedHashMap<>(fieldNames.size());

        for (String fieldName : fieldNames) {
            FieldKind kind = record.getFieldKind(fieldName);
            Object value = readField(record, fieldName, kind);
            result.put(fieldName, value);
        }

        return result;
    }

    /**
     * Reads a single field value from a GenericRecord based on its FieldKind.
     *
     * @param record the record to read from
     * @param fieldName the field name
     * @param kind the field kind
     * @return the field value, or null for unsupported types
     */
    private static Object readField(GenericRecord record, String fieldName, FieldKind kind) {
        switch (kind) {
            case STRING:
                return record.getString(fieldName);
            case INT32:
                return record.getInt32(fieldName);
            case INT64:
                return record.getInt64(fieldName);
            case FLOAT32:
                return record.getFloat32(fieldName);
            case FLOAT64:
                return record.getFloat64(fieldName);
            case BOOLEAN:
                return record.getBoolean(fieldName);
            case NULLABLE_INT32:
                return record.getNullableInt32(fieldName);
            case NULLABLE_INT64:
                return record.getNullableInt64(fieldName);
            case NULLABLE_FLOAT32:
                return record.getNullableFloat32(fieldName);
            case NULLABLE_FLOAT64:
                return record.getNullableFloat64(fieldName);
            case NULLABLE_BOOLEAN:
                return record.getNullableBoolean(fieldName);
            case COMPACT:
                GenericRecord nested = record.getGenericRecord(fieldName);
                return nested != null ? toMap(nested) : null;
            case ARRAY_OF_COMPACT:
                GenericRecord[] array = record.getArrayOfGenericRecord(fieldName);
                if (array == null) {
                    return null;
                }
                List<Map<String, Object>> list = new ArrayList<>(array.length);
                for (GenericRecord item : array) {
                    list.add(toMap(item));
                }
                return list;
            default:
                return "unsupported:" + kind.name();
        }
    }
}
