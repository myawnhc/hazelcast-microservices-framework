package com.theyawns.framework.persistence.postgres;

import com.theyawns.framework.persistence.PersistableView;
import com.theyawns.framework.persistence.postgres.repository.ViewStoreRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.util.List;
import java.util.Optional;
import java.util.stream.StreamSupport;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration tests for {@link PostgresViewStorePersistence} using Testcontainers PostgreSQL.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("PostgresViewStorePersistence - PostgreSQL integration tests")
@SpringBootTest(
        classes = PostgresViewStorePersistenceTest.TestConfig.class,
        properties = {
                "framework.persistence.enabled=true",
                "framework.edition.license.env-var=NONEXISTENT_TEST_LICENSE_VAR_12345",
                "spring.autoconfigure.exclude="
                        + "com.theyawns.framework.config.FrameworkAutoConfiguration,"
                        + "com.theyawns.framework.edition.EditionAutoConfiguration,"
                        + "com.theyawns.framework.vectorstore.VectorStoreAutoConfiguration,"
                        + "com.theyawns.framework.resilience.ResilienceAutoConfiguration,"
                        + "com.theyawns.framework.outbox.OutboxAutoConfiguration,"
                        + "com.theyawns.framework.dlq.DeadLetterQueueAutoConfiguration,"
                        + "com.theyawns.framework.idempotency.IdempotencyAutoConfiguration,"
                        + "com.theyawns.framework.saga.orchestrator.SagaOrchestratorAutoConfiguration,"
                        + "com.theyawns.framework.security.SecurityAutoConfiguration,"
                        + "com.theyawns.framework.security.PermitAllSecurityAutoConfiguration,"
                        + "com.theyawns.framework.security.identity.ServiceIdentityAutoConfiguration,"
                        + "org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,"
                        + "com.hazelcast.spring.HazelcastObjectExtractionConfiguration"
        }
)
@Testcontainers
class PostgresViewStorePersistenceTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16-alpine")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
        registry.add("spring.flyway.enabled", () -> "true");
        registry.add("spring.jpa.hibernate.ddl-auto", () -> "validate");
    }

    @Autowired
    private ViewStoreRepository repository;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private PostgresViewStorePersistence persistence;

    @BeforeEach
    void setUp() {
        persistence = new PostgresViewStorePersistence(repository, jdbcTemplate);
        repository.deleteAll();
    }

    @Test
    @DisplayName("should persist and load a single view entry")
    void shouldPersistAndLoadSingleView() {
        // Arrange
        PersistableView view = new PersistableView(
                "cust-001",
                "{\"name\":\"John\",\"email\":\"john@example.com\"}",
                1700000000000L);

        // Act
        persistence.persist("Customer_VIEW", view);
        Optional<PersistableView> loaded = persistence.loadView("Customer_VIEW", "cust-001");

        // Assert
        assertTrue(loaded.isPresent());
        PersistableView result = loaded.get();
        assertEquals("cust-001", result.viewKey());
        assertTrue(result.viewData().contains("John"));
        assertEquals(1700000000000L, result.lastUpdatedMillis());
    }

    @Test
    @DisplayName("should upsert view entry (update existing)")
    void shouldUpsertViewEntry() {
        // Arrange
        persistence.persist("Customer_VIEW",
                new PersistableView("cust-001", "{\"name\":\"John\"}", 100L));

        // Act â€” update same key with new data
        persistence.persist("Customer_VIEW",
                new PersistableView("cust-001", "{\"name\":\"John Updated\"}", 200L));

        // Assert
        Optional<PersistableView> loaded = persistence.loadView("Customer_VIEW", "cust-001");
        assertTrue(loaded.isPresent());
        assertTrue(loaded.get().viewData().contains("Updated"));
        assertEquals(200L, loaded.get().lastUpdatedMillis());
    }

    @Test
    @DisplayName("should persist a batch of view entries with upsert")
    void shouldPersistBatchWithUpsert() {
        // Arrange
        persistence.persist("Test_VIEW",
                new PersistableView("k1", "{\"v\":1}", 100L));

        List<PersistableView> views = List.of(
                new PersistableView("k1", "{\"v\":\"updated\"}", 200L),
                new PersistableView("k2", "{\"v\":2}", 200L),
                new PersistableView("k3", "{\"v\":3}", 200L)
        );

        // Act
        persistence.persistBatch("Test_VIEW", views);

        // Assert
        List<String> keys = StreamSupport.stream(
                persistence.loadAllKeys("Test_VIEW").spliterator(), false).toList();
        assertEquals(3, keys.size());

        // k1 should be updated
        Optional<PersistableView> k1 = persistence.loadView("Test_VIEW", "k1");
        assertTrue(k1.isPresent());
        assertTrue(k1.get().viewData().contains("updated"));
    }

    @Test
    @DisplayName("should load all keys for a view")
    void shouldLoadAllKeysForView() {
        // Arrange
        persistence.persist("View1", new PersistableView("a", "{}", 100L));
        persistence.persist("View1", new PersistableView("b", "{}", 200L));
        persistence.persist("View2", new PersistableView("c", "{}", 300L));

        // Act
        List<String> view1Keys = StreamSupport.stream(
                persistence.loadAllKeys("View1").spliterator(), false).toList();
        List<String> view2Keys = StreamSupport.stream(
                persistence.loadAllKeys("View2").spliterator(), false).toList();

        // Assert
        assertEquals(2, view1Keys.size());
        assertEquals(1, view2Keys.size());
    }

    @Test
    @DisplayName("should delete a single view entry")
    void shouldDeleteSingleViewEntry() {
        // Arrange
        persistence.persist("Test_VIEW",
                new PersistableView("k1", "{}", 100L));

        // Act
        persistence.delete("Test_VIEW", "k1");

        // Assert
        assertFalse(persistence.loadView("Test_VIEW", "k1").isPresent());
    }

    @Test
    @DisplayName("should delete all entries for a view")
    void shouldDeleteAllEntriesForView() {
        // Arrange
        persistence.persist("View1", new PersistableView("a", "{}", 100L));
        persistence.persist("View1", new PersistableView("b", "{}", 200L));
        persistence.persist("View2", new PersistableView("c", "{}", 300L));

        // Act
        persistence.deleteAll("View1");

        // Assert
        List<String> view1Keys = StreamSupport.stream(
                persistence.loadAllKeys("View1").spliterator(), false).toList();
        List<String> view2Keys = StreamSupport.stream(
                persistence.loadAllKeys("View2").spliterator(), false).toList();
        assertEquals(0, view1Keys.size());
        assertEquals(1, view2Keys.size()); // View2 unaffected
    }

    @Test
    @DisplayName("should return empty when view entry not found")
    void shouldReturnEmptyWhenNotFound() {
        // Act
        Optional<PersistableView> result = persistence.loadView("Missing_VIEW", "nonexistent");

        // Assert
        assertFalse(result.isPresent());
    }

    @Test
    @DisplayName("should report availability when database is reachable")
    void shouldReportAvailability() {
        assertTrue(persistence.isAvailable());
    }

    @Configuration
    @EnableAutoConfiguration
    static class TestConfig {
    }
}
