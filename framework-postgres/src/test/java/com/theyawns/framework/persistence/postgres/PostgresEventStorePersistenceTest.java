package com.theyawns.framework.persistence.postgres;

import com.theyawns.framework.persistence.PersistableEvent;
import com.theyawns.framework.persistence.postgres.entity.EventStoreEntity;
import com.theyawns.framework.persistence.postgres.repository.EventStoreRepository;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.autoconfigure.EnableAutoConfiguration;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.context.annotation.Configuration;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.testcontainers.containers.PostgreSQLContainer;
import org.testcontainers.junit.jupiter.Container;
import org.testcontainers.junit.jupiter.Testcontainers;

import java.util.List;
import java.util.Optional;
import java.util.stream.StreamSupport;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Integration tests for {@link PostgresEventStorePersistence} using Testcontainers PostgreSQL.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("PostgresEventStorePersistence - PostgreSQL integration tests")
@SpringBootTest(
        classes = PostgresEventStorePersistenceTest.TestConfig.class,
        properties = {
                "framework.persistence.enabled=true",
                "framework.edition.license.env-var=NONEXISTENT_TEST_LICENSE_VAR_12345",
                "spring.autoconfigure.exclude="
                        + "com.theyawns.framework.config.FrameworkAutoConfiguration,"
                        + "com.theyawns.framework.edition.EditionAutoConfiguration,"
                        + "com.theyawns.framework.vectorstore.VectorStoreAutoConfiguration,"
                        + "com.theyawns.framework.resilience.ResilienceAutoConfiguration,"
                        + "com.theyawns.framework.outbox.OutboxAutoConfiguration,"
                        + "com.theyawns.framework.dlq.DeadLetterQueueAutoConfiguration,"
                        + "com.theyawns.framework.idempotency.IdempotencyAutoConfiguration,"
                        + "com.theyawns.framework.saga.orchestrator.SagaOrchestratorAutoConfiguration,"
                        + "com.theyawns.framework.security.SecurityAutoConfiguration,"
                        + "com.theyawns.framework.security.PermitAllSecurityAutoConfiguration,"
                        + "com.theyawns.framework.security.identity.ServiceIdentityAutoConfiguration,"
                        + "org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,"
                        + "com.hazelcast.spring.HazelcastObjectExtractionConfiguration"
        }
)
@Testcontainers
class PostgresEventStorePersistenceTest {

    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:16-alpine")
            .withDatabaseName("testdb")
            .withUsername("test")
            .withPassword("test");

    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
        registry.add("spring.datasource.username", postgres::getUsername);
        registry.add("spring.datasource.password", postgres::getPassword);
        registry.add("spring.flyway.enabled", () -> "true");
        registry.add("spring.jpa.hibernate.ddl-auto", () -> "validate");
    }

    @Autowired
    private EventStoreRepository repository;

    @Autowired
    private JdbcTemplate jdbcTemplate;

    private PostgresEventStorePersistence persistence;

    @BeforeEach
    void setUp() {
        persistence = new PostgresEventStorePersistence(repository, jdbcTemplate);
        repository.deleteAll();
    }

    @Test
    @DisplayName("should persist and load a single event")
    void shouldPersistAndLoadSingleEvent() {
        // Arrange
        PersistableEvent event = new PersistableEvent(
                "seq:1000|key:cust-001", "cust-001", 1000L,
                "CustomerCreatedEvent",
                "{\"_schemaType\":\"CustomerCreatedEvent\",\"_fieldKinds\":{\"name\":\"STRING\"},\"_fields\":{\"name\":\"John\"}}",
                1700000000000L, "corr-123");

        // Act
        persistence.persist("Customer_ES", event);
        Optional<PersistableEvent> loaded = persistence.loadEvent("Customer_ES", "seq:1000|key:cust-001");

        // Assert
        assertTrue(loaded.isPresent());
        PersistableEvent result = loaded.get();
        assertEquals("seq:1000|key:cust-001", result.mapKey());
        assertEquals("cust-001", result.aggregateId());
        assertEquals(1000L, result.sequence());
        assertEquals("CustomerCreatedEvent", result.eventType());
        assertEquals(1700000000000L, result.timestampMillis());
        assertEquals("corr-123", result.correlationId());
    }

    @Test
    @DisplayName("should persist a batch of events")
    void shouldPersistBatchOfEvents() {
        // Arrange
        List<PersistableEvent> events = List.of(
                new PersistableEvent("seq:1|key:a", "a", 1L, "Event1", "{}", 100L, null),
                new PersistableEvent("seq:2|key:b", "b", 2L, "Event2", "{}", 200L, null),
                new PersistableEvent("seq:3|key:c", "c", 3L, "Event3", "{}", 300L, null)
        );

        // Act
        persistence.persistBatch("Test_ES", events);

        // Assert
        List<String> keys = repository.findAllMapKeysByMapName("Test_ES");
        assertEquals(3, keys.size());
    }

    @Test
    @DisplayName("should load all keys for a map")
    void shouldLoadAllKeysForMap() {
        // Arrange
        persistence.persist("Map1", new PersistableEvent("k1", "a", 1L, "E", "{}", 100L, null));
        persistence.persist("Map1", new PersistableEvent("k2", "b", 2L, "E", "{}", 200L, null));
        persistence.persist("Map2", new PersistableEvent("k3", "c", 3L, "E", "{}", 300L, null));

        // Act
        List<String> map1Keys = StreamSupport.stream(
                persistence.loadAllKeys("Map1").spliterator(), false).toList();
        List<String> map2Keys = StreamSupport.stream(
                persistence.loadAllKeys("Map2").spliterator(), false).toList();

        // Assert
        assertEquals(2, map1Keys.size());
        assertEquals(1, map2Keys.size());
    }

    @Test
    @DisplayName("should return empty when event not found")
    void shouldReturnEmptyWhenNotFound() {
        // Act
        Optional<PersistableEvent> result = persistence.loadEvent("Missing_ES", "nonexistent");

        // Assert
        assertFalse(result.isPresent());
    }

    @Test
    @DisplayName("should delete an event")
    void shouldDeleteEvent() {
        // Arrange
        persistence.persist("Test_ES",
                new PersistableEvent("k1", "a", 1L, "E", "{}", 100L, null));

        // Act
        persistence.delete("Test_ES", "k1");

        // Assert
        assertFalse(persistence.loadEvent("Test_ES", "k1").isPresent());
    }

    @Test
    @DisplayName("should report availability when database is reachable")
    void shouldReportAvailability() {
        assertTrue(persistence.isAvailable());
    }

    @Test
    @DisplayName("should handle batch insert with ON CONFLICT DO NOTHING for duplicates")
    void shouldHandleDuplicatesInBatch() {
        // Arrange
        PersistableEvent event = new PersistableEvent(
                "seq:1|key:a", "a", 1L, "Event1", "{}", 100L, null);
        persistence.persist("Test_ES", event);

        // Act — re-insert same key in batch
        List<PersistableEvent> batch = List.of(event);
        assertDoesNotThrow(() -> persistence.persistBatch("Test_ES", batch));

        // Assert — still only 1 row
        assertEquals(1, repository.findAllMapKeysByMapName("Test_ES").size());
    }

    @Configuration
    @EnableAutoConfiguration
    static class TestConfig {
    }
}
