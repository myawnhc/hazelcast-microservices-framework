package com.theyawns.framework.persistence.postgres;

import com.theyawns.framework.persistence.EventStorePersistence;
import com.theyawns.framework.persistence.PersistableEvent;
import com.theyawns.framework.persistence.postgres.entity.EventStoreEntity;
import com.theyawns.framework.persistence.postgres.repository.EventStoreRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

/**
 * PostgreSQL implementation of {@link EventStorePersistence}.
 *
 * <p>Uses JPA for single-record operations and JDBC batch insert for
 * {@link #persistBatch(String, List)} to maximize throughput.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
public class PostgresEventStorePersistence implements EventStorePersistence {

    private static final Logger logger = LoggerFactory.getLogger(PostgresEventStorePersistence.class);

    private static final String BATCH_INSERT_SQL =
            "INSERT INTO domain_events (map_name, map_key, aggregate_id, sequence, event_type, " +
            "event_data, timestamp_millis, correlation_id) " +
            "VALUES (?, ?, ?, ?, ?, ?::jsonb, ?, ?) " +
            "ON CONFLICT (map_name, map_key) DO NOTHING";

    private final EventStoreRepository repository;
    private final JdbcTemplate jdbcTemplate;

    /**
     * Creates a new PostgresEventStorePersistence.
     *
     * @param repository the JPA repository
     * @param jdbcTemplate the JDBC template for batch operations
     */
    public PostgresEventStorePersistence(EventStoreRepository repository, JdbcTemplate jdbcTemplate) {
        this.repository = repository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Transactional
    public void persist(String mapName, PersistableEvent event) {
        EventStoreEntity entity = toEntity(mapName, event);
        repository.save(entity);
        logger.debug("Persisted event {} for map {}", event.mapKey(), mapName);
    }

    @Override
    @Transactional
    public void persistBatch(String mapName, List<PersistableEvent> events) {
        if (events.isEmpty()) {
            return;
        }

        jdbcTemplate.batchUpdate(BATCH_INSERT_SQL, events, events.size(),
                (ps, event) -> {
                    ps.setString(1, mapName);
                    ps.setString(2, event.mapKey());
                    ps.setString(3, event.aggregateId());
                    ps.setLong(4, event.sequence());
                    ps.setString(5, event.eventType());
                    ps.setString(6, event.eventData());
                    ps.setLong(7, event.timestampMillis());
                    ps.setString(8, event.correlationId());
                });
        logger.debug("Batch persisted {} events for map {}", events.size(), mapName);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<PersistableEvent> loadEvent(String mapName, String mapKey) {
        return repository.findByMapNameAndMapKey(mapName, mapKey)
                .map(this::fromEntity);
    }

    @Override
    @Transactional(readOnly = true)
    public Iterable<String> loadAllKeys(String mapName) {
        return repository.findAllMapKeysByMapName(mapName);
    }

    @Override
    @Transactional
    public void delete(String mapName, String mapKey) {
        repository.deleteByMapNameAndMapKey(mapName, mapKey);
        logger.debug("Deleted event {} from map {}", mapKey, mapName);
    }

    @Override
    public boolean isAvailable() {
        try {
            jdbcTemplate.queryForObject("SELECT 1", Integer.class);
            return true;
        } catch (Exception e) {
            logger.warn("PostgreSQL persistence unavailable: {}", e.getMessage());
            return false;
        }
    }

    private EventStoreEntity toEntity(String mapName, PersistableEvent event) {
        return new EventStoreEntity(
                mapName,
                event.mapKey(),
                event.aggregateId(),
                event.sequence(),
                event.eventType(),
                event.eventData(),
                event.timestampMillis(),
                event.correlationId()
        );
    }

    private PersistableEvent fromEntity(EventStoreEntity entity) {
        return new PersistableEvent(
                entity.getMapKey(),
                entity.getAggregateId(),
                entity.getSequence(),
                entity.getEventType(),
                entity.getEventData(),
                entity.getTimestampMillis(),
                entity.getCorrelationId()
        );
    }
}
