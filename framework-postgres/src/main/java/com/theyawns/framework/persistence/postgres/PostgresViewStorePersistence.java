package com.theyawns.framework.persistence.postgres;

import com.theyawns.framework.persistence.PersistableView;
import com.theyawns.framework.persistence.ViewStorePersistence;
import com.theyawns.framework.persistence.postgres.entity.ViewStoreEntity;
import com.theyawns.framework.persistence.postgres.repository.ViewStoreRepository;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.jdbc.core.JdbcTemplate;
import org.springframework.transaction.annotation.Transactional;

import java.util.List;
import java.util.Optional;

/**
 * PostgreSQL implementation of {@link ViewStorePersistence}.
 *
 * <p>Uses upsert semantics (INSERT ... ON CONFLICT DO UPDATE) to ensure that
 * the latest materialized view state always wins. JDBC batch operations are
 * used for {@link #persistBatch(String, List)}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
public class PostgresViewStorePersistence implements ViewStorePersistence {

    private static final Logger logger = LoggerFactory.getLogger(PostgresViewStorePersistence.class);

    private static final String UPSERT_SQL =
            "INSERT INTO domain_views (view_name, view_key, view_data, last_updated_millis, updated_at) " +
            "VALUES (?, ?, ?::jsonb, ?, NOW()) " +
            "ON CONFLICT (view_name, view_key) DO UPDATE SET " +
            "view_data = EXCLUDED.view_data, " +
            "last_updated_millis = EXCLUDED.last_updated_millis, " +
            "updated_at = NOW()";

    private final ViewStoreRepository repository;
    private final JdbcTemplate jdbcTemplate;

    /**
     * Creates a new PostgresViewStorePersistence.
     *
     * @param repository the JPA repository
     * @param jdbcTemplate the JDBC template for batch operations
     */
    public PostgresViewStorePersistence(ViewStoreRepository repository, JdbcTemplate jdbcTemplate) {
        this.repository = repository;
        this.jdbcTemplate = jdbcTemplate;
    }

    @Override
    @Transactional
    public void persist(String viewName, PersistableView view) {
        jdbcTemplate.update(UPSERT_SQL,
                viewName, view.viewKey(), view.viewData(), view.lastUpdatedMillis());
        logger.debug("Persisted view entry {} for view {}", view.viewKey(), viewName);
    }

    @Override
    @Transactional
    public void persistBatch(String viewName, List<PersistableView> views) {
        if (views.isEmpty()) {
            return;
        }

        jdbcTemplate.batchUpdate(UPSERT_SQL, views, views.size(),
                (ps, view) -> {
                    ps.setString(1, viewName);
                    ps.setString(2, view.viewKey());
                    ps.setString(3, view.viewData());
                    ps.setLong(4, view.lastUpdatedMillis());
                });
        logger.debug("Batch persisted {} view entries for view {}", views.size(), viewName);
    }

    @Override
    @Transactional(readOnly = true)
    public Optional<PersistableView> loadView(String viewName, String viewKey) {
        return repository.findByViewNameAndViewKey(viewName, viewKey)
                .map(this::fromEntity);
    }

    @Override
    @Transactional(readOnly = true)
    public Iterable<String> loadAllKeys(String viewName) {
        return repository.findAllViewKeysByViewName(viewName);
    }

    @Override
    @Transactional
    public void delete(String viewName, String viewKey) {
        repository.deleteByViewNameAndViewKey(viewName, viewKey);
        logger.debug("Deleted view entry {} from view {}", viewKey, viewName);
    }

    @Override
    @Transactional
    public void deleteAll(String viewName) {
        repository.deleteAllByViewName(viewName);
        logger.info("Deleted all entries for view {}", viewName);
    }

    @Override
    public boolean isAvailable() {
        try {
            jdbcTemplate.queryForObject("SELECT 1", Integer.class);
            return true;
        } catch (Exception e) {
            logger.warn("PostgreSQL persistence unavailable: {}", e.getMessage());
            return false;
        }
    }

    private PersistableView fromEntity(ViewStoreEntity entity) {
        return new PersistableView(
                entity.getViewKey(),
                entity.getViewData(),
                entity.getLastUpdatedMillis()
        );
    }
}
