package com.theyawns.ecommerce.mcp.security;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.boot.web.servlet.FilterRegistrationBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Auto-configuration for MCP server security.
 *
 * <p>Activates only when {@code mcp.security.enabled=true}. Creates:
 * <ul>
 *   <li>{@link ToolAuthorizer} — checks tool-level access based on role</li>
 *   <li>{@link McpApiKeyFilter} — validates API keys on HTTP requests
 *       (only in servlet web application mode)</li>
 * </ul>
 *
 * <p>In stdio mode, the API key is read from the environment variable specified
 * by {@link McpSecurityProperties#getApiKeyEnvVar()} (default: {@code MCP_API_KEY}).
 * The resolved role is set as the session-level role on the {@link ToolAuthorizer}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@Configuration
@ConditionalOnProperty(name = "mcp.security.enabled", havingValue = "true")
@EnableConfigurationProperties(McpSecurityProperties.class)
public class McpSecurityAutoConfiguration {

    private static final Logger logger = LoggerFactory.getLogger(McpSecurityAutoConfiguration.class);

    /**
     * Creates the {@link ToolAuthorizer} bean.
     *
     * <p>Resolves the session role from the environment variable API key
     * (stdio mode). In HTTP/SSE mode, the per-request role is set by
     * {@link McpApiKeyFilter} and takes precedence.
     *
     * @param properties the MCP security configuration
     * @return the configured ToolAuthorizer
     */
    @Bean
    public ToolAuthorizer toolAuthorizer(final McpSecurityProperties properties) {
        // Resolve session role from environment variable (stdio mode)
        final String envVar = properties.getApiKeyEnvVar();
        final String apiKey = System.getenv(envVar);
        McpRole sessionRole = null;

        if (apiKey != null && !apiKey.isBlank()) {
            sessionRole = properties.resolveRole(apiKey);
            if (sessionRole != null) {
                logger.info("MCP session role resolved from {}: {}", envVar, sessionRole);
            } else {
                logger.warn("API key from {} is not recognized — defaulting to VIEWER", envVar);
                sessionRole = McpRole.VIEWER;
            }
        } else {
            logger.info("No API key found in {} — HTTP/SSE mode will use per-request keys", envVar);
        }

        return new ToolAuthorizer(sessionRole);
    }

    /**
     * Registers the {@link McpApiKeyFilter} for HTTP/SSE mode.
     *
     * <p>Only created when the application is running as a servlet web
     * application (Docker profile with {@code spring.main.web-application-type=servlet}).
     *
     * @param properties the MCP security configuration
     * @return the filter registration bean
     */
    @Bean
    @ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
    public FilterRegistrationBean<McpApiKeyFilter> mcpApiKeyFilterRegistration(
            final McpSecurityProperties properties) {
        logger.info("Registering McpApiKeyFilter for HTTP/SSE mode");
        final FilterRegistrationBean<McpApiKeyFilter> registration = new FilterRegistrationBean<>();
        registration.setFilter(new McpApiKeyFilter(properties));
        registration.addUrlPatterns("/*");
        registration.setOrder(1);
        return registration;
    }
}
