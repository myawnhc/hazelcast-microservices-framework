package com.theyawns.ecommerce.mcp.tools;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.theyawns.ecommerce.mcp.client.ServiceClientOperations;
import com.theyawns.ecommerce.mcp.security.ToolAuthorizer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.UUID;

/**
 * MCP tool for running demo scenarios against the eCommerce microservices.
 *
 * <p>Provides pre-built scenarios that create entities and trigger workflows
 * to demonstrate the event sourcing framework and saga patterns.
 *
 * <p>Available scenarios:
 * <ul>
 *   <li>{@code happy_path} - Creates a customer, product, and order that completes successfully</li>
 *   <li>{@code payment_failure} - Creates an order with a high total that triggers payment failure</li>
 *   <li>{@code saga_timeout} - Creates an order designed to exceed the saga timeout deadline</li>
 *   <li>{@code orchestrated_happy_path} - Like happy_path but uses the orchestrated saga endpoint</li>
 *   <li>{@code orchestrated_payment_failure} - Like payment_failure but uses the orchestrated saga endpoint</li>
 *   <li>{@code load_sample_data} - Creates a set of sample customers and products for testing</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@Service
public class RunDemoTool {

    private static final Logger logger = LoggerFactory.getLogger(RunDemoTool.class);

    private final ServiceClientOperations serviceClient;
    private final ObjectMapper objectMapper;
    private ToolAuthorizer toolAuthorizer;

    /**
     * Creates a new RunDemoTool.
     *
     * @param serviceClient the REST client for service communication
     */
    public RunDemoTool(ServiceClientOperations serviceClient) {
        this.serviceClient = serviceClient;
        this.objectMapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
    }

    /**
     * Sets the tool authorizer for role-based access control.
     *
     * @param toolAuthorizer the authorizer (injected only when security is enabled)
     */
    @Autowired(required = false)
    public void setToolAuthorizer(final ToolAuthorizer toolAuthorizer) {
        this.toolAuthorizer = toolAuthorizer;
    }

    /**
     * Runs a demo scenario against the microservices.
     *
     * @param scenario the scenario to run
     * @return JSON string with the scenario results
     */
    @Tool(description = "Run a demo scenario. Available scenarios: "
            + "happy_path (successful choreographed order), payment_failure (triggers payment rejection), "
            + "saga_timeout (triggers saga timeout), "
            + "orchestrated_happy_path (successful orchestrated order), "
            + "orchestrated_payment_failure (orchestrated order with payment rejection), "
            + "load_sample_data (creates sample entities)")
    public String runDemo(
            @ToolParam(description = "Scenario: happy_path, payment_failure, saga_timeout, "
                    + "orchestrated_happy_path, orchestrated_payment_failure, or load_sample_data")
            String scenario) {

        if (toolAuthorizer != null) {
            String denied = toolAuthorizer.checkAccess("runDemo");
            if (denied != null) {
                return denied;
            }
        }

        logger.info("MCP runDemo: scenario={}", scenario);

        try {
            Map<String, Object> result = switch (scenario) {
                case "happy_path" -> runHappyPath();
                case "payment_failure" -> runPaymentFailure();
                case "saga_timeout" -> runSagaTimeout();
                case "orchestrated_happy_path" -> runOrchestratedHappyPath();
                case "orchestrated_payment_failure" -> runOrchestratedPaymentFailure();
                case "load_sample_data" -> runLoadSampleData();
                default -> throw new IllegalArgumentException("Unknown scenario: " + scenario
                        + ". Available: happy_path, payment_failure, saga_timeout, "
                        + "orchestrated_happy_path, orchestrated_payment_failure, load_sample_data");
            };
            return toJson(result);
        } catch (IllegalArgumentException e) {
            return toJson(Map.of("error", e.getMessage()));
        } catch (Exception e) {
            logger.error("Failed to run demo scenario: {}", scenario, e);
            return toJson(Map.of("error", "Failed to run scenario: " + e.getMessage()));
        }
    }

    /**
     * Runs the happy path scenario: customer + product + order that succeeds.
     */
    private Map<String, Object> runHappyPath() {
        Map<String, Object> result = new LinkedHashMap<>();
        result.put("scenario", "happy_path");
        result.put("description", "Creates a customer, product, and order that completes successfully");
        List<Map<String, Object>> steps = new ArrayList<>();

        // Step 1: Create customer
        Map<String, Object> customer = serviceClient.createEntity("customer", Map.of(
                "name", "Demo Customer",
                "email", "demo-" + shortId() + "@example.com",
                "address", "123 Demo Street"
        ));
        steps.add(Map.of("step", "CreateCustomer", "result", customer));

        // Step 2: Create product
        Map<String, Object> product = serviceClient.createEntity("product", Map.of(
                "sku", "DEMO-" + shortId(),
                "name", "Demo Widget",
                "price", "29.99",
                "quantityOnHand", 100
        ));
        steps.add(Map.of("step", "CreateProduct", "result", product));

        // Step 3: Create order (reasonable total within payment limit)
        String customerId = extractId(customer, "customerId");
        String productId = extractId(product, "productId");
        Map<String, Object> order = serviceClient.createEntity("order", Map.of(
                "customerId", customerId,
                "customerName", "Demo Customer",
                "shippingAddress", "123 Demo Street",
                "lineItems", List.of(Map.of(
                        "productId", productId,
                        "productName", "Demo Widget",
                        "sku", "DEMO-001",
                        "quantity", 2,
                        "unitPrice", 29.99
                ))
        ));
        steps.add(Map.of("step", "CreateOrder", "result", order));

        result.put("steps", steps);
        return result;
    }

    /**
     * Runs the payment failure scenario: high-value order exceeds payment limit.
     */
    private Map<String, Object> runPaymentFailure() {
        Map<String, Object> result = new LinkedHashMap<>();
        result.put("scenario", "payment_failure");
        result.put("description", "Creates a high-value order that triggers payment rejection (>$10,000)");
        List<Map<String, Object>> steps = new ArrayList<>();

        // Step 1: Create customer
        Map<String, Object> customer = serviceClient.createEntity("customer", Map.of(
                "name", "Big Spender",
                "email", "bigspender-" + shortId() + "@example.com",
                "address", "456 Expensive Ave"
        ));
        steps.add(Map.of("step", "CreateCustomer", "result", customer));

        // Step 2: Create expensive product
        Map<String, Object> product = serviceClient.createEntity("product", Map.of(
                "sku", "EXPENSIVE-" + shortId(),
                "name", "Premium Item",
                "price", "5500.00",
                "quantityOnHand", 50
        ));
        steps.add(Map.of("step", "CreateProduct", "result", product));

        // Step 3: Create order with total > $10,000
        String customerId = extractId(customer, "customerId");
        String productId = extractId(product, "productId");
        Map<String, Object> order = serviceClient.createEntity("order", Map.of(
                "customerId", customerId,
                "customerName", "Big Spender",
                "shippingAddress", "456 Expensive Ave",
                "lineItems", List.of(Map.of(
                        "productId", productId,
                        "productName", "Premium Item",
                        "sku", "EXPENSIVE-001",
                        "quantity", 3,
                        "unitPrice", 5500.00
                ))
        ));
        steps.add(Map.of("step", "CreateOrder", "result", order));

        result.put("steps", steps);
        result.put("expectedOutcome", "Payment should be rejected (total > $10,000), "
                + "triggering saga compensation with stock release");
        return result;
    }

    /**
     * Runs the saga timeout scenario: creates an order designed to timeout.
     */
    private Map<String, Object> runSagaTimeout() {
        Map<String, Object> result = new LinkedHashMap<>();
        result.put("scenario", "saga_timeout");
        result.put("description", "Creates an order that will exceed the saga timeout deadline");
        List<Map<String, Object>> steps = new ArrayList<>();

        // Step 1: Create customer
        Map<String, Object> customer = serviceClient.createEntity("customer", Map.of(
                "name", "Timeout Customer",
                "email", "timeout-" + shortId() + "@example.com",
                "address", "789 Slow Lane"
        ));
        steps.add(Map.of("step", "CreateCustomer", "result", customer));

        // Step 2: Create product with very low stock (may cause delays)
        Map<String, Object> product = serviceClient.createEntity("product", Map.of(
                "sku", "TIMEOUT-" + shortId(),
                "name", "Timeout Test Item",
                "price", "19.99",
                "quantityOnHand", 1
        ));
        steps.add(Map.of("step", "CreateProduct", "result", product));

        // Step 3: Create order
        String customerId = extractId(customer, "customerId");
        String productId = extractId(product, "productId");
        Map<String, Object> order = serviceClient.createEntity("order", Map.of(
                "customerId", customerId,
                "customerName", "Timeout Customer",
                "shippingAddress", "789 Slow Lane",
                "lineItems", List.of(Map.of(
                        "productId", productId,
                        "productName", "Timeout Test Item",
                        "sku", "TIMEOUT-001",
                        "quantity", 1,
                        "unitPrice", 19.99
                ))
        ));
        steps.add(Map.of("step", "CreateOrder", "result", order));

        result.put("steps", steps);
        result.put("expectedOutcome", "If saga timeout is configured with a short deadline, "
                + "the saga may time out before all steps complete");
        return result;
    }

    /**
     * Runs the orchestrated happy path scenario: customer + product + orchestrated order.
     */
    private Map<String, Object> runOrchestratedHappyPath() {
        Map<String, Object> result = new LinkedHashMap<>();
        result.put("scenario", "orchestrated_happy_path");
        result.put("sagaPattern", "orchestrated");
        result.put("description", "Creates a customer, product, and order via the orchestrated saga endpoint");
        List<Map<String, Object>> steps = new ArrayList<>();

        // Step 1: Create customer
        Map<String, Object> customer = serviceClient.createEntity("customer", Map.of(
                "name", "Orchestrated Customer",
                "email", "orch-" + shortId() + "@example.com",
                "address", "100 Orchestrated Blvd"
        ));
        steps.add(Map.of("step", "CreateCustomer", "result", customer));

        // Step 2: Create product
        Map<String, Object> product = serviceClient.createEntity("product", Map.of(
                "sku", "ORCH-" + shortId(),
                "name", "Orchestrated Widget",
                "price", "39.99",
                "quantityOnHand", 100
        ));
        steps.add(Map.of("step", "CreateProduct", "result", product));

        // Step 3: Create order via orchestrated endpoint
        String customerId = extractId(customer, "customerId");
        String productId = extractId(product, "productId");
        Map<String, Object> order = serviceClient.createOrchestratedOrder(Map.of(
                "customerId", customerId,
                "customerName", "Orchestrated Customer",
                "shippingAddress", "100 Orchestrated Blvd",
                "lineItems", List.of(Map.of(
                        "productId", productId,
                        "productName", "Orchestrated Widget",
                        "sku", "ORCH-001",
                        "quantity", 2,
                        "unitPrice", 39.99
                ))
        ));
        steps.add(Map.of("step", "CreateOrchestratedOrder", "result", order));

        result.put("steps", steps);
        return result;
    }

    /**
     * Runs the orchestrated payment failure scenario: high-value orchestrated order.
     */
    private Map<String, Object> runOrchestratedPaymentFailure() {
        Map<String, Object> result = new LinkedHashMap<>();
        result.put("scenario", "orchestrated_payment_failure");
        result.put("sagaPattern", "orchestrated");
        result.put("description", "Creates a high-value order via orchestrated saga that triggers payment rejection (>$10,000)");
        List<Map<String, Object>> steps = new ArrayList<>();

        // Step 1: Create customer
        Map<String, Object> customer = serviceClient.createEntity("customer", Map.of(
                "name", "Orchestrated Big Spender",
                "email", "orch-spender-" + shortId() + "@example.com",
                "address", "456 Orchestrated Ave"
        ));
        steps.add(Map.of("step", "CreateCustomer", "result", customer));

        // Step 2: Create expensive product
        Map<String, Object> product = serviceClient.createEntity("product", Map.of(
                "sku", "ORCH-EXP-" + shortId(),
                "name", "Premium Orchestrated Item",
                "price", "5500.00",
                "quantityOnHand", 50
        ));
        steps.add(Map.of("step", "CreateProduct", "result", product));

        // Step 3: Create orchestrated order with total > $10,000
        String customerId = extractId(customer, "customerId");
        String productId = extractId(product, "productId");
        Map<String, Object> order = serviceClient.createOrchestratedOrder(Map.of(
                "customerId", customerId,
                "customerName", "Orchestrated Big Spender",
                "shippingAddress", "456 Orchestrated Ave",
                "lineItems", List.of(Map.of(
                        "productId", productId,
                        "productName", "Premium Orchestrated Item",
                        "sku", "ORCH-EXP-001",
                        "quantity", 3,
                        "unitPrice", 5500.00
                ))
        ));
        steps.add(Map.of("step", "CreateOrchestratedOrder", "result", order));

        result.put("steps", steps);
        result.put("expectedOutcome", "Payment should be rejected (total > $10,000), "
                + "triggering orchestrated saga compensation with stock release");
        return result;
    }

    /**
     * Runs the load sample data scenario: creates a set of sample entities.
     */
    private Map<String, Object> runLoadSampleData() {
        Map<String, Object> result = new LinkedHashMap<>();
        result.put("scenario", "load_sample_data");
        result.put("description", "Creates sample customers and products for testing");
        List<Map<String, Object>> steps = new ArrayList<>();

        // Create sample customers
        String[][] customers = {
                {"Alice Johnson", "alice@example.com", "100 Main St"},
                {"Bob Smith", "bob@example.com", "200 Oak Ave"},
                {"Carol Williams", "carol@example.com", "300 Pine Rd"}
        };
        for (String[] c : customers) {
            Map<String, Object> customer = serviceClient.createEntity("customer", Map.of(
                    "name", c[0],
                    "email", c[1].replace("@", "-" + shortId() + "@"),
                    "address", c[2]
            ));
            steps.add(Map.of("step", "CreateCustomer", "name", c[0], "result", customer));
        }

        // Create sample products
        String[][] products = {
                {"SKU-WIDGET", "Standard Widget", "9.99", "500"},
                {"SKU-GADGET", "Premium Gadget", "49.99", "200"},
                {"SKU-GIZMO", "Deluxe Gizmo", "99.99", "100"}
        };
        for (String[] p : products) {
            Map<String, Object> product = serviceClient.createEntity("product", Map.of(
                    "sku", p[0] + "-" + shortId(),
                    "name", p[1],
                    "price", p[2],
                    "quantityOnHand", Integer.parseInt(p[3])
            ));
            steps.add(Map.of("step", "CreateProduct", "name", p[1], "result", product));
        }

        result.put("steps", steps);
        result.put("entitiesCreated", Map.of("customers", customers.length, "products", products.length));
        return result;
    }

    /**
     * Extracts an ID field from a service response, falling back to "unknown".
     *
     * @param response the service response map
     * @param field the field name to extract
     * @return the extracted ID, or "unknown" if not found
     */
    private String extractId(Map<String, Object> response, String field) {
        Object value = response.get(field);
        return value != null ? value.toString() : "unknown";
    }

    /**
     * Generates a short unique ID fragment for demo data uniqueness.
     *
     * @return a short UUID fragment
     */
    private String shortId() {
        return UUID.randomUUID().toString().substring(0, 8);
    }

    private String toJson(Object value) {
        try {
            return objectMapper.writeValueAsString(value);
        } catch (JsonProcessingException e) {
            logger.error("Failed to serialize result", e);
            return "{\"error\": \"Failed to serialize result\"}";
        }
    }
}
