package com.theyawns.ecommerce.mcp.tools;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.theyawns.ecommerce.mcp.client.ServiceClientOperations;
import com.theyawns.ecommerce.mcp.security.ToolAuthorizer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Map;

/**
 * MCP tool for submitting domain events to the eCommerce microservices.
 *
 * <p>Maps event types to the correct service endpoints:
 * <table>
 *   <tr><th>Event Type</th><th>HTTP Method</th><th>Endpoint</th></tr>
 *   <tr><td>CreateCustomer</td><td>POST</td><td>/api/customers</td></tr>
 *   <tr><td>CreateProduct</td><td>POST</td><td>/api/products</td></tr>
 *   <tr><td>CreateOrder</td><td>POST</td><td>/api/orders</td></tr>
 *   <tr><td>CancelOrder</td><td>PATCH</td><td>/api/orders/{id}/cancel</td></tr>
 *   <tr><td>ReserveStock</td><td>POST</td><td>/api/products/{id}/stock/reserve</td></tr>
 *   <tr><td>ProcessPayment</td><td>POST</td><td>/api/payments</td></tr>
 *   <tr><td>RefundPayment</td><td>POST</td><td>/api/payments/{id}/refund</td></tr>
 * </table>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@Service
public class SubmitEventTool {

    private static final Logger logger = LoggerFactory.getLogger(SubmitEventTool.class);

    private final ServiceClientOperations serviceClient;
    private final ObjectMapper objectMapper;
    private ToolAuthorizer toolAuthorizer;

    /**
     * Creates a new SubmitEventTool.
     *
     * @param serviceClient the REST client for service communication
     */
    public SubmitEventTool(ServiceClientOperations serviceClient) {
        this.serviceClient = serviceClient;
        this.objectMapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
    }

    /**
     * Sets the tool authorizer for role-based access control.
     *
     * @param toolAuthorizer the authorizer (injected only when security is enabled)
     */
    @Autowired(required = false)
    public void setToolAuthorizer(final ToolAuthorizer toolAuthorizer) {
        this.toolAuthorizer = toolAuthorizer;
    }

    /**
     * Submits a domain event to the appropriate microservice.
     *
     * @param eventType the event type (CreateCustomer, CreateProduct, CreateOrder, etc.)
     * @param payload the event payload as a JSON string
     * @return JSON string with the result
     */
    @Tool(description = "Submit a domain event. Supported event types: "
            + "CreateCustomer, CreateProduct, CreateOrder, CancelOrder, "
            + "ReserveStock, ProcessPayment, RefundPayment")
    public String submitEvent(
            @ToolParam(description = "Event type: CreateCustomer, CreateProduct, CreateOrder, "
                    + "CancelOrder, ReserveStock, ProcessPayment, or RefundPayment") String eventType,
            @ToolParam(description = "Event payload as JSON string") String payload) {

        if (toolAuthorizer != null) {
            String denied = toolAuthorizer.checkAccess("submitEvent");
            if (denied != null) {
                return denied;
            }
        }

        logger.info("MCP submitEvent: type={}", eventType);

        try {
            Map<String, Object> payloadMap = parsePayload(payload);
            Map<String, Object> result = dispatch(eventType, payloadMap);
            return toJson(Map.of("eventType", eventType, "result", result));
        } catch (IllegalArgumentException e) {
            return toJson(Map.of("error", e.getMessage()));
        } catch (Exception e) {
            logger.error("Failed to submit event: {}", eventType, e);
            return toJson(Map.of("error", "Failed to submit event: " + e.getMessage()));
        }
    }

    /**
     * Dispatches an event to the correct service endpoint based on event type.
     *
     * @param eventType the event type
     * @param payload the parsed payload
     * @return the service response as a map
     */
    Map<String, Object> dispatch(String eventType, Map<String, Object> payload) {
        return switch (eventType) {
            case "CreateCustomer" -> serviceClient.createEntity("customer", payload);
            case "CreateProduct" -> serviceClient.createEntity("product", payload);
            case "CreateOrder" -> serviceClient.createEntity("order", payload);
            case "CancelOrder" -> {
                String orderId = requireField(payload, "orderId");
                yield serviceClient.performAction("order", orderId, "cancel", payload, true);
            }
            case "ReserveStock" -> {
                String productId = requireField(payload, "productId");
                yield serviceClient.performAction("product", productId, "stock/reserve", payload, false);
            }
            case "ProcessPayment" -> serviceClient.createEntity("payment", payload);
            case "RefundPayment" -> {
                String paymentId = requireField(payload, "paymentId");
                yield serviceClient.performAction("payment", paymentId, "refund", payload, false);
            }
            default -> throw new IllegalArgumentException("Unknown event type: " + eventType
                    + ". Supported types: CreateCustomer, CreateProduct, CreateOrder, "
                    + "CancelOrder, ReserveStock, ProcessPayment, RefundPayment");
        };
    }

    private String requireField(Map<String, Object> payload, String field) {
        Object value = payload.get(field);
        if (value == null || value.toString().isBlank()) {
            throw new IllegalArgumentException("Payload must include '" + field + "' for this event type");
        }
        return value.toString();
    }

    private Map<String, Object> parsePayload(String payload) {
        try {
            return objectMapper.readValue(payload, new TypeReference<>() {});
        } catch (JsonProcessingException e) {
            throw new IllegalArgumentException("Invalid JSON payload: " + e.getMessage());
        }
    }

    private String toJson(Object value) {
        try {
            return objectMapper.writeValueAsString(value);
        } catch (JsonProcessingException e) {
            logger.error("Failed to serialize result", e);
            return "{\"error\": \"Failed to serialize result\"}";
        }
    }
}
