package com.theyawns.ecommerce.mcp.tools;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.SerializationFeature;
import com.theyawns.ecommerce.mcp.client.ServiceClientOperations;
import com.theyawns.ecommerce.mcp.security.ToolAuthorizer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.ai.tool.annotation.Tool;
import org.springframework.ai.tool.annotation.ToolParam;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;

/**
 * MCP tool for retrieving event history for domain entities.
 *
 * <p>Allows AI assistants to inspect the full event history of an entity,
 * which is useful for understanding how the current state was derived and
 * for debugging issues.
 *
 * <p>Supported aggregate types:
 * <ul>
 *   <li>{@code Customer} - Customer account events</li>
 *   <li>{@code Product} - Product/inventory events</li>
 *   <li>{@code Order} - Order lifecycle events</li>
 *   <li>{@code Payment} - Payment processing events</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@Service
public class GetEventHistoryTool {

    private static final Logger logger = LoggerFactory.getLogger(GetEventHistoryTool.class);
    private static final int DEFAULT_LIMIT = 20;

    private final ServiceClientOperations serviceClient;
    private final ObjectMapper objectMapper;
    private ToolAuthorizer toolAuthorizer;

    /**
     * Creates a new GetEventHistoryTool.
     *
     * @param serviceClient the REST client for service communication
     */
    public GetEventHistoryTool(ServiceClientOperations serviceClient) {
        this.serviceClient = serviceClient;
        this.objectMapper = new ObjectMapper().enable(SerializationFeature.INDENT_OUTPUT);
    }

    /**
     * Sets the tool authorizer for role-based access control.
     *
     * @param toolAuthorizer the authorizer (injected only when security is enabled)
     */
    @Autowired(required = false)
    public void setToolAuthorizer(final ToolAuthorizer toolAuthorizer) {
        this.toolAuthorizer = toolAuthorizer;
    }

    /**
     * Retrieves event history for a domain entity.
     *
     * @param aggregateId the entity ID
     * @param aggregateType the aggregate type: Customer, Product, Order, or Payment
     * @param limit maximum events to return (default: 20)
     * @return JSON string with the event history
     */
    @Tool(description = "Get event history for a domain entity. "
            + "Aggregate types: Customer, Product, Order, Payment")
    public String getEventHistory(
            @ToolParam(description = "Entity ID") String aggregateId,
            @ToolParam(description = "Aggregate type: Customer, Product, Order, or Payment") String aggregateType,
            @ToolParam(description = "Maximum events to return (default: 20)", required = false) Integer limit) {

        if (toolAuthorizer != null) {
            String denied = toolAuthorizer.checkAccess("getEventHistory");
            if (denied != null) {
                return denied;
            }
        }

        logger.info("MCP getEventHistory: type={}, id={}, limit={}", aggregateType, aggregateId, limit);

        try {
            String viewName = mapAggregateTypeToView(aggregateType);
            int effectiveLimit = (limit != null && limit > 0) ? limit : DEFAULT_LIMIT;

            List<Map<String, Object>> events = serviceClient.getEventHistory(viewName, aggregateId, effectiveLimit);

            return toJson(Map.of(
                    "aggregateType", aggregateType,
                    "aggregateId", aggregateId,
                    "eventCount", events.size(),
                    "events", events
            ));
        } catch (IllegalArgumentException e) {
            return toJson(Map.of("error", e.getMessage()));
        }
    }

    /**
     * Maps an aggregate type name to the corresponding view name.
     *
     * @param aggregateType the aggregate type
     * @return the view name
     * @throws IllegalArgumentException if aggregate type is unknown
     */
    String mapAggregateTypeToView(String aggregateType) {
        return switch (aggregateType) {
            case "Customer" -> "customer";
            case "Product" -> "product";
            case "Order" -> "order";
            case "Payment" -> "payment";
            default -> throw new IllegalArgumentException("Unknown aggregate type: " + aggregateType
                    + ". Available types: Customer, Product, Order, Payment");
        };
    }

    private String toJson(Object value) {
        try {
            return objectMapper.writeValueAsString(value);
        } catch (JsonProcessingException e) {
            logger.error("Failed to serialize result", e);
            return "{\"error\": \"Failed to serialize result\"}";
        }
    }
}
