package com.theyawns.ecommerce.mcp.security;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;

/**
 * Authorizes tool invocations based on the current session's {@link McpRole}.
 *
 * <p>Each tool method calls {@link #checkAccess(String)} before executing. If the
 * current role does not permit the tool, a JSON error string is returned that the
 * tool method can return directly to the AI assistant. If access is permitted,
 * {@code null} is returned and the tool proceeds normally.
 *
 * <p>The role is set either:
 * <ul>
 *   <li><strong>Stdio mode</strong>: at startup from the {@code MCP_API_KEY}
 *       environment variable (single role for the entire process lifetime)</li>
 *   <li><strong>HTTP/SSE mode</strong>: per-request by {@link McpApiKeyFilter}
 *       via a {@link ThreadLocal}</li>
 * </ul>
 *
 * <p>This class is thread-safe.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
public class ToolAuthorizer {

    private static final Logger logger = LoggerFactory.getLogger(ToolAuthorizer.class);
    private static final ObjectMapper OBJECT_MAPPER = new ObjectMapper();

    /**
     * Per-request role for HTTP/SSE mode. Set by {@link McpApiKeyFilter}.
     */
    private static final ThreadLocal<McpRole> REQUEST_ROLE = new ThreadLocal<>();

    /**
     * Session-level role for stdio mode. Set once at startup.
     */
    private volatile McpRole sessionRole;

    /**
     * Creates a new ToolAuthorizer with the given session role.
     *
     * @param sessionRole the default role for stdio mode (may be null if HTTP-only)
     */
    public ToolAuthorizer(final McpRole sessionRole) {
        this.sessionRole = sessionRole;
    }

    /**
     * Checks whether the current role permits access to the named tool.
     *
     * <p>Returns {@code null} if access is permitted, or a JSON error string
     * if access is denied. The calling tool method should return the error
     * string directly to the AI assistant.
     *
     * @param toolName the tool name (e.g., "queryView", "submitEvent")
     * @return null if access is permitted, or a JSON error string if denied
     */
    public String checkAccess(final String toolName) {
        McpRole role = getCurrentRole();
        if (role == null) {
            logger.warn("No role set for MCP session â€” denying access to tool '{}'", toolName);
            return accessDeniedJson(toolName, "No valid API key provided");
        }
        if (!role.canAccess(toolName)) {
            logger.warn("Role {} denied access to tool '{}'", role, toolName);
            return accessDeniedJson(toolName, "Role " + role + " does not have permission to use '" + toolName + "'");
        }
        if (logger.isDebugEnabled()) {
            logger.debug("Role {} granted access to tool '{}'", role, toolName);
        }
        return null;
    }

    /**
     * Returns the current role, preferring the per-request role (HTTP mode)
     * over the session role (stdio mode).
     *
     * @return the current role, or null if none is set
     */
    public McpRole getCurrentRole() {
        McpRole perRequest = REQUEST_ROLE.get();
        return perRequest != null ? perRequest : sessionRole;
    }

    /**
     * Sets the per-request role. Called by {@link McpApiKeyFilter}.
     *
     * @param role the role for the current request
     */
    public static void setRequestRole(final McpRole role) {
        REQUEST_ROLE.set(role);
    }

    /**
     * Clears the per-request role. Called by {@link McpApiKeyFilter} after
     * request processing.
     */
    public static void clearRequestRole() {
        REQUEST_ROLE.remove();
    }

    /**
     * Returns the session role (stdio mode).
     *
     * @return the session role
     */
    public McpRole getSessionRole() {
        return sessionRole;
    }

    private String accessDeniedJson(final String toolName, final String reason) {
        try {
            return OBJECT_MAPPER.writeValueAsString(Map.of(
                    "error", "access_denied",
                    "tool", toolName,
                    "message", reason
            ));
        } catch (JsonProcessingException e) {
            return "{\"error\":\"access_denied\",\"tool\":\"" + toolName + "\"}";
        }
    }
}
