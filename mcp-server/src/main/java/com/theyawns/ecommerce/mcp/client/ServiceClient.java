package com.theyawns.ecommerce.mcp.client;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.theyawns.ecommerce.mcp.config.McpServerProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Component;
import org.springframework.web.client.RestClient;
import org.springframework.web.client.RestClientResponseException;

import java.util.List;
import java.util.Map;

/**
 * REST client wrapper for communicating with eCommerce microservices.
 *
 * <p>Provides a thin abstraction over Spring's {@link RestClient} that maps
 * view/aggregate names to service URLs and endpoint paths. All methods return
 * deserialized JSON as maps or lists of maps.
 *
 * <p>This is the only component that makes HTTP calls to the services. The MCP
 * tools delegate to this client rather than making HTTP calls directly.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@Component
public class ServiceClient implements ServiceClientOperations {

    private static final Logger logger = LoggerFactory.getLogger(ServiceClient.class);

    private final McpServerProperties properties;
    private final RestClient restClient;
    private final ObjectMapper objectMapper;

    /**
     * Creates a new ServiceClient.
     *
     * @param properties the service URL configuration
     */
    public ServiceClient(McpServerProperties properties) {
        this.properties = properties;
        this.restClient = RestClient.create();
        this.objectMapper = new ObjectMapper();
    }

    /**
     * Constructor for testing with a custom RestClient.
     *
     * @param properties the service URL configuration
     * @param restClient the REST client to use
     * @param objectMapper the object mapper to use
     */
    ServiceClient(McpServerProperties properties, RestClient restClient, ObjectMapper objectMapper) {
        this.properties = properties;
        this.restClient = restClient;
        this.objectMapper = objectMapper;
    }

    /**
     * Retrieves a single entity by ID.
     *
     * @param viewName the view name (customer, product, order, payment)
     * @param id the entity ID
     * @return the entity as a map, or an error map if not found
     */
    public Map<String, Object> getEntity(String viewName, String id) {
        String url = resolveUrl(viewName) + "/" + id;
        logger.debug("GET {}", url);

        try {
            String json = restClient.get()
                    .uri(url)
                    .retrieve()
                    .body(String.class);
            return parseMap(json);
        } catch (RestClientResponseException e) {
            logger.warn("Failed to get entity {} with id {}: {} {}", viewName, id,
                    e.getStatusCode(), e.getStatusText());
            return Map.of("error", "Entity not found",
                    "viewName", viewName,
                    "id", id,
                    "status", e.getStatusCode().value());
        }
    }

    /**
     * Lists entities from a service, up to the specified limit.
     *
     * @param viewName the view name (customer, product, order, payment)
     * @param limit the maximum number of entities to return
     * @return list of entities as maps, or a list with a single error map
     */
    public List<Map<String, Object>> listEntities(String viewName, int limit) {
        String url = resolveUrl(viewName) + "?limit=" + limit;
        logger.debug("GET {}", url);

        try {
            String json = restClient.get()
                    .uri(url)
                    .retrieve()
                    .body(String.class);
            return parseList(json);
        } catch (RestClientResponseException e) {
            logger.warn("Failed to list entities for {}: {} {}", viewName,
                    e.getStatusCode(), e.getStatusText());
            return List.of(Map.of("error", "Failed to list entities",
                    "viewName", viewName,
                    "status", e.getStatusCode().value()));
        }
    }

    /**
     * Creates a new entity by POSTing to the service.
     *
     * @param viewName the view name (customer, product, order, payment)
     * @param payload the entity data as a map
     * @return the created entity as a map
     */
    public Map<String, Object> createEntity(String viewName, Map<String, Object> payload) {
        String url = resolveUrl(viewName);
        logger.debug("POST {}", url);

        try {
            String json = restClient.post()
                    .uri(url)
                    .header("Content-Type", "application/json")
                    .body(toJson(payload))
                    .retrieve()
                    .body(String.class);
            return parseMap(json);
        } catch (RestClientResponseException e) {
            logger.warn("Failed to create entity for {}: {} {}", viewName,
                    e.getStatusCode(), e.getStatusText());
            return Map.of("error", "Failed to create entity",
                    "viewName", viewName,
                    "status", e.getStatusCode().value(),
                    "message", e.getResponseBodyAsString());
        }
    }

    /**
     * Performs an action on an entity (e.g., cancel order, refund payment).
     *
     * @param viewName the view name
     * @param id the entity ID
     * @param action the action path (e.g., "cancel", "refund")
     * @param payload the action payload (may be empty)
     * @param usePatch true to use PATCH, false to use POST
     * @return the result as a map
     */
    public Map<String, Object> performAction(String viewName, String id, String action,
                                              Map<String, Object> payload, boolean usePatch) {
        String url = resolveUrl(viewName) + "/" + id + "/" + action;
        logger.debug("{} {}", usePatch ? "PATCH" : "POST", url);

        try {
            String body = toJson(payload);
            String json;
            if (usePatch) {
                json = restClient.patch()
                        .uri(url)
                        .header("Content-Type", "application/json")
                        .body(body)
                        .retrieve()
                        .body(String.class);
            } else {
                json = restClient.post()
                        .uri(url)
                        .header("Content-Type", "application/json")
                        .body(body)
                        .retrieve()
                        .body(String.class);
            }
            return parseMap(json);
        } catch (RestClientResponseException e) {
            logger.warn("Failed to perform action {} on {} {}: {} {}", action, viewName, id,
                    e.getStatusCode(), e.getStatusText());
            return Map.of("error", "Failed to perform action",
                    "action", action,
                    "viewName", viewName,
                    "id", id,
                    "status", e.getStatusCode().value(),
                    "message", e.getResponseBodyAsString());
        }
    }

    /**
     * Retrieves event history for a domain entity.
     *
     * @param viewName the view name (customer, product, order, payment)
     * @param id the entity ID
     * @param limit the maximum number of events to return
     * @return list of events as maps
     */
    public List<Map<String, Object>> getEventHistory(String viewName, String id, int limit) {
        String url = resolveUrl(viewName) + "/" + id + "/events?limit=" + limit;
        logger.debug("GET {}", url);

        try {
            String json = restClient.get()
                    .uri(url)
                    .retrieve()
                    .body(String.class);
            return parseList(json);
        } catch (RestClientResponseException e) {
            logger.warn("Failed to get event history for {} {}: {} {}", viewName, id,
                    e.getStatusCode(), e.getStatusText());
            return List.of(Map.of("error", "Failed to get event history",
                    "viewName", viewName,
                    "id", id,
                    "status", e.getStatusCode().value()));
        }
    }

    /**
     * Retrieves saga state by ID from the order service.
     *
     * @param sagaId the saga identifier
     * @return the saga state as a map
     */
    public Map<String, Object> getSaga(String sagaId) {
        String url = orderBaseUrl() + "/api/sagas/" + sagaId;
        logger.debug("GET {}", url);

        try {
            String json = restClient.get()
                    .uri(url)
                    .retrieve()
                    .body(String.class);
            return parseMap(json);
        } catch (RestClientResponseException e) {
            logger.warn("Failed to get saga {}: {} {}", sagaId,
                    e.getStatusCode(), e.getStatusText());
            return Map.of("error", "Saga not found",
                    "sagaId", sagaId,
                    "status", e.getStatusCode().value());
        }
    }

    /**
     * Lists sagas from the order service, optionally filtered by status and type.
     *
     * @param status optional status filter (e.g., "COMPLETED", "FAILED")
     * @param type optional saga type filter (e.g., "OrderFulfillment", "OrderFulfillmentOrchestrated")
     * @param limit the maximum number of sagas to return
     * @return list of saga states as maps
     */
    public List<Map<String, Object>> listSagas(String status, String type, int limit) {
        StringBuilder urlBuilder = new StringBuilder(orderBaseUrl())
                .append("/api/sagas?limit=").append(limit);
        if (status != null && !status.isBlank()) {
            urlBuilder.append("&status=").append(status);
        }
        if (type != null && !type.isBlank()) {
            urlBuilder.append("&type=").append(type);
        }
        String url = urlBuilder.toString();
        logger.debug("GET {}", url);

        try {
            String json = restClient.get()
                    .uri(url)
                    .retrieve()
                    .body(String.class);
            return parseList(json);
        } catch (RestClientResponseException e) {
            logger.warn("Failed to list sagas: {} {}", e.getStatusCode(), e.getStatusText());
            return List.of(Map.of("error", "Failed to list sagas",
                    "status", e.getStatusCode().value()));
        }
    }

    /**
     * Creates an order using the orchestrated saga pattern.
     *
     * @param payload the order data as a map
     * @return the created order as a map
     */
    public Map<String, Object> createOrchestratedOrder(Map<String, Object> payload) {
        String url = orderBaseUrl() + "/api/orders/orchestrated";
        logger.debug("POST {}", url);

        try {
            String json = restClient.post()
                    .uri(url)
                    .header("Content-Type", "application/json")
                    .body(toJson(payload))
                    .retrieve()
                    .body(String.class);
            return parseMap(json);
        } catch (RestClientResponseException e) {
            logger.warn("Failed to create orchestrated order: {} {}", e.getStatusCode(), e.getStatusText());
            return Map.of("error", "Failed to create orchestrated order",
                    "status", e.getStatusCode().value(),
                    "message", e.getResponseBodyAsString());
        }
    }

    /**
     * Retrieves an aggregated metrics summary from the order service.
     *
     * @return the metrics summary as a map
     */
    public Map<String, Object> getMetricsSummary() {
        String url = orderBaseUrl() + "/api/metrics/summary";
        logger.debug("GET {}", url);

        try {
            String json = restClient.get()
                    .uri(url)
                    .retrieve()
                    .body(String.class);
            return parseMap(json);
        } catch (RestClientResponseException e) {
            logger.warn("Failed to get metrics summary: {} {}", e.getStatusCode(), e.getStatusText());
            return Map.of("error", "Failed to get metrics summary",
                    "status", e.getStatusCode().value());
        }
    }

    /**
     * Resolves a view name to a full base URL with entity path.
     *
     * @param viewName the view name
     * @return the full URL (e.g., "http://localhost:8081/api/customers")
     * @throws IllegalArgumentException if view name is unknown
     */
    String resolveUrl(String viewName) {
        return switch (viewName.toLowerCase()) {
            case "customer" -> properties.resolveBaseUrl(properties.getAccountUrl()) + "/api/customers";
            case "product" -> properties.resolveBaseUrl(properties.getInventoryUrl()) + "/api/products";
            case "order" -> properties.resolveBaseUrl(properties.getOrderUrl()) + "/api/orders";
            case "payment" -> properties.resolveBaseUrl(properties.getPaymentUrl()) + "/api/payments";
            default -> throw new IllegalArgumentException("Unknown view: " + viewName
                    + ". Available views: customer, product, order, payment");
        };
    }

    /**
     * Returns the effective order service base URL (gateway or direct).
     */
    private String orderBaseUrl() {
        return properties.resolveBaseUrl(properties.getOrderUrl());
    }

    private Map<String, Object> parseMap(String json) {
        try {
            return objectMapper.readValue(json, new TypeReference<>() {});
        } catch (JsonProcessingException e) {
            logger.error("Failed to parse JSON response", e);
            return Map.of("error", "Failed to parse response", "raw", json != null ? json : "null");
        }
    }

    private List<Map<String, Object>> parseList(String json) {
        try {
            return objectMapper.readValue(json, new TypeReference<>() {});
        } catch (JsonProcessingException e) {
            logger.error("Failed to parse JSON list response", e);
            return List.of(Map.of("error", "Failed to parse response", "raw", json != null ? json : "null"));
        }
    }

    private String toJson(Map<String, Object> payload) {
        try {
            return objectMapper.writeValueAsString(payload);
        } catch (JsonProcessingException e) {
            logger.error("Failed to serialize payload", e);
            return "{}";
        }
    }
}
