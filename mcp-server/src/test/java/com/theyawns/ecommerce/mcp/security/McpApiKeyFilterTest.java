package com.theyawns.ecommerce.mcp.security;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.mock.web.MockHttpServletRequest;
import org.springframework.mock.web.MockHttpServletResponse;

import java.io.IOException;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.verifyNoInteractions;

/**
 * Tests for {@link McpApiKeyFilter}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("McpApiKeyFilter")
class McpApiKeyFilterTest {

    private McpSecurityProperties properties;
    private McpApiKeyFilter filter;
    private FilterChain filterChain;

    @BeforeEach
    void setUp() {
        properties = new McpSecurityProperties();
        properties.setEnabled(true);
        properties.setApiKeys(Map.of(
                "viewer-key", "VIEWER",
                "operator-key", "OPERATOR",
                "admin-key", "ADMIN"
        ));
        filter = new McpApiKeyFilter(properties);
        filterChain = mock(FilterChain.class);
    }

    @AfterEach
    void tearDown() {
        ToolAuthorizer.clearRequestRole();
    }

    @Test
    @DisplayName("should permit actuator requests without API key")
    void shouldPermitActuatorWithoutKey() throws ServletException, IOException {
        MockHttpServletRequest request = new MockHttpServletRequest("GET", "/actuator/health");
        MockHttpServletResponse response = new MockHttpServletResponse();

        filter.doFilterInternal(request, response, filterChain);

        verify(filterChain).doFilter(request, response);
        assertThat(response.getStatus()).isEqualTo(200);
    }

    @Test
    @DisplayName("should reject request with missing API key")
    void shouldRejectMissingKey() throws ServletException, IOException {
        MockHttpServletRequest request = new MockHttpServletRequest("POST", "/mcp/tools/call");
        MockHttpServletResponse response = new MockHttpServletResponse();

        filter.doFilterInternal(request, response, filterChain);

        verifyNoInteractions(filterChain);
        assertThat(response.getStatus()).isEqualTo(401);
        assertThat(response.getContentAsString()).contains("Missing API key");
    }

    @Test
    @DisplayName("should reject request with blank API key")
    void shouldRejectBlankKey() throws ServletException, IOException {
        MockHttpServletRequest request = new MockHttpServletRequest("POST", "/mcp/tools/call");
        request.addHeader("X-API-Key", "   ");
        MockHttpServletResponse response = new MockHttpServletResponse();

        filter.doFilterInternal(request, response, filterChain);

        verifyNoInteractions(filterChain);
        assertThat(response.getStatus()).isEqualTo(401);
    }

    @Test
    @DisplayName("should reject request with invalid API key")
    void shouldRejectInvalidKey() throws ServletException, IOException {
        MockHttpServletRequest request = new MockHttpServletRequest("POST", "/mcp/tools/call");
        request.addHeader("X-API-Key", "invalid-key-999");
        MockHttpServletResponse response = new MockHttpServletResponse();

        filter.doFilterInternal(request, response, filterChain);

        verifyNoInteractions(filterChain);
        assertThat(response.getStatus()).isEqualTo(401);
        assertThat(response.getContentAsString()).contains("Invalid API key");
    }

    @Test
    @DisplayName("should accept request with valid API key and set request role")
    void shouldAcceptValidKey() throws ServletException, IOException {
        MockHttpServletRequest request = new MockHttpServletRequest("POST", "/mcp/tools/call");
        request.addHeader("X-API-Key", "operator-key");
        MockHttpServletResponse response = new MockHttpServletResponse();

        filter.doFilterInternal(request, response, filterChain);

        verify(filterChain).doFilter(request, response);
        assertThat(response.getStatus()).isEqualTo(200);
    }

    @Test
    @DisplayName("should clear request role after filter chain completes")
    void shouldClearRequestRoleAfterFilterChain() throws ServletException, IOException {
        MockHttpServletRequest request = new MockHttpServletRequest("GET", "/mcp/tools/list");
        request.addHeader("X-API-Key", "admin-key");
        MockHttpServletResponse response = new MockHttpServletResponse();

        filter.doFilterInternal(request, response, filterChain);

        // After filter completes, the ThreadLocal should be cleared
        ToolAuthorizer authorizer = new ToolAuthorizer(null);
        assertThat(authorizer.getCurrentRole()).isNull();
    }

    @Test
    @DisplayName("should set correct role for each key type")
    void shouldSetCorrectRoleForEachKey() throws ServletException, IOException {
        // Test that the role is set correctly during filter chain execution
        // by capturing the role within the filterChain mock
        MockHttpServletRequest request = new MockHttpServletRequest("GET", "/mcp/tools/list");
        request.addHeader("X-API-Key", "viewer-key");
        MockHttpServletResponse response = new MockHttpServletResponse();

        // Use a real filter chain that verifies the role was set
        filter.doFilterInternal(request, response, (req, res) -> {
            ToolAuthorizer authorizer = new ToolAuthorizer(null);
            assertThat(authorizer.getCurrentRole()).isEqualTo(McpRole.VIEWER);
        });
    }
}
