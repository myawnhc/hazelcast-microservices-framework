package com.theyawns.ecommerce.mcp.tools;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.theyawns.ecommerce.mcp.client.ServiceClientOperations;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.atLeast;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link RunDemoTool}.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("RunDemoTool")
@ExtendWith(MockitoExtension.class)
class RunDemoToolTest {

    @Mock
    private ServiceClientOperations serviceClient;

    private RunDemoTool runDemoTool;
    private final ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    void setUp() {
        runDemoTool = new RunDemoTool(serviceClient);
    }

    @Test
    @DisplayName("should run happy_path scenario creating customer, product, and order")
    void shouldRunHappyPath() throws JsonProcessingException {
        when(serviceClient.createEntity(eq("customer"), any()))
                .thenReturn(Map.of("customerId", "c1", "name", "Demo Customer"));
        when(serviceClient.createEntity(eq("product"), any()))
                .thenReturn(Map.of("productId", "p1", "name", "Demo Widget"));
        when(serviceClient.createEntity(eq("order"), any()))
                .thenReturn(Map.of("orderId", "o1", "status", "PENDING"));

        String result = runDemoTool.runDemo("happy_path");

        verify(serviceClient).createEntity(eq("customer"), any());
        verify(serviceClient).createEntity(eq("product"), any());
        verify(serviceClient).createEntity(eq("order"), any());

        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("happy_path", parsed.get("scenario"));
        assertNotNull(parsed.get("steps"));
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> steps = (List<Map<String, Object>>) parsed.get("steps");
        assertEquals(3, steps.size());
    }

    @Test
    @DisplayName("should run payment_failure scenario with high-value order")
    void shouldRunPaymentFailure() throws JsonProcessingException {
        when(serviceClient.createEntity(eq("customer"), any()))
                .thenReturn(Map.of("customerId", "c2", "name", "Big Spender"));
        when(serviceClient.createEntity(eq("product"), any()))
                .thenReturn(Map.of("productId", "p2", "name", "Premium Item"));
        when(serviceClient.createEntity(eq("order"), any()))
                .thenReturn(Map.of("orderId", "o2", "status", "PENDING"));

        String result = runDemoTool.runDemo("payment_failure");

        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("payment_failure", parsed.get("scenario"));
        assertNotNull(parsed.get("expectedOutcome"));
        assertTrue(parsed.get("expectedOutcome").toString().contains("$10,000"));
    }

    @Test
    @DisplayName("should run saga_timeout scenario")
    void shouldRunSagaTimeout() throws JsonProcessingException {
        when(serviceClient.createEntity(eq("customer"), any()))
                .thenReturn(Map.of("customerId", "c3"));
        when(serviceClient.createEntity(eq("product"), any()))
                .thenReturn(Map.of("productId", "p3"));
        when(serviceClient.createEntity(eq("order"), any()))
                .thenReturn(Map.of("orderId", "o3"));

        String result = runDemoTool.runDemo("saga_timeout");

        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("saga_timeout", parsed.get("scenario"));
        assertNotNull(parsed.get("expectedOutcome"));
    }

    @Test
    @DisplayName("should run load_sample_data scenario creating multiple entities")
    void shouldRunLoadSampleData() throws JsonProcessingException {
        when(serviceClient.createEntity(eq("customer"), any()))
                .thenReturn(Map.of("customerId", "c-sample"));
        when(serviceClient.createEntity(eq("product"), any()))
                .thenReturn(Map.of("productId", "p-sample"));

        String result = runDemoTool.runDemo("load_sample_data");

        // Should create 3 customers and 3 products
        verify(serviceClient, atLeast(3)).createEntity(eq("customer"), any());
        verify(serviceClient, atLeast(3)).createEntity(eq("product"), any());

        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("load_sample_data", parsed.get("scenario"));
        assertNotNull(parsed.get("entitiesCreated"));
    }

    @Test
    @DisplayName("should run orchestrated_happy_path scenario using orchestrated endpoint")
    void shouldRunOrchestratedHappyPath() throws JsonProcessingException {
        when(serviceClient.createEntity(eq("customer"), any()))
                .thenReturn(Map.of("customerId", "c-orch1", "name", "Orchestrated Customer"));
        when(serviceClient.createEntity(eq("product"), any()))
                .thenReturn(Map.of("productId", "p-orch1", "name", "Orchestrated Widget"));
        when(serviceClient.createOrchestratedOrder(any()))
                .thenReturn(Map.of("orderId", "o-orch1", "status", "PENDING"));

        String result = runDemoTool.runDemo("orchestrated_happy_path");

        verify(serviceClient).createEntity(eq("customer"), any());
        verify(serviceClient).createEntity(eq("product"), any());
        verify(serviceClient).createOrchestratedOrder(any());

        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("orchestrated_happy_path", parsed.get("scenario"));
        assertEquals("orchestrated", parsed.get("sagaPattern"));
        assertNotNull(parsed.get("steps"));
        @SuppressWarnings("unchecked")
        List<Map<String, Object>> steps = (List<Map<String, Object>>) parsed.get("steps");
        assertEquals(3, steps.size());
    }

    @Test
    @DisplayName("should run orchestrated_payment_failure scenario with high-value orchestrated order")
    void shouldRunOrchestratedPaymentFailure() throws JsonProcessingException {
        when(serviceClient.createEntity(eq("customer"), any()))
                .thenReturn(Map.of("customerId", "c-orch2", "name", "Orchestrated Big Spender"));
        when(serviceClient.createEntity(eq("product"), any()))
                .thenReturn(Map.of("productId", "p-orch2", "name", "Premium Orchestrated Item"));
        when(serviceClient.createOrchestratedOrder(any()))
                .thenReturn(Map.of("orderId", "o-orch2", "status", "PENDING"));

        String result = runDemoTool.runDemo("orchestrated_payment_failure");

        verify(serviceClient).createOrchestratedOrder(any());

        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("orchestrated_payment_failure", parsed.get("scenario"));
        assertEquals("orchestrated", parsed.get("sagaPattern"));
        assertNotNull(parsed.get("expectedOutcome"));
        assertTrue(parsed.get("expectedOutcome").toString().contains("$10,000"));
    }

    @Test
    @DisplayName("should return error for unknown scenario")
    void shouldReturnErrorForUnknownScenario() throws JsonProcessingException {
        String result = runDemoTool.runDemo("unknown_scenario");

        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertTrue(parsed.containsKey("error"));
        assertTrue(parsed.get("error").toString().contains("Unknown scenario"));
    }

    @Test
    @DisplayName("should handle service client exception gracefully")
    void shouldHandleServiceException() throws JsonProcessingException {
        when(serviceClient.createEntity(eq("customer"), any()))
                .thenThrow(new RuntimeException("Connection refused"));

        String result = runDemoTool.runDemo("happy_path");

        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertTrue(parsed.containsKey("error"));
        assertTrue(parsed.get("error").toString().contains("Connection refused"));
    }
}
