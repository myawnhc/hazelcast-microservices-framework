package com.theyawns.ecommerce.mcp.security;

import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.test.context.runner.ApplicationContextRunner;
import org.springframework.boot.test.context.runner.WebApplicationContextRunner;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration tests for the MCP security layer.
 *
 * <p>Tests that {@link ToolAuthorizer}, {@link McpRole}, and
 * {@link McpSecurityProperties} work together correctly for role-based
 * tool access control. Uses {@link ApplicationContextRunner} to avoid
 * stdio transport blocking.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("MCP Security - Integration")
class McpSecurityIntegrationTest {

    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(McpSecurityAutoConfiguration.class));

    @AfterEach
    void cleanUp() {
        ToolAuthorizer.clearRequestRole();
    }

    @Nested
    @DisplayName("ToolAuthorizer + McpRole role-based access")
    class RoleBasedAccess {

        @Test
        @DisplayName("VIEWER role should access all read-only tools")
        void viewerShouldAccessReadOnlyTools() {
            final ToolAuthorizer authorizer = new ToolAuthorizer(McpRole.VIEWER);
            assertThat(authorizer.checkAccess("queryView")).isNull();
            assertThat(authorizer.checkAccess("getEventHistory")).isNull();
            assertThat(authorizer.checkAccess("inspectSaga")).isNull();
            assertThat(authorizer.checkAccess("listSagas")).isNull();
            assertThat(authorizer.checkAccess("getMetrics")).isNull();
        }

        @Test
        @DisplayName("VIEWER role should be denied write tools")
        void viewerShouldBeDeniedWriteTools() {
            final ToolAuthorizer authorizer = new ToolAuthorizer(McpRole.VIEWER);
            assertThat(authorizer.checkAccess("submitEvent")).isNotNull();
            assertThat(authorizer.checkAccess("runDemo")).isNotNull();
        }

        @Test
        @DisplayName("OPERATOR role should access all 7 tools")
        void operatorShouldAccessAllTools() {
            final ToolAuthorizer authorizer = new ToolAuthorizer(McpRole.OPERATOR);
            assertThat(authorizer.checkAccess("queryView")).isNull();
            assertThat(authorizer.checkAccess("getEventHistory")).isNull();
            assertThat(authorizer.checkAccess("inspectSaga")).isNull();
            assertThat(authorizer.checkAccess("listSagas")).isNull();
            assertThat(authorizer.checkAccess("getMetrics")).isNull();
            assertThat(authorizer.checkAccess("submitEvent")).isNull();
            assertThat(authorizer.checkAccess("runDemo")).isNull();
        }

        @Test
        @DisplayName("ADMIN role should access all 7 tools")
        void adminShouldAccessAllTools() {
            final ToolAuthorizer authorizer = new ToolAuthorizer(McpRole.ADMIN);
            assertThat(authorizer.checkAccess("queryView")).isNull();
            assertThat(authorizer.checkAccess("getEventHistory")).isNull();
            assertThat(authorizer.checkAccess("inspectSaga")).isNull();
            assertThat(authorizer.checkAccess("listSagas")).isNull();
            assertThat(authorizer.checkAccess("getMetrics")).isNull();
            assertThat(authorizer.checkAccess("submitEvent")).isNull();
            assertThat(authorizer.checkAccess("runDemo")).isNull();
        }

        @Test
        @DisplayName("should deny access when no role is set")
        void shouldDenyWhenNoRole() {
            final ToolAuthorizer authorizer = new ToolAuthorizer(null);
            assertThat(authorizer.checkAccess("queryView")).isNotNull();
            assertThat(authorizer.checkAccess("submitEvent")).isNotNull();
        }
    }

    @Nested
    @DisplayName("Per-request role overrides session role")
    class RequestRoleOverride {

        @Test
        @DisplayName("request role should take precedence over session role")
        void requestRoleShouldOverrideSession() {
            final ToolAuthorizer authorizer = new ToolAuthorizer(McpRole.VIEWER);

            // Session role (VIEWER) denies submitEvent
            assertThat(authorizer.checkAccess("submitEvent")).isNotNull();

            // Per-request role (OPERATOR) permits submitEvent
            ToolAuthorizer.setRequestRole(McpRole.OPERATOR);
            try {
                assertThat(authorizer.checkAccess("submitEvent")).isNull();
                assertThat(authorizer.getCurrentRole()).isEqualTo(McpRole.OPERATOR);
            } finally {
                ToolAuthorizer.clearRequestRole();
            }

            // After clearing, back to session role
            assertThat(authorizer.checkAccess("submitEvent")).isNotNull();
            assertThat(authorizer.getCurrentRole()).isEqualTo(McpRole.VIEWER);
        }

        @Test
        @DisplayName("clearing request role should fall back to session role")
        void clearingRequestRoleShouldFallback() {
            final ToolAuthorizer authorizer = new ToolAuthorizer(McpRole.ADMIN);

            ToolAuthorizer.setRequestRole(McpRole.VIEWER);
            assertThat(authorizer.getCurrentRole()).isEqualTo(McpRole.VIEWER);

            ToolAuthorizer.clearRequestRole();
            assertThat(authorizer.getCurrentRole()).isEqualTo(McpRole.ADMIN);
        }
    }

    @Nested
    @DisplayName("McpSecurityProperties role resolution")
    class PropertiesRoleResolution {

        @Test
        @DisplayName("should resolve VIEWER role from API key")
        void shouldResolveViewerRole() {
            final McpSecurityProperties properties = new McpSecurityProperties();
            properties.getApiKeys().put("viewer-key", "VIEWER");
            assertThat(properties.resolveRole("viewer-key")).isEqualTo(McpRole.VIEWER);
        }

        @Test
        @DisplayName("should resolve OPERATOR role from API key")
        void shouldResolveOperatorRole() {
            final McpSecurityProperties properties = new McpSecurityProperties();
            properties.getApiKeys().put("operator-key", "OPERATOR");
            assertThat(properties.resolveRole("operator-key")).isEqualTo(McpRole.OPERATOR);
        }

        @Test
        @DisplayName("should resolve ADMIN role from API key")
        void shouldResolveAdminRole() {
            final McpSecurityProperties properties = new McpSecurityProperties();
            properties.getApiKeys().put("admin-key", "ADMIN");
            assertThat(properties.resolveRole("admin-key")).isEqualTo(McpRole.ADMIN);
        }

        @Test
        @DisplayName("should resolve role case-insensitively")
        void shouldResolveCaseInsensitive() {
            final McpSecurityProperties properties = new McpSecurityProperties();
            properties.getApiKeys().put("mixed-key", "viewer");
            assertThat(properties.resolveRole("mixed-key")).isEqualTo(McpRole.VIEWER);
        }

        @Test
        @DisplayName("should return null for unknown API key")
        void shouldReturnNullForUnknownKey() {
            final McpSecurityProperties properties = new McpSecurityProperties();
            properties.getApiKeys().put("known-key", "VIEWER");
            assertThat(properties.resolveRole("unknown-key")).isNull();
        }

        @Test
        @DisplayName("should return null for null or blank API key")
        void shouldReturnNullForNullOrBlank() {
            final McpSecurityProperties properties = new McpSecurityProperties();
            assertThat(properties.resolveRole(null)).isNull();
            assertThat(properties.resolveRole("")).isNull();
            assertThat(properties.resolveRole("  ")).isNull();
        }
    }

    @Nested
    @DisplayName("Auto-configuration bean creation")
    class AutoConfigBeanCreation {

        @Test
        @DisplayName("should create beans when mcp.security.enabled=true")
        void shouldCreateBeansWhenEnabled() {
            contextRunner
                    .withPropertyValues(
                            "mcp.security.enabled=true",
                            "mcp.security.api-key-env-var=NONEXISTENT_MCP_KEY_12345"
                    )
                    .run(context -> {
                        assertThat(context).hasSingleBean(ToolAuthorizer.class);
                        assertThat(context).hasSingleBean(McpSecurityProperties.class);
                    });
        }

        @Test
        @DisplayName("should not create beans when mcp.security.enabled=false")
        void shouldNotCreateBeansWhenDisabled() {
            contextRunner
                    .withPropertyValues("mcp.security.enabled=false")
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(ToolAuthorizer.class);
                    });
        }

        @Test
        @DisplayName("should not create beans when mcp.security.enabled is absent")
        void shouldNotCreateBeansWhenAbsent() {
            contextRunner
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(ToolAuthorizer.class);
                    });
        }

        @Test
        @DisplayName("should bind API keys from configuration")
        void shouldBindApiKeysFromConfig() {
            contextRunner
                    .withPropertyValues(
                            "mcp.security.enabled=true",
                            "mcp.security.api-keys.test-viewer=VIEWER",
                            "mcp.security.api-keys.test-operator=OPERATOR",
                            "mcp.security.api-keys.test-admin=ADMIN",
                            "mcp.security.api-key-env-var=NONEXISTENT_MCP_KEY_12345"
                    )
                    .run(context -> {
                        final McpSecurityProperties props = context.getBean(McpSecurityProperties.class);
                        assertThat(props.getApiKeys()).hasSize(3);
                        assertThat(props.resolveRole("test-viewer")).isEqualTo(McpRole.VIEWER);
                        assertThat(props.resolveRole("test-operator")).isEqualTo(McpRole.OPERATOR);
                        assertThat(props.resolveRole("test-admin")).isEqualTo(McpRole.ADMIN);
                    });
        }

        @Test
        @DisplayName("should create McpApiKeyFilter in servlet web context")
        void shouldCreateFilterInServletContext() {
            new WebApplicationContextRunner()
                    .withConfiguration(AutoConfigurations.of(McpSecurityAutoConfiguration.class))
                    .withPropertyValues(
                            "mcp.security.enabled=true",
                            "mcp.security.api-key-env-var=NONEXISTENT_MCP_KEY_12345"
                    )
                    .run(context -> {
                        assertThat(context).hasSingleBean(ToolAuthorizer.class);
                        assertThat(context).hasBean("mcpApiKeyFilterRegistration");
                    });
        }

        @Test
        @DisplayName("should not create McpApiKeyFilter in non-servlet context")
        void shouldNotCreateFilterInNonServletContext() {
            contextRunner
                    .withPropertyValues(
                            "mcp.security.enabled=true",
                            "mcp.security.api-key-env-var=NONEXISTENT_MCP_KEY_12345"
                    )
                    .run(context -> {
                        assertThat(context).hasSingleBean(ToolAuthorizer.class);
                        assertThat(context).doesNotHaveBean("mcpApiKeyFilterRegistration");
                    });
        }
    }

    @Nested
    @DisplayName("Access denied response format")
    class AccessDeniedFormat {

        @Test
        @DisplayName("should return JSON error when access is denied")
        void shouldReturnJsonOnDenial() {
            final ToolAuthorizer authorizer = new ToolAuthorizer(McpRole.VIEWER);
            final String result = authorizer.checkAccess("submitEvent");

            assertThat(result).isNotNull();
            assertThat(result).contains("access_denied");
            assertThat(result).contains("submitEvent");
        }

        @Test
        @DisplayName("should return null (no error) when access is granted")
        void shouldReturnNullOnGrant() {
            final ToolAuthorizer authorizer = new ToolAuthorizer(McpRole.VIEWER);
            assertThat(authorizer.checkAccess("queryView")).isNull();
        }
    }
}
