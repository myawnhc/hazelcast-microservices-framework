package com.theyawns.ecommerce.mcp.tools;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.theyawns.ecommerce.mcp.client.ServiceClientOperations;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link GetEventHistoryTool}.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("GetEventHistoryTool")
@ExtendWith(MockitoExtension.class)
class GetEventHistoryToolTest {

    @Mock
    private ServiceClientOperations serviceClient;

    private GetEventHistoryTool getEventHistoryTool;
    private final ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    void setUp() {
        getEventHistoryTool = new GetEventHistoryTool(serviceClient);
    }

    @Test
    @DisplayName("should get event history for Customer aggregate")
    void shouldGetCustomerHistory() throws JsonProcessingException {
        List<Map<String, Object>> events = List.of(
                Map.of("eventType", "CustomerCreated", "eventId", "e1"),
                Map.of("eventType", "CustomerUpdated", "eventId", "e2")
        );
        when(serviceClient.getEventHistory("customer", "c1", 20)).thenReturn(events);

        String result = getEventHistoryTool.getEventHistory("c1", "Customer", null);

        verify(serviceClient).getEventHistory("customer", "c1", 20);
        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("Customer", parsed.get("aggregateType"));
        assertEquals("c1", parsed.get("aggregateId"));
        assertEquals(2, parsed.get("eventCount"));
        assertNotNull(parsed.get("events"));
    }

    @Test
    @DisplayName("should get event history for Product aggregate")
    void shouldGetProductHistory() {
        when(serviceClient.getEventHistory("product", "p1", 20)).thenReturn(List.of());

        getEventHistoryTool.getEventHistory("p1", "Product", null);

        verify(serviceClient).getEventHistory("product", "p1", 20);
    }

    @Test
    @DisplayName("should get event history for Order aggregate")
    void shouldGetOrderHistory() {
        when(serviceClient.getEventHistory("order", "o1", 10)).thenReturn(List.of());

        getEventHistoryTool.getEventHistory("o1", "Order", 10);

        verify(serviceClient).getEventHistory("order", "o1", 10);
    }

    @Test
    @DisplayName("should get event history for Payment aggregate")
    void shouldGetPaymentHistory() {
        when(serviceClient.getEventHistory("payment", "pay1", 20)).thenReturn(List.of());

        getEventHistoryTool.getEventHistory("pay1", "Payment", null);

        verify(serviceClient).getEventHistory("payment", "pay1", 20);
    }

    @Test
    @DisplayName("should use custom limit")
    void shouldUseCustomLimit() {
        when(serviceClient.getEventHistory("customer", "c1", 5)).thenReturn(List.of());

        getEventHistoryTool.getEventHistory("c1", "Customer", 5);

        verify(serviceClient).getEventHistory("customer", "c1", 5);
    }

    @Test
    @DisplayName("should default to limit 20 when null")
    void shouldDefaultLimit() {
        when(serviceClient.getEventHistory("order", "o1", 20)).thenReturn(List.of());

        getEventHistoryTool.getEventHistory("o1", "Order", null);

        verify(serviceClient).getEventHistory("order", "o1", 20);
    }

    @Test
    @DisplayName("should return error for unknown aggregate type")
    void shouldReturnErrorForUnknownAggregate() throws JsonProcessingException {
        String result = getEventHistoryTool.getEventHistory("id1", "Unknown", null);

        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertTrue(parsed.containsKey("error"));
        assertTrue(parsed.get("error").toString().contains("Unknown aggregate type"));
    }

    @Test
    @DisplayName("should map aggregate types to view names correctly")
    void shouldMapAggregateTypes() {
        assertEquals("customer", getEventHistoryTool.mapAggregateTypeToView("Customer"));
        assertEquals("product", getEventHistoryTool.mapAggregateTypeToView("Product"));
        assertEquals("order", getEventHistoryTool.mapAggregateTypeToView("Order"));
        assertEquals("payment", getEventHistoryTool.mapAggregateTypeToView("Payment"));
    }

    @Test
    @DisplayName("should throw for unknown aggregate type in mapAggregateTypeToView")
    void shouldThrowForUnknownAggregateInMapper() {
        assertThrows(IllegalArgumentException.class,
                () -> getEventHistoryTool.mapAggregateTypeToView("Invalid"));
    }
}
