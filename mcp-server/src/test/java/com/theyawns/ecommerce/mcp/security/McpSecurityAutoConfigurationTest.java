package com.theyawns.ecommerce.mcp.security;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.test.context.runner.ApplicationContextRunner;
import org.springframework.boot.test.context.runner.WebApplicationContextRunner;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link McpSecurityAutoConfiguration}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("McpSecurityAutoConfiguration")
class McpSecurityAutoConfigurationTest {

    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(McpSecurityAutoConfiguration.class));

    @Test
    @DisplayName("should not create beans when security is disabled")
    void shouldNotCreateBeansWhenDisabled() {
        contextRunner
                .withPropertyValues("mcp.security.enabled=false")
                .run(context -> {
                    assertThat(context).doesNotHaveBean(ToolAuthorizer.class);
                });
    }

    @Test
    @DisplayName("should not create beans when security property is missing")
    void shouldNotCreateBeansWhenPropertyMissing() {
        contextRunner
                .run(context -> {
                    assertThat(context).doesNotHaveBean(ToolAuthorizer.class);
                });
    }

    @Test
    @DisplayName("should create ToolAuthorizer when security is enabled")
    void shouldCreateToolAuthorizerWhenEnabled() {
        contextRunner
                .withPropertyValues("mcp.security.enabled=true")
                .run(context -> {
                    assertThat(context).hasSingleBean(ToolAuthorizer.class);
                });
    }

    @Test
    @DisplayName("should resolve session role from configured API key and env var")
    void shouldResolveSessionRoleFromConfig() {
        contextRunner
                .withPropertyValues(
                        "mcp.security.enabled=true",
                        "mcp.security.api-keys.test-key=ADMIN",
                        "mcp.security.api-key-env-var=NONEXISTENT_MCP_KEY_12345"
                )
                .run(context -> {
                    assertThat(context).hasSingleBean(ToolAuthorizer.class);
                    ToolAuthorizer authorizer = context.getBean(ToolAuthorizer.class);
                    // No env var set, so session role should be null (HTTP-only mode)
                    assertThat(authorizer.getSessionRole()).isNull();
                });
    }

    @Test
    @DisplayName("should not create McpApiKeyFilter in non-servlet context")
    void shouldNotCreateFilterInNonServletContext() {
        contextRunner
                .withPropertyValues("mcp.security.enabled=true")
                .run(context -> {
                    assertThat(context).doesNotHaveBean("mcpApiKeyFilterRegistration");
                });
    }

    @Test
    @DisplayName("should create McpApiKeyFilter in servlet web context")
    void shouldCreateFilterInServletContext() {
        new WebApplicationContextRunner()
                .withConfiguration(AutoConfigurations.of(McpSecurityAutoConfiguration.class))
                .withPropertyValues("mcp.security.enabled=true")
                .run(context -> {
                    assertThat(context).hasSingleBean(ToolAuthorizer.class);
                    assertThat(context).hasBean("mcpApiKeyFilterRegistration");
                });
    }
}
