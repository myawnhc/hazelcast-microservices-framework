package com.theyawns.ecommerce.mcp.tools;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.theyawns.ecommerce.mcp.client.ServiceClientOperations;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.List;
import java.util.Map;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link ListSagasTool}.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("ListSagasTool")
@ExtendWith(MockitoExtension.class)
class ListSagasToolTest {

    @Mock
    private ServiceClientOperations serviceClient;

    private ListSagasTool listSagasTool;
    private final ObjectMapper objectMapper = new ObjectMapper();

    @BeforeEach
    void setUp() {
        listSagasTool = new ListSagasTool(serviceClient);
    }

    @Test
    @DisplayName("should list sagas with status filter")
    void shouldListSagasWithStatusFilter() throws JsonProcessingException {
        List<Map<String, Object>> sagas = List.of(
                Map.of("sagaId", "saga-1", "status", "COMPLETED"),
                Map.of("sagaId", "saga-2", "status", "COMPLETED")
        );
        when(serviceClient.listSagas("COMPLETED", null, 10)).thenReturn(sagas);

        String result = listSagasTool.listSagas("COMPLETED", null, null);

        verify(serviceClient).listSagas("COMPLETED", null, 10);
        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("COMPLETED", parsed.get("status"));
        assertEquals(2, parsed.get("count"));
        assertNotNull(parsed.get("sagas"));
    }

    @Test
    @DisplayName("should list all sagas when status is null")
    void shouldListAllSagasWhenStatusNull() throws JsonProcessingException {
        when(serviceClient.listSagas(null, null, 10)).thenReturn(List.of());

        String result = listSagasTool.listSagas(null, null, null);

        verify(serviceClient).listSagas(null, null, 10);
        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("ALL", parsed.get("status"));
        assertEquals("ALL", parsed.get("type"));
        assertEquals(0, parsed.get("count"));
    }

    @Test
    @DisplayName("should use custom limit")
    void shouldUseCustomLimit() {
        when(serviceClient.listSagas("FAILED", null, 25)).thenReturn(List.of());

        listSagasTool.listSagas("FAILED", null, 25);

        verify(serviceClient).listSagas("FAILED", null, 25);
    }

    @Test
    @DisplayName("should default to limit 10 when limit is null")
    void shouldDefaultLimit() {
        when(serviceClient.listSagas("IN_PROGRESS", null, 10)).thenReturn(List.of());

        listSagasTool.listSagas("IN_PROGRESS", null, null);

        verify(serviceClient).listSagas("IN_PROGRESS", null, 10);
    }

    @Test
    @DisplayName("should filter by type when type parameter is provided")
    void shouldFilterByType() throws JsonProcessingException {
        List<Map<String, Object>> sagas = List.of(
                Map.of("sagaId", "saga-orch-1", "sagaType", "OrderFulfillmentOrchestrated")
        );
        when(serviceClient.listSagas(null, "OrderFulfillmentOrchestrated", 10)).thenReturn(sagas);

        String result = listSagasTool.listSagas(null, "OrderFulfillmentOrchestrated", null);

        verify(serviceClient).listSagas(null, "OrderFulfillmentOrchestrated", 10);
        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("OrderFulfillmentOrchestrated", parsed.get("type"));
        assertEquals(1, parsed.get("count"));
    }

    @Test
    @DisplayName("should filter by both status and type")
    void shouldFilterByStatusAndType() throws JsonProcessingException {
        when(serviceClient.listSagas("COMPLETED", "OrderFulfillment", 10)).thenReturn(List.of());

        String result = listSagasTool.listSagas("COMPLETED", "OrderFulfillment", null);

        verify(serviceClient).listSagas("COMPLETED", "OrderFulfillment", 10);
        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertEquals("COMPLETED", parsed.get("status"));
        assertEquals("OrderFulfillment", parsed.get("type"));
    }

    @Test
    @DisplayName("should return error when service client throws exception")
    void shouldReturnErrorOnException() throws JsonProcessingException {
        when(serviceClient.listSagas(null, null, 10)).thenThrow(new RuntimeException("Service unavailable"));

        String result = listSagasTool.listSagas(null, null, null);

        Map<String, Object> parsed = objectMapper.readValue(result, new TypeReference<>() {});
        assertTrue(parsed.containsKey("error"));
        assertTrue(parsed.get("error").toString().contains("Service unavailable"));
    }
}
