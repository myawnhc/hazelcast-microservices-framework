package com.theyawns.framework.dlq;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;

import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link DeadLetterQueueController}.
 *
 * <p>Uses direct method invocation on the controller with a mock
 * {@link DeadLetterQueueOperations} interface. No MockMvc or web
 * context is needed since framework-core does not depend on
 * spring-boot-starter-web.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("DeadLetterQueueController - REST admin endpoints")
class DeadLetterQueueControllerTest {

    private DeadLetterQueueOperations mockDlq;
    private DeadLetterQueueController controller;

    @BeforeEach
    void setUp() {
        mockDlq = Mockito.mock(DeadLetterQueueOperations.class);
        controller = new DeadLetterQueueController(mockDlq);
    }

    private DeadLetterEntry createTestEntry(final String originalEventId) {
        return DeadLetterEntry.builder()
                .originalEventId(originalEventId)
                .eventType("TestCreated")
                .topicName("TestTopic")
                .failureReason("Test failure")
                .build();
    }

    @Nested
    @DisplayName("GET /api/admin/dlq (list)")
    class ListEndpoint {

        @Test
        @DisplayName("should return 200 with list of entries")
        void shouldReturn200WithListOfEntries() {
            // Arrange
            DeadLetterEntry entry1 = createTestEntry("evt-001");
            DeadLetterEntry entry2 = createTestEntry("evt-002");
            when(mockDlq.list(20)).thenReturn(List.of(entry1, entry2));

            // Act
            ResponseEntity<List<DeadLetterEntry>> response = controller.list(20);

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).hasSize(2);
            verify(mockDlq).list(20);
        }

        @Test
        @DisplayName("should return 200 with empty list when no entries")
        void shouldReturn200WithEmptyList() {
            // Arrange
            when(mockDlq.list(20)).thenReturn(List.of());

            // Act
            ResponseEntity<List<DeadLetterEntry>> response = controller.list(20);

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).isEmpty();
        }

        @Test
        @DisplayName("should pass custom limit to operations")
        void shouldPassCustomLimitToOperations() {
            // Arrange
            when(mockDlq.list(50)).thenReturn(List.of());

            // Act
            controller.list(50);

            // Assert
            verify(mockDlq).list(50);
        }
    }

    @Nested
    @DisplayName("GET /api/admin/dlq/count")
    class CountEndpoint {

        @Test
        @DisplayName("should return 200 with count")
        void shouldReturn200WithCount() {
            // Arrange
            when(mockDlq.count()).thenReturn(7L);

            // Act
            ResponseEntity<Map<String, Long>> response = controller.count();

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).containsEntry("count", 7L);
        }

        @Test
        @DisplayName("should return 200 with zero count when empty")
        void shouldReturn200WithZeroCount() {
            // Arrange
            when(mockDlq.count()).thenReturn(0L);

            // Act
            ResponseEntity<Map<String, Long>> response = controller.count();

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).containsEntry("count", 0L);
        }
    }

    @Nested
    @DisplayName("GET /api/admin/dlq/{id} (getEntry)")
    class GetEntryEndpoint {

        @Test
        @DisplayName("should return 200 with entry when found")
        void shouldReturn200WhenEntryFound() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-001");
            when(mockDlq.getEntry(entry.getDlqEntryId())).thenReturn(entry);

            // Act
            ResponseEntity<DeadLetterEntry> response = controller.getEntry(entry.getDlqEntryId());

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).isNotNull();
            assertThat(response.getBody().getOriginalEventId()).isEqualTo("evt-001");
        }

        @Test
        @DisplayName("should return 404 when entry not found")
        void shouldReturn404WhenEntryNotFound() {
            // Arrange
            when(mockDlq.getEntry("non-existent")).thenReturn(null);

            // Act
            ResponseEntity<DeadLetterEntry> response = controller.getEntry("non-existent");

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
            assertThat(response.getBody()).isNull();
        }
    }

    @Nested
    @DisplayName("POST /api/admin/dlq/{id}/replay")
    class ReplayEndpoint {

        @Test
        @DisplayName("should return 200 on successful replay")
        void shouldReturn200OnSuccessfulReplay() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-001");
            String entryId = entry.getDlqEntryId();
            when(mockDlq.getEntry(entryId)).thenReturn(entry);

            // Act
            ResponseEntity<Map<String, String>> response = controller.replay(entryId);

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).containsEntry("status", "replayed");
            assertThat(response.getBody()).containsEntry("dlqEntryId", entryId);
            verify(mockDlq).replay(entryId);
        }

        @Test
        @DisplayName("should return 404 when entry not found for replay")
        void shouldReturn404WhenEntryNotFoundForReplay() {
            // Arrange
            when(mockDlq.getEntry("non-existent")).thenReturn(null);

            // Act
            ResponseEntity<Map<String, String>> response = controller.replay("non-existent");

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
        }

        @Test
        @DisplayName("should return 400 when replay fails due to invalid state")
        void shouldReturn400WhenReplayFailsDueToInvalidState() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-001");
            String entryId = entry.getDlqEntryId();
            when(mockDlq.getEntry(entryId)).thenReturn(entry);
            doThrow(new IllegalStateException("Cannot replay entry in status REPLAYED"))
                    .when(mockDlq).replay(entryId);

            // Act
            ResponseEntity<Map<String, String>> response = controller.replay(entryId);

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
            assertThat(response.getBody()).containsKey("error");
            assertThat(response.getBody().get("error")).contains("REPLAYED");
        }
    }

    @Nested
    @DisplayName("DELETE /api/admin/dlq/{id} (discard)")
    class DiscardEndpoint {

        @Test
        @DisplayName("should return 200 on successful discard")
        void shouldReturn200OnSuccessfulDiscard() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-001");
            String entryId = entry.getDlqEntryId();
            when(mockDlq.getEntry(entryId)).thenReturn(entry);

            // Act
            ResponseEntity<Map<String, String>> response = controller.discard(entryId);

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.OK);
            assertThat(response.getBody()).containsEntry("status", "discarded");
            assertThat(response.getBody()).containsEntry("dlqEntryId", entryId);
            verify(mockDlq).discard(entryId);
        }

        @Test
        @DisplayName("should return 404 when entry not found for discard")
        void shouldReturn404WhenEntryNotFoundForDiscard() {
            // Arrange
            when(mockDlq.getEntry("non-existent")).thenReturn(null);

            // Act
            ResponseEntity<Map<String, String>> response = controller.discard("non-existent");

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.NOT_FOUND);
        }

        @Test
        @DisplayName("should return 400 when discard fails due to invalid state")
        void shouldReturn400WhenDiscardFailsDueToInvalidState() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-001");
            String entryId = entry.getDlqEntryId();
            when(mockDlq.getEntry(entryId)).thenReturn(entry);
            doThrow(new IllegalStateException("Cannot discard entry in status DISCARDED"))
                    .when(mockDlq).discard(entryId);

            // Act
            ResponseEntity<Map<String, String>> response = controller.discard(entryId);

            // Assert
            assertThat(response.getStatusCode()).isEqualTo(HttpStatus.BAD_REQUEST);
            assertThat(response.getBody()).containsKey("error");
            assertThat(response.getBody().get("error")).contains("DISCARDED");
        }
    }
}
