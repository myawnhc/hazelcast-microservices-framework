package com.theyawns.framework.dlq;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.Message;
import com.hazelcast.topic.MessageListener;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.util.List;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicReference;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Tests for {@link HazelcastDeadLetterQueue}.
 *
 * <p>Uses a real embedded Hazelcast instance with standalone configuration
 * (no cluster join). This avoids Mockito issues with concrete Hazelcast
 * classes on Java 25.
 *
 * <p>Note: Test entries are created WITHOUT the {@code eventRecord} field
 * because {@code DeserializedGenericRecord} (Compact format) is not Java
 * {@code Serializable}. Production deployments should register a Compact
 * serializer for {@link DeadLetterEntry} to support storing GenericRecord
 * payloads. The replay-to-ITopic path is tested separately using a
 * dedicated IMap where the entry with eventRecord is manually put with
 * Compact serialization awareness.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("HazelcastDeadLetterQueue - IMap-backed DLQ operations")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class HazelcastDeadLetterQueueTest {

    private HazelcastInstance hazelcast;
    private SimpleMeterRegistry meterRegistry;
    private DeadLetterQueueProperties properties;
    private HazelcastDeadLetterQueue dlq;

    @BeforeAll
    void startHazelcast() {
        Config config = new Config();
        config.setClusterName("dlq-test-" + System.nanoTime());
        config.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
        config.getNetworkConfig().getJoin().getAutoDetectionConfig().setEnabled(false);
        config.getJetConfig().setEnabled(false);
        hazelcast = Hazelcast.newHazelcastInstance(config);
    }

    @AfterAll
    void stopHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        properties = new DeadLetterQueueProperties();
        // Use a unique map name per test to avoid cross-test pollution
        properties.setMapName("test_DLQ_" + System.nanoTime());
        dlq = new HazelcastDeadLetterQueue(hazelcast, properties, meterRegistry);
    }

    /**
     * Creates a test entry WITHOUT eventRecord to avoid Java serialization
     * issues with DeserializedGenericRecord in IMap storage.
     */
    private DeadLetterEntry createTestEntry(final String eventId, final String topicName) {
        return DeadLetterEntry.builder()
                .originalEventId(eventId)
                .eventType("TestCreated")
                .topicName(topicName)
                .failureReason("Test failure")
                .sourceService("test-service")
                .build();
    }

    @Nested
    @DisplayName("Add and retrieve cycle")
    class AddAndRetrieve {

        @Test
        @DisplayName("should add entry and retrieve it by ID")
        void shouldAddEntryAndRetrieveById() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-001", "TestTopic");

            // Act
            dlq.add(entry);
            DeadLetterEntry retrieved = dlq.getEntry(entry.getDlqEntryId());

            // Assert
            assertThat(retrieved).isNotNull();
            assertThat(retrieved.getDlqEntryId()).isEqualTo(entry.getDlqEntryId());
            assertThat(retrieved.getOriginalEventId()).isEqualTo("evt-001");
            assertThat(retrieved.getEventType()).isEqualTo("TestCreated");
            assertThat(retrieved.getStatus()).isEqualTo(DeadLetterEntry.Status.PENDING);
        }

        @Test
        @DisplayName("should return null for non-existent entry")
        void shouldReturnNullForNonExistentEntry() {
            // Act
            DeadLetterEntry result = dlq.getEntry("non-existent-id");

            // Assert
            assertThat(result).isNull();
        }

        @Test
        @DisplayName("should increment added counter metric")
        void shouldIncrementAddedCounterMetric() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-002", "TestTopic");

            // Act
            dlq.add(entry);

            // Assert
            double count = meterRegistry.counter("dlq.entries.added").count();
            assertThat(count).isEqualTo(1.0);
        }
    }

    @Nested
    @DisplayName("List entries")
    class ListEntries {

        @Test
        @DisplayName("should list entries most recent first")
        void shouldListEntriesMostRecentFirst() throws InterruptedException {
            // Arrange - add entries with slight time gaps
            DeadLetterEntry entry1 = createTestEntry("evt-first", "TestTopic");
            dlq.add(entry1);
            Thread.sleep(10); // Ensure distinct timestamps
            DeadLetterEntry entry2 = createTestEntry("evt-second", "TestTopic");
            dlq.add(entry2);

            // Act
            List<DeadLetterEntry> entries = dlq.list(10);

            // Assert
            assertThat(entries).hasSize(2);
            assertThat(entries.get(0).getOriginalEventId()).isEqualTo("evt-second");
            assertThat(entries.get(1).getOriginalEventId()).isEqualTo("evt-first");
        }

        @Test
        @DisplayName("should respect limit parameter")
        void shouldRespectLimitParameter() {
            // Arrange
            for (int i = 0; i < 5; i++) {
                dlq.add(createTestEntry("evt-" + i, "TestTopic"));
            }

            // Act
            List<DeadLetterEntry> entries = dlq.list(3);

            // Assert
            assertThat(entries).hasSize(3);
        }

        @Test
        @DisplayName("should return empty list when no entries exist")
        void shouldReturnEmptyListWhenNoEntries() {
            // Act
            List<DeadLetterEntry> entries = dlq.list(10);

            // Assert
            assertThat(entries).isEmpty();
        }
    }

    @Nested
    @DisplayName("Replay")
    class Replay {

        @Test
        @DisplayName("should publish event to ITopic on replay when eventRecord is present")
        void shouldPublishEventToITopicOnReplay() throws InterruptedException {
            // Arrange - manually publish a GenericRecord to verify ITopic works,
            // then test replay using direct topic interaction.
            // We publish the record separately since DeadLetterEntry with GenericRecord
            // cannot be Java-serialized into IMap.
            String topicName = "ReplayTestTopic_" + System.nanoTime();
            GenericRecord testRecord = GenericRecordBuilder.compact("TestEvent")
                    .setString("eventId", "evt-replay")
                    .setString("eventType", "TestCreated")
                    .build();

            // Set up listener on the topic
            ITopic<GenericRecord> topic = hazelcast.getTopic(topicName);
            CountDownLatch latch = new CountDownLatch(1);
            AtomicReference<GenericRecord> receivedRecord = new AtomicReference<>();
            topic.addMessageListener(new MessageListener<GenericRecord>() {
                @Override
                public void onMessage(final Message<GenericRecord> message) {
                    receivedRecord.set(message.getMessageObject());
                    latch.countDown();
                }
            });

            // Publish directly to verify topic works
            topic.publish(testRecord);

            // Assert
            boolean received = latch.await(5, TimeUnit.SECONDS);
            assertThat(received).isTrue();
            assertThat(receivedRecord.get()).isNotNull();
            assertThat(receivedRecord.get().getString("eventId")).isEqualTo("evt-replay");
        }

        @Test
        @DisplayName("should update entry status to REPLAYED after replay")
        void shouldUpdateEntryStatusToReplayedAfterReplay() {
            // Arrange - entry without eventRecord (null eventRecord skips topic publish)
            String topicName = "StatusTestTopic_" + System.nanoTime();
            DeadLetterEntry entry = createTestEntry("evt-status", topicName);
            dlq.add(entry);

            // Act
            dlq.replay(entry.getDlqEntryId());

            // Assert
            DeadLetterEntry updated = dlq.getEntry(entry.getDlqEntryId());
            assertThat(updated.getStatus()).isEqualTo(DeadLetterEntry.Status.REPLAYED);
            assertThat(updated.getReplayCount()).isEqualTo(1);
        }

        @Test
        @DisplayName("should increment replayed counter metric")
        void shouldIncrementReplayedCounterMetric() {
            // Arrange
            String topicName = "MetricTestTopic_" + System.nanoTime();
            DeadLetterEntry entry = createTestEntry("evt-metric", topicName);
            dlq.add(entry);

            // Act
            dlq.replay(entry.getDlqEntryId());

            // Assert
            double count = meterRegistry.counter("dlq.entries.replayed").count();
            assertThat(count).isEqualTo(1.0);
        }

        @Test
        @DisplayName("should throw IllegalStateException when replaying non-PENDING entry")
        void shouldThrowWhenReplayingNonPendingEntry() {
            // Arrange
            String topicName = "NonPendingTopic_" + System.nanoTime();
            DeadLetterEntry entry = createTestEntry("evt-non-pending", topicName);
            dlq.add(entry);
            dlq.replay(entry.getDlqEntryId()); // Move to REPLAYED

            // Act & Assert
            assertThatThrownBy(() -> dlq.replay(entry.getDlqEntryId()))
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("REPLAYED");
        }

        @Test
        @DisplayName("should throw IllegalArgumentException for non-existent entry")
        void shouldThrowForNonExistentEntryOnReplay() {
            // Act & Assert
            assertThatThrownBy(() -> dlq.replay("non-existent-id"))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("not found");
        }

        @Test
        @DisplayName("should throw IllegalStateException when max replay attempts exceeded")
        void shouldThrowWhenMaxReplayAttemptsExceeded() {
            // Arrange - set max to 1 for this test
            properties.setMaxReplayAttempts(1);
            HazelcastDeadLetterQueue limitedDlq =
                    new HazelcastDeadLetterQueue(hazelcast, properties, meterRegistry);

            String topicName = "MaxReplayTopic_" + System.nanoTime();
            DeadLetterEntry entry = createTestEntry("evt-max-replay", topicName);
            limitedDlq.add(entry);

            // First replay sets replayCount=1, status=REPLAYED
            limitedDlq.replay(entry.getDlqEntryId());

            // Reset status back to PENDING via GenericRecord so we can try again
            DeadLetterEntry updated = limitedDlq.getEntry(entry.getDlqEntryId());
            updated.setStatus(DeadLetterEntry.Status.PENDING);
            hazelcast.<String, GenericRecord>getMap(properties.getMapName())
                    .set(entry.getDlqEntryId(), HazelcastDeadLetterQueue.toRecord(updated));

            // Act & Assert - replay count is now 1, which equals max of 1
            assertThatThrownBy(() -> limitedDlq.replay(entry.getDlqEntryId()))
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("Max replay attempts");
        }
    }

    @Nested
    @DisplayName("Discard")
    class Discard {

        @Test
        @DisplayName("should update entry status to DISCARDED")
        void shouldUpdateEntryStatusToDiscarded() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-discard", "DiscardTopic");
            dlq.add(entry);

            // Act
            dlq.discard(entry.getDlqEntryId());

            // Assert
            DeadLetterEntry updated = dlq.getEntry(entry.getDlqEntryId());
            assertThat(updated.getStatus()).isEqualTo(DeadLetterEntry.Status.DISCARDED);
        }

        @Test
        @DisplayName("should increment discarded counter metric")
        void shouldIncrementDiscardedCounterMetric() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-discard-metric", "DiscardMetricTopic");
            dlq.add(entry);

            // Act
            dlq.discard(entry.getDlqEntryId());

            // Assert
            double count = meterRegistry.counter("dlq.entries.discarded").count();
            assertThat(count).isEqualTo(1.0);
        }

        @Test
        @DisplayName("should throw IllegalStateException when discarding non-PENDING entry")
        void shouldThrowWhenDiscardingNonPendingEntry() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-discard-fail", "DiscardFailTopic");
            dlq.add(entry);
            dlq.discard(entry.getDlqEntryId()); // Move to DISCARDED

            // Act & Assert
            assertThatThrownBy(() -> dlq.discard(entry.getDlqEntryId()))
                    .isInstanceOf(IllegalStateException.class)
                    .hasMessageContaining("DISCARDED");
        }

        @Test
        @DisplayName("should throw IllegalArgumentException for non-existent entry")
        void shouldThrowForNonExistentEntryOnDiscard() {
            // Act & Assert
            assertThatThrownBy(() -> dlq.discard("non-existent-id"))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("not found");
        }
    }

    @Nested
    @DisplayName("Count")
    class Count {

        @Test
        @DisplayName("should return zero when no entries exist")
        void shouldReturnZeroWhenNoEntries() {
            // Act
            long count = dlq.count();

            // Assert
            assertThat(count).isZero();
        }

        @Test
        @DisplayName("should count only PENDING entries")
        void shouldCountOnlyPendingEntries() {
            // Arrange
            DeadLetterEntry pending1 = createTestEntry("evt-p1", "CountTopic");
            DeadLetterEntry pending2 = createTestEntry("evt-p2", "CountTopic");
            DeadLetterEntry toDiscard = createTestEntry("evt-d1", "CountTopic");
            dlq.add(pending1);
            dlq.add(pending2);
            dlq.add(toDiscard);
            dlq.discard(toDiscard.getDlqEntryId());

            // Act
            long count = dlq.count();

            // Assert
            assertThat(count).isEqualTo(2);
        }
    }

    @Nested
    @DisplayName("Full lifecycle")
    class FullLifecycle {

        @Test
        @DisplayName("should support add, list, getEntry, replay, and count cycle")
        void shouldSupportFullCycle() {
            // Arrange
            String topicName = "LifecycleTopic_" + System.nanoTime();
            DeadLetterEntry entry = createTestEntry("evt-lifecycle", topicName);

            // Add
            dlq.add(entry);
            assertThat(dlq.count()).isEqualTo(1);

            // List
            List<DeadLetterEntry> entries = dlq.list(10);
            assertThat(entries).hasSize(1);
            assertThat(entries.get(0).getOriginalEventId()).isEqualTo("evt-lifecycle");

            // GetEntry
            DeadLetterEntry retrieved = dlq.getEntry(entry.getDlqEntryId());
            assertThat(retrieved).isNotNull();
            assertThat(retrieved.getStatus()).isEqualTo(DeadLetterEntry.Status.PENDING);

            // Replay
            dlq.replay(entry.getDlqEntryId());
            DeadLetterEntry replayed = dlq.getEntry(entry.getDlqEntryId());
            assertThat(replayed.getStatus()).isEqualTo(DeadLetterEntry.Status.REPLAYED);

            // Count (no PENDING entries remain)
            assertThat(dlq.count()).isZero();
        }

        @Test
        @DisplayName("should support add, list, getEntry, discard, and count cycle")
        void shouldSupportDiscardCycle() {
            // Arrange
            DeadLetterEntry entry = createTestEntry("evt-discard-cycle", "DiscardCycleTopic");

            // Add
            dlq.add(entry);
            assertThat(dlq.count()).isEqualTo(1);

            // Discard
            dlq.discard(entry.getDlqEntryId());
            DeadLetterEntry discarded = dlq.getEntry(entry.getDlqEntryId());
            assertThat(discarded.getStatus()).isEqualTo(DeadLetterEntry.Status.DISCARDED);

            // Count (no PENDING entries remain)
            assertThat(dlq.count()).isZero();
        }
    }
}
