package com.theyawns.framework.persistence;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for {@link InMemoryEventStorePersistence}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("InMemoryEventStorePersistence - In-memory event store for testing")
class InMemoryEventStorePersistenceTest {

    private InMemoryEventStorePersistence persistence;

    @BeforeEach
    void setUp() {
        persistence = new InMemoryEventStorePersistence();
    }

    @Test
    @DisplayName("should persist and load a single event")
    void shouldPersistAndLoadSingleEvent() {
        // Arrange
        PersistableEvent event = new PersistableEvent(
                "seq:1|key:agg-001", "agg-001", 1L,
                "TestEvent", "{\"data\":\"hello\"}", 1700000000000L, "corr-1");

        // Act
        persistence.persist("TestMap_ES", event);
        Optional<PersistableEvent> loaded = persistence.loadEvent("TestMap_ES", "seq:1|key:agg-001");

        // Assert
        assertTrue(loaded.isPresent());
        assertEquals(event, loaded.get());
    }

    @Test
    @DisplayName("should persist batch of events")
    void shouldPersistBatchOfEvents() {
        // Arrange
        List<PersistableEvent> events = List.of(
                new PersistableEvent("seq:1|key:a", "a", 1L, "E1", "{}", 100L, null),
                new PersistableEvent("seq:2|key:b", "b", 2L, "E2", "{}", 200L, null),
                new PersistableEvent("seq:3|key:c", "c", 3L, "E3", "{}", 300L, null)
        );

        // Act
        persistence.persistBatch("BatchMap_ES", events);

        // Assert
        assertTrue(persistence.loadEvent("BatchMap_ES", "seq:1|key:a").isPresent());
        assertTrue(persistence.loadEvent("BatchMap_ES", "seq:2|key:b").isPresent());
        assertTrue(persistence.loadEvent("BatchMap_ES", "seq:3|key:c").isPresent());
    }

    @Test
    @DisplayName("should return empty when event not found")
    void shouldReturnEmptyWhenNotFound() {
        // Act
        Optional<PersistableEvent> result = persistence.loadEvent("NoSuchMap", "no-key");

        // Assert
        assertFalse(result.isPresent());
    }

    @Test
    @DisplayName("should delete a persisted event")
    void shouldDeleteEvent() {
        // Arrange
        PersistableEvent event = new PersistableEvent(
                "seq:1|key:del", "del", 1L, "E", "{}", 100L, null);
        persistence.persist("DelMap_ES", event);

        // Act
        persistence.delete("DelMap_ES", "seq:1|key:del");

        // Assert
        assertFalse(persistence.loadEvent("DelMap_ES", "seq:1|key:del").isPresent());
    }

    @Test
    @DisplayName("should isolate events by map name")
    void shouldIsolateByMapName() {
        // Arrange
        PersistableEvent event1 = new PersistableEvent(
                "seq:1|key:shared", "shared", 1L, "E1", "{\"v\":1}", 100L, null);
        PersistableEvent event2 = new PersistableEvent(
                "seq:1|key:shared", "shared", 1L, "E2", "{\"v\":2}", 200L, null);

        // Act
        persistence.persist("MapA_ES", event1);
        persistence.persist("MapB_ES", event2);

        // Assert
        assertEquals("E1", persistence.loadEvent("MapA_ES", "seq:1|key:shared").get().eventType());
        assertEquals("E2", persistence.loadEvent("MapB_ES", "seq:1|key:shared").get().eventType());
    }

    @Test
    @DisplayName("should load all keys for a map")
    void shouldLoadAllKeys() {
        // Arrange
        persistence.persist("KeyMap_ES", new PersistableEvent(
                "k1", "a1", 1L, "E", "{}", 100L, null));
        persistence.persist("KeyMap_ES", new PersistableEvent(
                "k2", "a2", 2L, "E", "{}", 200L, null));

        // Act
        List<String> keys = new ArrayList<>();
        persistence.loadAllKeys("KeyMap_ES").forEach(keys::add);

        // Assert
        assertEquals(2, keys.size());
        assertTrue(keys.contains("k1"));
        assertTrue(keys.contains("k2"));
    }

    @Test
    @DisplayName("should return empty keys for unknown map")
    void shouldReturnEmptyKeysForUnknownMap() {
        // Act
        List<String> keys = new ArrayList<>();
        persistence.loadAllKeys("Unknown_ES").forEach(keys::add);

        // Assert
        assertTrue(keys.isEmpty());
    }

    @Test
    @DisplayName("should always report available")
    void shouldAlwaysBeAvailable() {
        assertTrue(persistence.isAvailable());
    }

    @Test
    @DisplayName("should handle concurrent writes without errors")
    void shouldHandleConcurrentWrites() throws InterruptedException {
        // Arrange
        int threadCount = 10;
        int eventsPerThread = 100;
        ExecutorService executor = Executors.newFixedThreadPool(threadCount);
        CountDownLatch latch = new CountDownLatch(threadCount);

        // Act
        for (int t = 0; t < threadCount; t++) {
            final int threadId = t;
            executor.submit(() -> {
                try {
                    for (int i = 0; i < eventsPerThread; i++) {
                        String key = "seq:" + i + "|key:thread-" + threadId;
                        persistence.persist("ConcurrentMap_ES", new PersistableEvent(
                                key, "thread-" + threadId, i, "E", "{}", 100L, null));
                    }
                } finally {
                    latch.countDown();
                }
            });
        }

        latch.await(10, TimeUnit.SECONDS);
        executor.shutdown();

        // Assert â€” all events from all threads should be present
        List<String> allKeys = new ArrayList<>();
        persistence.loadAllKeys("ConcurrentMap_ES").forEach(allKeys::add);
        assertEquals(threadCount * eventsPerThread, allKeys.size());
    }
}
