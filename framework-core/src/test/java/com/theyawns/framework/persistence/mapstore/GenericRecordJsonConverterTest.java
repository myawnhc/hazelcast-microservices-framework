package com.theyawns.framework.persistence.mapstore;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.util.Map;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for {@link GenericRecordJsonConverter}.
 * Tests round-trip conversion of GenericRecord to/from JSON for all supported field types.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("GenericRecordJsonConverter - GenericRecord ↔ JSON round-trip conversion")
class GenericRecordJsonConverterTest {

    @Test
    @DisplayName("should round-trip STRING fields")
    void shouldRoundTripStringFields() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setString("name", "John Doe")
                .setString("email", "john@example.com")
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "TestEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertEquals("John Doe", restored.getString("name"));
        assertEquals("john@example.com", restored.getString("email"));
    }

    @Test
    @DisplayName("should round-trip null STRING fields")
    void shouldRoundTripNullStringFields() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setString("name", null)
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "TestEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertNull(restored.getString("name"));
    }

    @Test
    @DisplayName("should round-trip INT32 fields")
    void shouldRoundTripInt32Fields() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setInt32("count", 42)
                .setInt32("negative", -100)
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "TestEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertEquals(42, restored.getInt32("count"));
        assertEquals(-100, restored.getInt32("negative"));
    }

    @Test
    @DisplayName("should round-trip INT64 fields")
    void shouldRoundTripInt64Fields() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setInt64("timestamp", 1700000000000L)
                .setInt64("bigNumber", Long.MAX_VALUE)
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "TestEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertEquals(1700000000000L, restored.getInt64("timestamp"));
        assertEquals(Long.MAX_VALUE, restored.getInt64("bigNumber"));
    }

    @Test
    @DisplayName("should round-trip FLOAT32 fields")
    void shouldRoundTripFloat32Fields() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setFloat32("price", 19.99f)
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "TestEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertEquals(19.99f, restored.getFloat32("price"), 0.001f);
    }

    @Test
    @DisplayName("should round-trip FLOAT64 fields")
    void shouldRoundTripFloat64Fields() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setFloat64("amount", 1234.56789)
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "TestEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertEquals(1234.56789, restored.getFloat64("amount"), 0.00001);
    }

    @Test
    @DisplayName("should round-trip BOOLEAN fields")
    void shouldRoundTripBooleanFields() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setBoolean("active", true)
                .setBoolean("deleted", false)
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "TestEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertTrue(restored.getBoolean("active"));
        assertFalse(restored.getBoolean("deleted"));
    }

    @Test
    @DisplayName("should round-trip NULLABLE_INT32 fields")
    void shouldRoundTripNullableInt32Fields() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setNullableInt32("value", 42)
                .setNullableInt32("nullValue", null)
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "TestEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertEquals(42, restored.getNullableInt32("value"));
        assertNull(restored.getNullableInt32("nullValue"));
    }

    @Test
    @DisplayName("should round-trip NULLABLE_INT64 fields")
    void shouldRoundTripNullableInt64Fields() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setNullableInt64("value", 9999999999L)
                .setNullableInt64("nullValue", null)
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "TestEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertEquals(9999999999L, restored.getNullableInt64("value"));
        assertNull(restored.getNullableInt64("nullValue"));
    }

    @Test
    @DisplayName("should round-trip nested COMPACT (GenericRecord) fields")
    void shouldRoundTripNestedCompactFields() {
        // Arrange
        GenericRecord nested = GenericRecordBuilder.compact("Address")
                .setString("street", "123 Main St")
                .setString("city", "Springfield")
                .build();
        GenericRecord original = GenericRecordBuilder.compact("CustomerEvent")
                .setString("name", "John")
                .setGenericRecord("address", nested)
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "CustomerEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertEquals("John", restored.getString("name"));
        GenericRecord restoredAddress = restored.getGenericRecord("address");
        assertNotNull(restoredAddress);
        assertEquals("123 Main St", restoredAddress.getString("street"));
        assertEquals("Springfield", restoredAddress.getString("city"));
    }

    @Test
    @DisplayName("should round-trip mixed field types in one record")
    void shouldRoundTripMixedFieldTypes() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("OrderCreatedEvent")
                .setString("orderId", "ord-001")
                .setString("customerId", "cust-001")
                .setInt32("itemCount", 3)
                .setFloat64("totalAmount", 99.99)
                .setInt64("timestampMillis", 1700000000000L)
                .setBoolean("expedited", true)
                .setString("correlationId", "corr-abc")
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "OrderCreatedEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertEquals("ord-001", restored.getString("orderId"));
        assertEquals("cust-001", restored.getString("customerId"));
        assertEquals(3, restored.getInt32("itemCount"));
        assertEquals(99.99, restored.getFloat64("totalAmount"), 0.001);
        assertEquals(1700000000000L, restored.getInt64("timestampMillis"));
        assertTrue(restored.getBoolean("expedited"));
        assertEquals("corr-abc", restored.getString("correlationId"));
    }

    @Test
    @DisplayName("should handle strings with special characters")
    void shouldHandleSpecialCharacters() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setString("text", "Hello \"World\"\nNew Line\tTab\\Backslash")
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "TestEvent");
        GenericRecord restored = GenericRecordJsonConverter.fromJson(json);

        // Assert
        assertEquals("Hello \"World\"\nNew Line\tTab\\Backslash", restored.getString("text"));
    }

    @Test
    @DisplayName("should reject null record for toJson")
    void shouldRejectNullRecordForToJson() {
        assertThrows(IllegalArgumentException.class, () -> GenericRecordJsonConverter.toJson(null));
    }

    @Test
    @DisplayName("should reject null json for fromJson")
    void shouldRejectNullJsonForFromJson() {
        assertThrows(IllegalArgumentException.class, () -> GenericRecordJsonConverter.fromJson(null));
    }

    @Test
    @DisplayName("should reject malformed JSON")
    void shouldRejectMalformedJson() {
        assertThrows(IllegalArgumentException.class,
                () -> GenericRecordJsonConverter.fromJson("not valid json"));
    }

    @Test
    @DisplayName("should preserve schema type name through round-trip")
    void shouldPreserveSchemaTypeName() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("MyCustomEventType")
                .setString("data", "test")
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original, "MyCustomEventType");
        Map<String, Object> parsed = GenericRecordJsonConverter.jsonToMap(json);

        // Assert — schema type is stored in the JSON metadata
        assertEquals("MyCustomEventType", parsed.get(GenericRecordJsonConverter.SCHEMA_TYPE_KEY));
    }

    @Test
    @DisplayName("should infer schema type from eventType field")
    void shouldInferSchemaTypeFromEventTypeField() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("SomeSchema")
                .setString("eventType", "CustomerCreatedEvent")
                .setString("name", "John")
                .build();

        // Act — use toJson without explicit schema type
        String json = GenericRecordJsonConverter.toJson(original);
        Map<String, Object> parsed = GenericRecordJsonConverter.jsonToMap(json);

        // Assert — eventType field value is used as schema type
        assertEquals("CustomerCreatedEvent", parsed.get(GenericRecordJsonConverter.SCHEMA_TYPE_KEY));
    }

    @Test
    @DisplayName("should use default schema type when no eventType field present")
    void shouldUseDefaultSchemaTypeWhenNoEventTypeField() {
        // Arrange
        GenericRecord original = GenericRecordBuilder.compact("SomeSchema")
                .setString("name", "John")
                .build();

        // Act
        String json = GenericRecordJsonConverter.toJson(original);
        Map<String, Object> parsed = GenericRecordJsonConverter.jsonToMap(json);

        // Assert
        assertEquals(GenericRecordJsonConverter.DEFAULT_SCHEMA_TYPE,
                parsed.get(GenericRecordJsonConverter.SCHEMA_TYPE_KEY));
    }
}
