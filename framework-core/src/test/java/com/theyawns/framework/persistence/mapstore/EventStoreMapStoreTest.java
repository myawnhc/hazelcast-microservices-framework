package com.theyawns.framework.persistence.mapstore;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.framework.persistence.EventStorePersistence;
import com.theyawns.framework.persistence.PersistableEvent;
import com.theyawns.framework.store.PartitionedSequenceKey;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.*;
import static org.mockito.Mockito.*;

/**
 * Unit tests for {@link EventStoreMapStore}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("EventStoreMapStore - MapStore adapter for event persistence")
@ExtendWith(MockitoExtension.class)
class EventStoreMapStoreTest {

    @Mock
    private EventStorePersistence persistence;

    private EventStoreMapStore mapStore;

    @BeforeEach
    void setUp() {
        mapStore = new EventStoreMapStore(persistence);
    }

    @Test
    @DisplayName("should store a single event via persistence provider")
    void shouldStoreSingleEvent() {
        // Arrange
        PartitionedSequenceKey<String> key = new PartitionedSequenceKey<>(1000L, "cust-001");
        GenericRecord record = GenericRecordBuilder.compact("CustomerCreatedEvent")
                .setString("eventType", "CustomerCreatedEvent")
                .setString("name", "John")
                .setInt64("timestampMillis", 1700000000000L)
                .setString("correlationId", "corr-123")
                .build();

        // Act
        mapStore.store(key, record);

        // Assert
        ArgumentCaptor<PersistableEvent> captor = ArgumentCaptor.forClass(PersistableEvent.class);
        verify(persistence).persist(isNull(), captor.capture());

        PersistableEvent event = captor.getValue();
        assertEquals("seq:1000|key:cust-001", event.mapKey());
        assertEquals("cust-001", event.aggregateId());
        assertEquals(1000L, event.sequence());
        assertEquals("CustomerCreatedEvent", event.eventType());
        assertNotNull(event.eventData());
        assertEquals(1700000000000L, event.timestampMillis());
        assertEquals("corr-123", event.correlationId());
    }

    @Test
    @DisplayName("should batch store multiple events")
    void shouldBatchStoreEvents() {
        // Arrange
        Map<PartitionedSequenceKey<String>, GenericRecord> entries = new HashMap<>();
        entries.put(
                new PartitionedSequenceKey<>(1L, "cust-001"),
                GenericRecordBuilder.compact("Event1").setString("data", "a").build()
        );
        entries.put(
                new PartitionedSequenceKey<>(2L, "cust-002"),
                GenericRecordBuilder.compact("Event2").setString("data", "b").build()
        );

        // Act
        mapStore.storeAll(entries);

        // Assert
        @SuppressWarnings("unchecked")
        ArgumentCaptor<List<PersistableEvent>> captor = ArgumentCaptor.forClass(List.class);
        verify(persistence).persistBatch(isNull(), captor.capture());
        assertEquals(2, captor.getValue().size());
    }

    @Test
    @DisplayName("should not persist empty batch")
    void shouldNotPersistEmptyBatch() {
        // Act
        mapStore.storeAll(Map.of());

        // Assert
        verifyNoInteractions(persistence);
    }

    @Test
    @DisplayName("should load event from persistence and convert from JSON")
    void shouldLoadEvent() {
        // Arrange
        PartitionedSequenceKey<String> key = new PartitionedSequenceKey<>(1000L, "cust-001");
        GenericRecord original = GenericRecordBuilder.compact("TestEvent")
                .setString("name", "Test")
                .setInt32("value", 42)
                .build();
        String json = GenericRecordJsonConverter.toJson(original);

        PersistableEvent pe = new PersistableEvent(
                "seq:1000|key:cust-001", "cust-001", 1000L,
                "TestEvent", json, System.currentTimeMillis(), null);
        when(persistence.loadEvent(isNull(), eq("seq:1000|key:cust-001")))
                .thenReturn(Optional.of(pe));

        // Act
        GenericRecord loaded = mapStore.load(key);

        // Assert
        assertNotNull(loaded);
        assertEquals("Test", loaded.getString("name"));
        assertEquals(42, loaded.getInt32("value"));
    }

    @Test
    @DisplayName("should return null when event not found")
    void shouldReturnNullWhenNotFound() {
        // Arrange
        PartitionedSequenceKey<String> key = new PartitionedSequenceKey<>(999L, "nonexistent");
        when(persistence.loadEvent(isNull(), anyString())).thenReturn(Optional.empty());

        // Act
        GenericRecord result = mapStore.load(key);

        // Assert
        assertNull(result);
    }

    @Test
    @DisplayName("should return empty iterable for loadAllKeys (LAZY mode)")
    void shouldReturnEmptyForLoadAllKeys() {
        // Act
        Iterable<PartitionedSequenceKey<String>> keys = mapStore.loadAllKeys();

        // Assert
        assertFalse(keys.iterator().hasNext());
    }

    @Test
    @DisplayName("should delete event via persistence provider")
    void shouldDeleteEvent() {
        // Arrange
        PartitionedSequenceKey<String> key = new PartitionedSequenceKey<>(1000L, "cust-001");

        // Act
        mapStore.delete(key);

        // Assert
        verify(persistence).delete(isNull(), eq("seq:1000|key:cust-001"));
    }

    @Test
    @DisplayName("should serialize and deserialize keys correctly")
    void shouldSerializeDeserializeKeys() {
        // Arrange
        PartitionedSequenceKey<String> original = new PartitionedSequenceKey<>(12345L, "my-aggregate");

        // Act
        String serialized = EventStoreMapStore.serializeKey(original);
        PartitionedSequenceKey<String> deserialized = EventStoreMapStore.deserializeKey(serialized);

        // Assert
        assertEquals("seq:12345|key:my-aggregate", serialized);
        assertEquals(12345L, deserialized.getSequence());
        assertEquals("my-aggregate", deserialized.getKey());
    }

    @Test
    @DisplayName("should reject null persistence provider")
    void shouldRejectNullPersistence() {
        assertThrows(IllegalArgumentException.class, () -> new EventStoreMapStore(null));
    }

    @Test
    @DisplayName("should load all events from persistence")
    void shouldLoadAllEventsFromPersistence() {
        // Arrange
        PartitionedSequenceKey<String> key1 = new PartitionedSequenceKey<>(1L, "cust-001");
        PartitionedSequenceKey<String> key2 = new PartitionedSequenceKey<>(2L, "cust-002");

        GenericRecord rec1 = GenericRecordBuilder.compact("E1").setString("v", "a").build();
        GenericRecord rec2 = GenericRecordBuilder.compact("E2").setString("v", "b").build();

        when(persistence.loadEvent(isNull(), eq("seq:1|key:cust-001")))
                .thenReturn(Optional.of(new PersistableEvent("seq:1|key:cust-001", "cust-001", 1L,
                        "E1", GenericRecordJsonConverter.toJson(rec1), 100L, null)));
        when(persistence.loadEvent(isNull(), eq("seq:2|key:cust-002")))
                .thenReturn(Optional.of(new PersistableEvent("seq:2|key:cust-002", "cust-002", 2L,
                        "E2", GenericRecordJsonConverter.toJson(rec2), 200L, null)));

        // Act
        Map<PartitionedSequenceKey<String>, GenericRecord> result =
                mapStore.loadAll(List.of(key1, key2));

        // Assert
        assertEquals(2, result.size());
        assertEquals("a", result.get(key1).getString("v"));
        assertEquals("b", result.get(key2).getString("v"));
    }

    @Test
    @DisplayName("should skip missing events in loadAll")
    void shouldLoadAllSkippingMissingEvents() {
        // Arrange
        PartitionedSequenceKey<String> key1 = new PartitionedSequenceKey<>(1L, "cust-001");
        PartitionedSequenceKey<String> key2 = new PartitionedSequenceKey<>(2L, "cust-002");

        GenericRecord rec1 = GenericRecordBuilder.compact("E1").setString("v", "a").build();
        when(persistence.loadEvent(isNull(), eq("seq:1|key:cust-001")))
                .thenReturn(Optional.of(new PersistableEvent("seq:1|key:cust-001", "cust-001", 1L,
                        "E1", GenericRecordJsonConverter.toJson(rec1), 100L, null)));
        when(persistence.loadEvent(isNull(), eq("seq:2|key:cust-002")))
                .thenReturn(Optional.empty());

        // Act
        Map<PartitionedSequenceKey<String>, GenericRecord> result =
                mapStore.loadAll(List.of(key1, key2));

        // Assert
        assertEquals(1, result.size());
        assertTrue(result.containsKey(key1));
        assertFalse(result.containsKey(key2));
    }

    @Test
    @DisplayName("should delete all events via persistence provider")
    void shouldDeleteAllEvents() {
        // Arrange
        PartitionedSequenceKey<String> key1 = new PartitionedSequenceKey<>(1L, "a");
        PartitionedSequenceKey<String> key2 = new PartitionedSequenceKey<>(2L, "b");
        PartitionedSequenceKey<String> key3 = new PartitionedSequenceKey<>(3L, "c");

        // Act
        mapStore.deleteAll(List.of(key1, key2, key3));

        // Assert
        verify(persistence).delete(isNull(), eq("seq:1|key:a"));
        verify(persistence).delete(isNull(), eq("seq:2|key:b"));
        verify(persistence).delete(isNull(), eq("seq:3|key:c"));
    }

    @Test
    @DisplayName("should set mapName on init and pass through to persistence")
    void shouldInitWithMapName() {
        // Act
        mapStore.init(null, new java.util.Properties(), "Customer_ES");

        PartitionedSequenceKey<String> key = new PartitionedSequenceKey<>(1L, "cust-001");
        GenericRecord record = GenericRecordBuilder.compact("E")
                .setString("data", "test")
                .build();
        mapStore.store(key, record);

        // Assert
        ArgumentCaptor<PersistableEvent> captor = ArgumentCaptor.forClass(PersistableEvent.class);
        verify(persistence).persist(eq("Customer_ES"), captor.capture());
        assertEquals("seq:1|key:cust-001", captor.getValue().mapKey());
    }
}
