package com.theyawns.framework.idempotency;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Tests for {@link HazelcastIdempotencyGuard}.
 *
 * <p>Uses a real embedded Hazelcast instance with standalone configuration
 * (no cluster join). This avoids Mockito issues with concrete Hazelcast
 * classes on Java 25.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("HazelcastIdempotencyGuard - IMap-backed idempotency checking")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class HazelcastIdempotencyGuardTest {

    private HazelcastInstance hazelcast;
    private SimpleMeterRegistry meterRegistry;
    private IdempotencyProperties properties;
    private HazelcastIdempotencyGuard guard;

    @BeforeAll
    void startHazelcast() {
        Config config = new Config();
        config.setClusterName("idempotency-test-" + System.nanoTime());
        config.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
        config.getNetworkConfig().getJoin().getAutoDetectionConfig().setEnabled(false);
        config.getJetConfig().setEnabled(false);
        hazelcast = Hazelcast.newHazelcastInstance(config);
    }

    @AfterAll
    void stopHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        properties = new IdempotencyProperties();
        // Use a unique map name per test to avoid cross-test pollution
        properties.setMapName("test_PROCESSED_" + System.nanoTime());
        guard = new HazelcastIdempotencyGuard(hazelcast, properties, meterRegistry);
    }

    @Nested
    @DisplayName("tryProcess")
    class TryProcess {

        @Test
        @DisplayName("should return true on first call for an event ID")
        void shouldReturnTrueOnFirstCall() {
            // Act
            boolean result = guard.tryProcess("evt-001");

            // Assert
            assertThat(result).isTrue();
        }

        @Test
        @DisplayName("should return false on second call with same event ID (duplicate)")
        void shouldReturnFalseOnSecondCallWithSameEventId() {
            // Arrange
            guard.tryProcess("evt-dup");

            // Act
            boolean result = guard.tryProcess("evt-dup");

            // Assert
            assertThat(result).isFalse();
        }

        @Test
        @DisplayName("should return true for different event IDs")
        void shouldReturnTrueForDifferentEventIds() {
            // Act
            boolean first = guard.tryProcess("evt-a");
            boolean second = guard.tryProcess("evt-b");

            // Assert
            assertThat(first).isTrue();
            assertThat(second).isTrue();
        }

        @Test
        @DisplayName("should return false on repeated calls with same event ID")
        void shouldReturnFalseOnRepeatedCalls() {
            // Arrange
            guard.tryProcess("evt-repeat");

            // Act & Assert
            assertThat(guard.tryProcess("evt-repeat")).isFalse();
            assertThat(guard.tryProcess("evt-repeat")).isFalse();
            assertThat(guard.tryProcess("evt-repeat")).isFalse();
        }

        @Test
        @DisplayName("should throw NullPointerException for null event ID")
        void shouldThrowForNullEventId() {
            // Act & Assert
            assertThatThrownBy(() -> guard.tryProcess(null))
                    .isInstanceOf(NullPointerException.class)
                    .hasMessageContaining("eventId");
        }
    }

    @Nested
    @DisplayName("Metrics")
    class Metrics {

        @Test
        @DisplayName("should record miss metric on first call")
        void shouldRecordMissMetricOnFirstCall() {
            // Act
            guard.tryProcess("evt-metric-miss");

            // Assert
            Counter missCounter = meterRegistry.counter("idempotency.checks", "result", "miss");
            assertThat(missCounter.count()).isEqualTo(1.0);
        }

        @Test
        @DisplayName("should record hit metric on duplicate call")
        void shouldRecordHitMetricOnDuplicateCall() {
            // Arrange
            guard.tryProcess("evt-metric-hit");

            // Act
            guard.tryProcess("evt-metric-hit");

            // Assert
            Counter hitCounter = meterRegistry.counter("idempotency.checks", "result", "hit");
            assertThat(hitCounter.count()).isEqualTo(1.0);
        }

        @Test
        @DisplayName("should accumulate metrics across multiple calls")
        void shouldAccumulateMetricsAcrossMultipleCalls() {
            // Act - 3 unique events (misses) and 2 duplicates (hits)
            guard.tryProcess("evt-m1");
            guard.tryProcess("evt-m2");
            guard.tryProcess("evt-m3");
            guard.tryProcess("evt-m1"); // duplicate
            guard.tryProcess("evt-m2"); // duplicate

            // Assert
            Counter missCounter = meterRegistry.counter("idempotency.checks", "result", "miss");
            Counter hitCounter = meterRegistry.counter("idempotency.checks", "result", "hit");
            assertThat(missCounter.count()).isEqualTo(3.0);
            assertThat(hitCounter.count()).isEqualTo(2.0);
        }
    }
}
