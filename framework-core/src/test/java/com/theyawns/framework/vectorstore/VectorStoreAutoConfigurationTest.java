package com.theyawns.framework.vectorstore;

import com.hazelcast.config.Config;
import com.hazelcast.core.HazelcastInstance;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.test.context.runner.ApplicationContextRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link VectorStoreAutoConfiguration}.
 *
 * <p>Uses {@link ApplicationContextRunner} to test auto-configuration behavior
 * without starting a full Spring Boot application.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("VectorStoreAutoConfiguration - Auto-configuration behavior")
class VectorStoreAutoConfigurationTest {

    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(VectorStoreAutoConfiguration.class));

    @Nested
    @DisplayName("With HazelcastInstance present")
    class WithHazelcast {

        @Test
        @DisplayName("should enable VectorStoreProperties and VectorStoreService beans")
        void shouldEnableVectorStoreProperties() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(VectorStoreProperties.class);
                        assertThat(context).hasSingleBean(VectorStoreService.class);
                    });
        }

        @Test
        @DisplayName("should create NoOp fallback when no other VectorStoreService exists")
        void shouldCreateNoOpFallbackWhenNoOtherServiceExists() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .run(context -> {
                        final VectorStoreService service = context.getBean(VectorStoreService.class);
                        assertThat(service).isInstanceOf(NoOpVectorStoreService.class);
                        assertThat(service.isAvailable()).isFalse();
                    });
        }

        @Test
        @DisplayName("should bind default properties")
        void shouldBindDefaultProperties() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .run(context -> {
                        final VectorStoreProperties props = context.getBean(VectorStoreProperties.class);
                        assertThat(props.getCollectionName()).isEqualTo("product-vectors");
                        assertThat(props.getDimension()).isEqualTo(128);
                        assertThat(props.getMaxConnections()).isEqualTo(16);
                        assertThat(props.getEfConstruction()).isEqualTo(200);
                        assertThat(props.getMetric()).isEqualTo("COSINE");
                        assertThat(props.getIndexName()).isEqualTo("default");
                    });
        }

        @Test
        @DisplayName("should bind custom properties")
        void shouldBindCustomProperties() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues(
                            "framework.vectorstore.collection-name=custom-vectors",
                            "framework.vectorstore.dimension=256",
                            "framework.vectorstore.max-connections=32",
                            "framework.vectorstore.ef-construction=400",
                            "framework.vectorstore.metric=DOT",
                            "framework.vectorstore.index-name=custom-index"
                    )
                    .run(context -> {
                        final VectorStoreProperties props = context.getBean(VectorStoreProperties.class);
                        assertThat(props.getCollectionName()).isEqualTo("custom-vectors");
                        assertThat(props.getDimension()).isEqualTo(256);
                        assertThat(props.getMaxConnections()).isEqualTo(32);
                        assertThat(props.getEfConstruction()).isEqualTo(400);
                        assertThat(props.getMetric()).isEqualTo("DOT");
                        assertThat(props.getIndexName()).isEqualTo("custom-index");
                    });
        }
    }

    @Nested
    @DisplayName("Without HazelcastInstance")
    class WithoutHazelcast {

        @Test
        @DisplayName("should not create any beans when HazelcastInstance is missing")
        void shouldNotCreateAnyBeansWhenHazelcastMissing() {
            contextRunner
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(VectorStoreProperties.class);
                        assertThat(context).doesNotHaveBean(VectorStoreService.class);
                    });
        }
    }

    @Nested
    @DisplayName("Custom bean override")
    class CustomBeanOverride {

        @Test
        @DisplayName("should not override existing VectorStoreService bean")
        void shouldNotOverrideExistingVectorStoreServiceBean() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class, CustomVectorStoreConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(VectorStoreService.class);
                        final VectorStoreService service = context.getBean(VectorStoreService.class);
                        assertThat(service.getImplementationType()).isEqualTo("Custom Test Implementation");
                    });
        }
    }

    // ========== Test Configuration Classes ==========

    @Configuration
    static class HazelcastConfig {

        @Bean
        HazelcastInstance hazelcastInstance() {
            final HazelcastInstance mock = mock(HazelcastInstance.class);
            // Use real Config (not mockable on Java 25 with Mockito inline)
            final Config config = new Config();
            when(mock.getConfig()).thenReturn(config);
            return mock;
        }
    }

    @Configuration
    static class CustomVectorStoreConfig {

        @Bean
        VectorStoreService vectorStoreService() {
            return new NoOpVectorStoreService() {
                @Override
                public String getImplementationType() {
                    return "Custom Test Implementation";
                }
            };
        }
    }
}
