package com.theyawns.framework.vectorstore;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.assertj.core.api.Assertions.within;

/**
 * Tests for {@link TextEmbeddingGenerator}.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("TextEmbeddingGenerator - Deterministic embedding generation")
class TextEmbeddingGeneratorTest {

    private static final int DIMENSION = 128;

    @Nested
    @DisplayName("Embedding generation")
    class GenerationTests {

        @Test
        @DisplayName("should produce vector of correct dimension")
        void shouldProduceCorrectDimension() {
            float[] embedding = TextEmbeddingGenerator.generateEmbedding("test product", DIMENSION);
            assertThat(embedding).hasSize(DIMENSION);
        }

        @Test
        @DisplayName("should produce deterministic output for same input")
        void shouldBeDeterministic() {
            float[] first = TextEmbeddingGenerator.generateEmbedding("wireless headphones", DIMENSION);
            float[] second = TextEmbeddingGenerator.generateEmbedding("wireless headphones", DIMENSION);
            assertThat(first).isEqualTo(second);
        }

        @Test
        @DisplayName("should produce different vectors for different text")
        void shouldDifferForDifferentText() {
            float[] a = TextEmbeddingGenerator.generateEmbedding("wireless headphones", DIMENSION);
            float[] b = TextEmbeddingGenerator.generateEmbedding("leather wallet", DIMENSION);
            assertThat(a).isNotEqualTo(b);
        }

        @Test
        @DisplayName("should work with various dimensions")
        void shouldWorkWithVariousDimensions() {
            for (int dim : new int[]{1, 32, 64, 256, 512}) {
                float[] embedding = TextEmbeddingGenerator.generateEmbedding("test", dim);
                assertThat(embedding).hasSize(dim);
            }
        }
    }

    @Nested
    @DisplayName("Normalization")
    class NormalizationTests {

        @Test
        @DisplayName("should produce L2-normalized vector")
        void shouldBeNormalized() {
            float[] embedding = TextEmbeddingGenerator.generateEmbedding("test product", DIMENSION);

            float sumSquares = 0.0f;
            for (float v : embedding) {
                sumSquares += v * v;
            }
            float magnitude = (float) Math.sqrt(sumSquares);

            assertThat(magnitude).isCloseTo(1.0f, within(0.001f));
        }

        @Test
        @DisplayName("should handle empty string gracefully")
        void shouldHandleEmptyString() {
            float[] embedding = TextEmbeddingGenerator.generateEmbedding("", DIMENSION);
            assertThat(embedding).hasSize(DIMENSION);
            // Empty text produces zero vector
            for (float v : embedding) {
                assertThat(v).isEqualTo(0.0f);
            }
        }

        @Test
        @DisplayName("should handle whitespace-only string")
        void shouldHandleWhitespaceOnly() {
            float[] embedding = TextEmbeddingGenerator.generateEmbedding("   ", DIMENSION);
            assertThat(embedding).hasSize(DIMENSION);
        }
    }

    @Nested
    @DisplayName("Input validation")
    class ValidationTests {

        @Test
        @DisplayName("should reject null text")
        void shouldRejectNullText() {
            assertThatThrownBy(() -> TextEmbeddingGenerator.generateEmbedding(null, DIMENSION))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("null");
        }

        @Test
        @DisplayName("should reject non-positive dimension")
        void shouldRejectNonPositiveDimension() {
            assertThatThrownBy(() -> TextEmbeddingGenerator.generateEmbedding("test", 0))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("positive");

            assertThatThrownBy(() -> TextEmbeddingGenerator.generateEmbedding("test", -1))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("positive");
        }
    }

    @Nested
    @DisplayName("Case insensitivity")
    class CaseInsensitivityTests {

        @Test
        @DisplayName("should produce same vector regardless of case")
        void shouldBeCaseInsensitive() {
            float[] lower = TextEmbeddingGenerator.generateEmbedding("test product", DIMENSION);
            float[] upper = TextEmbeddingGenerator.generateEmbedding("TEST PRODUCT", DIMENSION);
            float[] mixed = TextEmbeddingGenerator.generateEmbedding("Test Product", DIMENSION);

            assertThat(lower).isEqualTo(upper);
            assertThat(lower).isEqualTo(mixed);
        }
    }
}
