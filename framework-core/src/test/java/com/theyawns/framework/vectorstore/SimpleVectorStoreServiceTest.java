package com.theyawns.framework.vectorstore;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.within;

/**
 * Tests for {@link SimpleVectorStoreService}.
 *
 * <p>Uses a real embedded Hazelcast instance because {@code IMap} cannot be mocked
 * with Mockito inline mock maker on Java 25.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("SimpleVectorStoreService - IMap-based vector store")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class SimpleVectorStoreServiceTest {

    private HazelcastInstance hazelcast;
    private SimpleVectorStoreService service;

    @BeforeAll
    void setUpHazelcast() {
        Config config = new Config();
        config.setClusterName("vector-store-test-" + System.currentTimeMillis());
        config.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
        config.getNetworkConfig().getJoin().getAutoDetectionConfig().setEnabled(false);
        hazelcast = Hazelcast.newHazelcastInstance(config);
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void setUp() {
        VectorStoreProperties properties = new VectorStoreProperties();
        properties.setCollectionName("test-vectors");
        properties.setDimension(4);

        service = new SimpleVectorStoreService(hazelcast, properties);

        // Clear maps between tests
        hazelcast.getMap("test-vectors").clear();
        hazelcast.getMap("test-vectors-metadata").clear();
    }

    @Nested
    @DisplayName("Availability")
    class AvailabilityTests {

        @Test
        @DisplayName("should always report as available")
        void shouldBeAvailable() {
            assertThat(service.isAvailable()).isTrue();
        }

        @Test
        @DisplayName("should report correct implementation type")
        void shouldReportImplementationType() {
            assertThat(service.getImplementationType()).contains("Enterprise");
        }
    }

    @Nested
    @DisplayName("storeEmbedding and retrieval")
    class StoreAndRetrieveTests {

        @Test
        @DisplayName("should store and retrieve embeddings")
        void shouldStoreAndRetrieve() {
            float[] embedding = {1.0f, 0.0f, 0.0f, 0.0f};
            service.storeEmbedding("item-1", embedding, Map.of("name", "Test Item"));

            List<SimilarityResult> results = service.findSimilar(embedding, 5);
            assertThat(results).hasSize(1);
            assertThat(results.get(0).id()).isEqualTo("item-1");
            assertThat(results.get(0).metadata()).containsEntry("name", "Test Item");
        }

        @Test
        @DisplayName("should store embedding with null metadata")
        void shouldStoreWithNullMetadata() {
            float[] embedding = {0.0f, 1.0f, 0.0f, 0.0f};
            service.storeEmbedding("item-2", embedding, null);

            List<SimilarityResult> results = service.findSimilar(embedding, 5);
            assertThat(results).hasSize(1);
            assertThat(results.get(0).id()).isEqualTo("item-2");
        }
    }

    @Nested
    @DisplayName("Cosine similarity")
    class CosineSimilarityTests {

        @Test
        @DisplayName("should return 1.0 for identical vectors")
        void shouldReturn1ForIdenticalVectors() {
            float[] a = {1.0f, 0.0f, 0.0f, 0.0f};
            float similarity = SimpleVectorStoreService.cosineSimilarity(a, a);
            assertThat(similarity).isCloseTo(1.0f, within(0.0001f));
        }

        @Test
        @DisplayName("should return 0.0 for orthogonal vectors")
        void shouldReturn0ForOrthogonalVectors() {
            float[] a = {1.0f, 0.0f, 0.0f, 0.0f};
            float[] b = {0.0f, 1.0f, 0.0f, 0.0f};
            float similarity = SimpleVectorStoreService.cosineSimilarity(a, b);
            assertThat(similarity).isCloseTo(0.0f, within(0.0001f));
        }

        @Test
        @DisplayName("should return -1.0 for opposite vectors")
        void shouldReturnNeg1ForOppositeVectors() {
            float[] a = {1.0f, 0.0f, 0.0f, 0.0f};
            float[] b = {-1.0f, 0.0f, 0.0f, 0.0f};
            float similarity = SimpleVectorStoreService.cosineSimilarity(a, b);
            assertThat(similarity).isCloseTo(-1.0f, within(0.0001f));
        }

        @Test
        @DisplayName("should return 0.0 for zero vectors")
        void shouldReturn0ForZeroVectors() {
            float[] a = {0.0f, 0.0f, 0.0f, 0.0f};
            float[] b = {1.0f, 0.0f, 0.0f, 0.0f};
            float similarity = SimpleVectorStoreService.cosineSimilarity(a, b);
            assertThat(similarity).isEqualTo(0.0f);
        }
    }

    @Nested
    @DisplayName("findSimilar")
    class FindSimilarTests {

        @Test
        @DisplayName("should return empty list for empty store")
        void shouldReturnEmptyForEmptyStore() {
            List<SimilarityResult> results = service.findSimilar(new float[]{1, 0, 0, 0}, 5);
            assertThat(results).isEmpty();
        }

        @Test
        @DisplayName("should return results sorted by descending similarity")
        void shouldReturnSortedResults() {
            float[] query = {1.0f, 0.0f, 0.0f, 0.0f};

            service.storeEmbedding("a", new float[]{0.9f, 0.1f, 0.0f, 0.0f}, Map.of("name", "A"));
            service.storeEmbedding("b", new float[]{0.5f, 0.5f, 0.0f, 0.0f}, Map.of("name", "B"));
            service.storeEmbedding("c", new float[]{0.0f, 1.0f, 0.0f, 0.0f}, Map.of("name", "C"));

            List<SimilarityResult> results = service.findSimilar(query, 3);

            assertThat(results).hasSize(3);
            assertThat(results.get(0).id()).isEqualTo("a");
            assertThat(results.get(1).id()).isEqualTo("b");
            assertThat(results.get(2).id()).isEqualTo("c");
            assertThat(results.get(0).score()).isGreaterThan(results.get(1).score());
            assertThat(results.get(1).score()).isGreaterThan(results.get(2).score());
        }

        @Test
        @DisplayName("should respect the limit parameter")
        void shouldRespectLimit() {
            service.storeEmbedding("a", new float[]{1.0f, 0.0f, 0.0f, 0.0f}, Map.of());
            service.storeEmbedding("b", new float[]{0.5f, 0.5f, 0.0f, 0.0f}, Map.of());
            service.storeEmbedding("c", new float[]{0.0f, 1.0f, 0.0f, 0.0f}, Map.of());

            List<SimilarityResult> results = service.findSimilar(
                    new float[]{1.0f, 0.0f, 0.0f, 0.0f}, 2);

            assertThat(results).hasSize(2);
        }
    }

    @Nested
    @DisplayName("findSimilarById")
    class FindSimilarByIdTests {

        @Test
        @DisplayName("should return empty list when ID not found")
        void shouldReturnEmptyWhenIdNotFound() {
            List<SimilarityResult> results = service.findSimilarById("unknown", 5);
            assertThat(results).isEmpty();
        }

        @Test
        @DisplayName("should exclude the query item from results")
        void shouldExcludeQueryItem() {
            service.storeEmbedding("query-id", new float[]{1.0f, 0.0f, 0.0f, 0.0f}, Map.of());
            service.storeEmbedding("other", new float[]{0.9f, 0.1f, 0.0f, 0.0f}, Map.of());

            List<SimilarityResult> results = service.findSimilarById("query-id", 5);

            assertThat(results).noneMatch(r -> r.id().equals("query-id"));
            assertThat(results).hasSize(1);
            assertThat(results.get(0).id()).isEqualTo("other");
        }
    }
}
