package com.theyawns.framework.saga.orchestrator;

import com.theyawns.framework.saga.SagaMetrics;
import com.theyawns.framework.saga.SagaStateStore;
import com.theyawns.framework.saga.SagaStatus;
import io.micrometer.core.instrument.Timer;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.time.Duration;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.atLeastOnce;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.times;
import static org.mockito.Mockito.verify;

/**
 * Tests for {@link HazelcastSagaOrchestrator}.
 *
 * <p>Uses Mockito to mock {@link SagaStateStore} (interface â€” works on Java 25).
 * Test actions and compensations are lambdas returning controlled CompletableFutures.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("HazelcastSagaOrchestrator")
class HazelcastSagaOrchestratorTest {

    @Mock
    private SagaStateStore stateStore;

    private ScheduledExecutorService scheduler;
    private HazelcastSagaOrchestrator orchestrator;

    @BeforeEach
    void setUp() {
        scheduler = Executors.newScheduledThreadPool(2);
        orchestrator = new HazelcastSagaOrchestrator(stateStore, Collections.emptyList(), scheduler);
    }

    // ========== Helper Methods ==========

    /**
     * Creates a simple saga action that completes immediately with success.
     */
    private static SagaAction successAction() {
        return ctx -> CompletableFuture.completedFuture(SagaStepResult.success());
    }

    /**
     * Creates a saga action that completes with success and carries data.
     */
    private static SagaAction successActionWithData(final Map<String, Object> data) {
        return ctx -> CompletableFuture.completedFuture(SagaStepResult.success(data));
    }

    /**
     * Creates a saga action that completes immediately with failure.
     */
    private static SagaAction failAction(final String errorMessage) {
        return ctx -> CompletableFuture.completedFuture(SagaStepResult.failure(errorMessage));
    }

    /**
     * Creates a saga action that never completes (for timeout testing).
     */
    private static SagaAction hangingAction() {
        return ctx -> new CompletableFuture<>();
    }

    /**
     * Creates a compensation that completes immediately with success.
     */
    private static SagaCompensation successCompensation() {
        return ctx -> CompletableFuture.completedFuture(SagaStepResult.success());
    }

    /**
     * Creates a compensation that completes immediately with failure.
     */
    private static SagaCompensation failCompensation(final String errorMessage) {
        return ctx -> CompletableFuture.completedFuture(SagaStepResult.failure(errorMessage));
    }

    /**
     * Builds a simple 3-step saga definition with fast timeouts.
     */
    private SagaDefinition threeStepSaga() {
        return SagaDefinition.builder()
                .name("TestSaga")
                .step("Step1").action(successAction()).compensation(successCompensation())
                    .timeout(Duration.ofSeconds(5)).build()
                .step("Step2").action(successAction()).compensation(successCompensation())
                    .timeout(Duration.ofSeconds(5)).build()
                .step("Step3").action(successAction()).noCompensation()
                    .timeout(Duration.ofSeconds(5)).build()
                .build();
    }

    // ========== Test Groups ==========

    @Nested
    @DisplayName("Construction & Validation")
    class ConstructionAndValidation {

        @Test
        @DisplayName("should reject null stateStore")
        void shouldRejectNullStateStore() {
            assertThatThrownBy(() -> new HazelcastSagaOrchestrator(null, null, null))
                    .isInstanceOf(NullPointerException.class)
                    .hasMessageContaining("stateStore");
        }

        @Test
        @DisplayName("should reject null sagaId")
        void shouldRejectNullSagaId() {
            assertThatThrownBy(() -> orchestrator.start(null, threeStepSaga(), SagaContext.create()))
                    .isInstanceOf(NullPointerException.class);
        }

        @Test
        @DisplayName("should reject null definition")
        void shouldRejectNullDefinition() {
            assertThatThrownBy(() -> orchestrator.start("saga-1", null, SagaContext.create()))
                    .isInstanceOf(NullPointerException.class);
        }

        @Test
        @DisplayName("should reject null context")
        void shouldRejectNullContext() {
            assertThatThrownBy(() -> orchestrator.start("saga-1", threeStepSaga(), null))
                    .isInstanceOf(NullPointerException.class);
        }

        @Test
        @DisplayName("should reject duplicate sagaId")
        void shouldRejectDuplicateSagaId() {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("SlowSaga")
                    .step("Slow").action(hangingAction()).noCompensation()
                        .timeout(Duration.ofSeconds(30)).build()
                    .build();

            orchestrator.start("saga-dup", def, SagaContext.create());

            assertThatThrownBy(() -> orchestrator.start("saga-dup", def, SagaContext.create()))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("already active");
        }
    }

    @Nested
    @DisplayName("Happy Path (Forward Execution)")
    class HappyPath {

        @Test
        @DisplayName("should complete single-step saga")
        void shouldCompleteSingleStepSaga() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("SingleStep")
                    .step("OnlyStep").action(successAction()).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            final SagaOrchestratorResult result = orchestrator.start("saga-1", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            assertThat(result.isSuccessful()).isTrue();
            assertThat(result.getStatus()).isEqualTo(SagaStatus.COMPLETED);
            assertThat(result.getStepsCompleted()).isEqualTo(1);
            assertThat(result.getSagaId()).isEqualTo("saga-1");
            assertThat(result.getSagaName()).isEqualTo("SingleStep");
        }

        @Test
        @DisplayName("should complete multi-step saga")
        void shouldCompleteMultiStepSaga() throws Exception {
            final SagaOrchestratorResult result = orchestrator.start(
                    "saga-2", threeStepSaga(), SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            assertThat(result.isSuccessful()).isTrue();
            assertThat(result.getStepsCompleted()).isEqualTo(3);
        }

        @Test
        @DisplayName("should pass data between steps via context")
        void shouldPassDataBetweenStepsViaContext() throws Exception {
            final SagaContext context = SagaContext.create();

            final SagaDefinition def = SagaDefinition.builder()
                    .name("DataPassing")
                    .step("Producer")
                        .action(successActionWithData(Map.of("key1", "value1")))
                        .noCompensation().timeout(Duration.ofSeconds(5)).build()
                    .step("Consumer")
                        .action(ctx -> {
                            final String val = ctx.get("key1", String.class);
                            assertThat(val).isEqualTo("value1");
                            return CompletableFuture.completedFuture(SagaStepResult.success());
                        })
                        .noCompensation().timeout(Duration.ofSeconds(5)).build()
                    .build();

            final SagaOrchestratorResult result = orchestrator.start("saga-3", def, context)
                    .get(5, TimeUnit.SECONDS);

            assertThat(result.isSuccessful()).isTrue();
            assertThat(context.get("key1")).isEqualTo("value1");
        }

        @Test
        @DisplayName("should record all steps in stateStore")
        void shouldRecordAllStepsInStateStore() throws Exception {
            orchestrator.start("saga-4", threeStepSaga(), SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            verify(stateStore).startSaga(eq("saga-4"), eq("TestSaga"), eq(3), any(Duration.class));
            verify(stateStore).recordStepCompleted("saga-4", 0, "Step1", "orchestrator", "saga-4");
            verify(stateStore).recordStepCompleted("saga-4", 1, "Step2", "orchestrator", "saga-4");
            verify(stateStore).recordStepCompleted("saga-4", 2, "Step3", "orchestrator", "saga-4");
            verify(stateStore).completeSaga("saga-4", SagaStatus.COMPLETED);
        }

        @Test
        @DisplayName("should return COMPLETED result with correct counts")
        void shouldReturnCompletedResultWithCorrectCounts() throws Exception {
            final SagaOrchestratorResult result = orchestrator.start(
                    "saga-5", threeStepSaga(), SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            assertThat(result.getStatus()).isEqualTo(SagaStatus.COMPLETED);
            assertThat(result.getStepsCompleted()).isEqualTo(3);
            assertThat(result.getStepsCompensated()).isEqualTo(0);
            assertThat(result.getFailureReason()).isEmpty();
            assertThat(result.getFailedAtStep()).isEmpty();
        }
    }

    @Nested
    @DisplayName("Failure Path (Compensation)")
    class FailurePath {

        @Test
        @DisplayName("should compensate when step fails")
        void shouldCompensateWhenStepFails() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("FailSaga")
                    .step("Step1").action(successAction()).compensation(successCompensation())
                        .timeout(Duration.ofSeconds(5)).build()
                    .step("Step2").action(failAction("Step2 failed")).compensation(successCompensation())
                        .timeout(Duration.ofSeconds(5)).build()
                    .step("Step3").action(successAction()).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            final SagaOrchestratorResult result = orchestrator.start("saga-fail", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            assertThat(result.isCompensated()).isTrue();
            assertThat(result.getStepsCompleted()).isEqualTo(1);
            assertThat(result.getStepsCompensated()).isEqualTo(1);
            assertThat(result.getFailedAtStep()).contains("Step2");
            assertThat(result.getFailureReason()).contains("Step2 failed");
        }

        @Test
        @DisplayName("should compensate in reverse order")
        void shouldCompensateInReverseOrder() throws Exception {
            final AtomicInteger compensationOrder = new AtomicInteger(0);
            final int[] order = new int[2];

            final SagaDefinition def = SagaDefinition.builder()
                    .name("ReverseCompSaga")
                    .step("Step1").action(successAction())
                        .compensation(ctx -> {
                            order[compensationOrder.getAndIncrement()] = 1;
                            return CompletableFuture.completedFuture(SagaStepResult.success());
                        }).timeout(Duration.ofSeconds(5)).build()
                    .step("Step2").action(successAction())
                        .compensation(ctx -> {
                            order[compensationOrder.getAndIncrement()] = 2;
                            return CompletableFuture.completedFuture(SagaStepResult.success());
                        }).timeout(Duration.ofSeconds(5)).build()
                    .step("Step3").action(failAction("fail")).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            orchestrator.start("saga-reverse", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            // Step2 compensation should run before Step1
            assertThat(order[0]).isEqualTo(2);
            assertThat(order[1]).isEqualTo(1);
        }

        @Test
        @DisplayName("should skip steps without compensation")
        void shouldSkipStepsWithoutCompensation() throws Exception {
            final AtomicInteger compensationCount = new AtomicInteger(0);

            final SagaDefinition def = SagaDefinition.builder()
                    .name("SkipCompSaga")
                    .step("Step1").action(successAction())
                        .compensation(ctx -> {
                            compensationCount.incrementAndGet();
                            return CompletableFuture.completedFuture(SagaStepResult.success());
                        }).timeout(Duration.ofSeconds(5)).build()
                    .step("Step2").action(successAction()).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .step("Step3").action(failAction("fail")).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            orchestrator.start("saga-skip", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            // Only Step1 has compensation, Step2 has none (should be skipped)
            assertThat(compensationCount.get()).isEqualTo(1);
        }

        @Test
        @DisplayName("should return COMPENSATED result")
        void shouldReturnCompensatedResult() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("CompSaga")
                    .step("Step1").action(successAction()).compensation(successCompensation())
                        .timeout(Duration.ofSeconds(5)).build()
                    .step("Step2").action(failAction("boom")).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            final SagaOrchestratorResult result = orchestrator.start("saga-comp", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            assertThat(result.getStatus()).isEqualTo(SagaStatus.COMPENSATED);
            assertThat(result.isCompensated()).isTrue();
        }

        @Test
        @DisplayName("should record failure reason")
        void shouldRecordFailureReason() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("ReasonSaga")
                    .step("Step1").action(failAction("Insufficient funds")).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            final SagaOrchestratorResult result = orchestrator.start("saga-reason", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            assertThat(result.getFailureReason()).contains("Insufficient funds");
            verify(stateStore).recordStepFailed("saga-reason", 0, "Step1", "orchestrator",
                    "Insufficient funds");
        }
    }

    @Nested
    @DisplayName("Timeout Path")
    class TimeoutPath {

        @Test
        @DisplayName("should timeout slow step and trigger compensation")
        void shouldTimeoutSlowStep() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("TimeoutSaga")
                    .step("Step1").action(successAction()).compensation(successCompensation())
                        .timeout(Duration.ofSeconds(5)).build()
                    .step("SlowStep").action(hangingAction()).compensation(successCompensation())
                        .timeout(Duration.ofMillis(100)).build()
                    .sagaTimeout(Duration.ofSeconds(10))
                    .build();

            final SagaOrchestratorResult result = orchestrator.start("saga-timeout", def, SagaContext.create())
                    .get(10, TimeUnit.SECONDS);

            assertThat(result.isTimedOut()).isTrue();
            assertThat(result.getStepsCompleted()).isEqualTo(1);
        }

        @Test
        @DisplayName("should return TIMED_OUT result for step timeout")
        void shouldReturnTimedOutResult() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("TimeoutResultSaga")
                    .step("SlowStep").action(hangingAction()).noCompensation()
                        .timeout(Duration.ofMillis(100)).build()
                    .sagaTimeout(Duration.ofSeconds(10))
                    .build();

            final SagaOrchestratorResult result = orchestrator.start(
                    "saga-timeout-result", def, SagaContext.create())
                    .get(10, TimeUnit.SECONDS);

            assertThat(result.getStatus()).isEqualTo(SagaStatus.TIMED_OUT);
            assertThat(result.isTimedOut()).isTrue();
        }

        @Test
        @DisplayName("should handle saga-level timeout")
        void shouldHandleSagaLevelTimeout() throws Exception {
            // Each step is fast but the saga has a very short overall timeout
            // Use a step that takes longer than the saga timeout
            final SagaDefinition def = SagaDefinition.builder()
                    .name("SagaTimeoutSaga")
                    .step("Step1").action(successAction()).compensation(successCompensation())
                        .timeout(Duration.ofSeconds(5)).build()
                    .step("SlowStep").action(hangingAction()).noCompensation()
                        .timeout(Duration.ofSeconds(30)).build()
                    .sagaTimeout(Duration.ofMillis(200))
                    .build();

            final SagaOrchestratorResult result = orchestrator.start(
                    "saga-saga-timeout", def, SagaContext.create())
                    .get(10, TimeUnit.SECONDS);

            // The saga-level timeout should fire before the step timeout
            assertThat(result.getStatus()).satisfiesAnyOf(
                    s -> assertThat(s).isEqualTo(SagaStatus.TIMED_OUT),
                    s -> assertThat(s).isEqualTo(SagaStatus.COMPENSATED)
            );
        }
    }

    @Nested
    @DisplayName("Retry Logic")
    class RetryLogic {

        @Test
        @DisplayName("should retry on failure up to maxRetries")
        void shouldRetryOnFailure() throws Exception {
            final AtomicInteger attempts = new AtomicInteger(0);

            final SagaDefinition def = SagaDefinition.builder()
                    .name("RetrySaga")
                    .step("RetryStep")
                        .action(ctx -> {
                            attempts.incrementAndGet();
                            return CompletableFuture.completedFuture(SagaStepResult.failure("fail"));
                        })
                        .noCompensation()
                        .timeout(Duration.ofSeconds(5))
                        .maxRetries(2)
                        .retryDelay(Duration.ofMillis(10))
                        .build()
                    .build();

            orchestrator.start("saga-retry", def, SagaContext.create())
                    .get(10, TimeUnit.SECONDS);

            // 1 initial + 2 retries = 3 total attempts
            assertThat(attempts.get()).isEqualTo(3);
        }

        @Test
        @DisplayName("should succeed on retry after transient failure")
        void shouldSucceedOnRetry() throws Exception {
            final AtomicInteger attempts = new AtomicInteger(0);

            final SagaDefinition def = SagaDefinition.builder()
                    .name("TransientRetrySaga")
                    .step("TransientStep")
                        .action(ctx -> {
                            if (attempts.incrementAndGet() < 3) {
                                return CompletableFuture.completedFuture(
                                        SagaStepResult.failure("transient"));
                            }
                            return CompletableFuture.completedFuture(SagaStepResult.success());
                        })
                        .noCompensation()
                        .timeout(Duration.ofSeconds(5))
                        .maxRetries(3)
                        .retryDelay(Duration.ofMillis(10))
                        .build()
                    .build();

            final SagaOrchestratorResult result = orchestrator.start(
                    "saga-transient", def, SagaContext.create())
                    .get(10, TimeUnit.SECONDS);

            assertThat(result.isSuccessful()).isTrue();
            assertThat(attempts.get()).isEqualTo(3);
        }

        @Test
        @DisplayName("should enter compensation after exhausting retries")
        void shouldCompensateAfterExhaustingRetries() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("ExhaustedRetrySaga")
                    .step("Step1").action(successAction()).compensation(successCompensation())
                        .timeout(Duration.ofSeconds(5)).build()
                    .step("FailStep")
                        .action(failAction("persistent failure"))
                        .noCompensation()
                        .timeout(Duration.ofSeconds(5))
                        .maxRetries(1)
                        .retryDelay(Duration.ofMillis(10))
                        .build()
                    .build();

            final SagaOrchestratorResult result = orchestrator.start(
                    "saga-exhausted", def, SagaContext.create())
                    .get(10, TimeUnit.SECONDS);

            assertThat(result.isCompensated()).isTrue();
            assertThat(result.getFailedAtStep()).contains("FailStep");
        }
    }

    @Nested
    @DisplayName("Compensation Failure")
    class CompensationFailure {

        @Test
        @DisplayName("should return FAILED when compensation step fails")
        void shouldReturnFailedWhenCompensationFails() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("CompFailSaga")
                    .step("Step1").action(successAction())
                        .compensation(failCompensation("comp failed"))
                        .timeout(Duration.ofSeconds(5)).build()
                    .step("Step2").action(failAction("step2 failed")).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            final SagaOrchestratorResult result = orchestrator.start(
                    "saga-comp-fail", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            assertThat(result.isFailed()).isTrue();
            assertThat(result.getStatus()).isEqualTo(SagaStatus.FAILED);
            verify(stateStore).completeSaga("saga-comp-fail", SagaStatus.FAILED);
        }

        @Test
        @DisplayName("should continue compensating remaining steps even after one fails")
        void shouldContinueCompensatingAfterFailure() throws Exception {
            final AtomicInteger compensationCount = new AtomicInteger(0);

            final SagaDefinition def = SagaDefinition.builder()
                    .name("ContinueCompSaga")
                    .step("Step1").action(successAction())
                        .compensation(ctx -> {
                            compensationCount.incrementAndGet();
                            return CompletableFuture.completedFuture(SagaStepResult.success());
                        }).timeout(Duration.ofSeconds(5)).build()
                    .step("Step2").action(successAction())
                        .compensation(failCompensation("comp2 failed"))
                        .timeout(Duration.ofSeconds(5)).build()
                    .step("Step3").action(failAction("step3 failed")).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            orchestrator.start("saga-continue-comp", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            // Step2's compensation fails, but Step1's compensation should still run
            assertThat(compensationCount.get()).isEqualTo(1);
        }
    }

    @Nested
    @DisplayName("handleStepResult (External Completion)")
    class HandleStepResult {

        @Test
        @DisplayName("should complete pending step with external result")
        void shouldCompletePendingStep() throws Exception {
            final CompletableFuture<SagaStepResult> pendingFuture = new CompletableFuture<>();

            final SagaDefinition def = SagaDefinition.builder()
                    .name("ExternalSaga")
                    .step("ExternalStep")
                        .action(ctx -> pendingFuture)
                        .noCompensation()
                        .timeout(Duration.ofSeconds(10))
                        .build()
                    .build();

            final CompletableFuture<SagaOrchestratorResult> resultFuture =
                    orchestrator.start("saga-external", def, SagaContext.create());

            // Wait briefly for the step to start
            Thread.sleep(100);

            // Complete externally
            orchestrator.handleStepResult("saga-external", "ExternalStep", SagaStepResult.success());

            final SagaOrchestratorResult result = resultFuture.get(5, TimeUnit.SECONDS);
            assertThat(result.isSuccessful()).isTrue();
        }

        @Test
        @DisplayName("should reject unknown sagaId")
        void shouldRejectUnknownSagaId() {
            assertThatThrownBy(() -> orchestrator.handleStepResult(
                    "unknown-saga", "Step1", SagaStepResult.success()))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("not found");
        }

        @Test
        @DisplayName("should reject wrong stepName")
        void shouldRejectWrongStepName() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("WrongStepSaga")
                    .step("Step1")
                        .action(hangingAction())
                        .noCompensation()
                        .timeout(Duration.ofSeconds(30))
                        .build()
                    .build();

            orchestrator.start("saga-wrong-step", def, SagaContext.create());
            Thread.sleep(100);

            assertThatThrownBy(() -> orchestrator.handleStepResult(
                    "saga-wrong-step", "WrongName", SagaStepResult.success()))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("mismatch");
        }
    }

    @Nested
    @DisplayName("cancel()")
    class Cancel {

        @Test
        @DisplayName("should trigger compensation on cancel")
        void shouldTriggerCompensationOnCancel() throws Exception {
            final AtomicInteger compensated = new AtomicInteger(0);

            final SagaDefinition def = SagaDefinition.builder()
                    .name("CancelSaga")
                    .step("Step1").action(successAction())
                        .compensation(ctx -> {
                            compensated.incrementAndGet();
                            return CompletableFuture.completedFuture(SagaStepResult.success());
                        }).timeout(Duration.ofSeconds(5)).build()
                    .step("SlowStep").action(hangingAction()).noCompensation()
                        .timeout(Duration.ofSeconds(30)).build()
                    .build();

            orchestrator.start("saga-cancel", def, SagaContext.create());
            Thread.sleep(200); // Wait for Step1 to complete

            final SagaOrchestratorResult result = orchestrator.cancel("saga-cancel", "User cancelled")
                    .get(5, TimeUnit.SECONDS);

            assertThat(result.isCompensated()).isTrue();
            assertThat(compensated.get()).isEqualTo(1);
        }

        @Test
        @DisplayName("should reject cancel for unknown saga")
        void shouldRejectCancelForUnknownSaga() {
            assertThatThrownBy(() -> orchestrator.cancel("nonexistent", "reason"))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("not found");
        }

        @Test
        @DisplayName("should reject cancel for already-completed saga")
        void shouldRejectCancelForCompletedSaga() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("CompletedCancelSaga")
                    .step("Step1").action(successAction()).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            orchestrator.start("saga-done", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            // Small delay to let cleanup happen
            Thread.sleep(100);

            assertThatThrownBy(() -> orchestrator.cancel("saga-done", "too late"))
                    .isInstanceOf(IllegalArgumentException.class);
        }
    }

    @Nested
    @DisplayName("getStatus()")
    class GetStatus {

        @Test
        @DisplayName("should return status for active saga")
        void shouldReturnStatusForActiveSaga() {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("ActiveStatusSaga")
                    .step("SlowStep").action(hangingAction()).noCompensation()
                        .timeout(Duration.ofSeconds(30)).build()
                    .build();

            orchestrator.start("saga-active", def, SagaContext.create());

            final Optional<SagaOrchestratorResult> status = orchestrator.getStatus("saga-active");
            assertThat(status).isPresent();
            assertThat(status.get().getSagaId()).isEqualTo("saga-active");
            assertThat(status.get().getSagaName()).isEqualTo("ActiveStatusSaga");
            assertThat(status.get().getStatus()).isEqualTo(SagaStatus.IN_PROGRESS);
        }

        @Test
        @DisplayName("should return empty for unknown saga")
        void shouldReturnEmptyForUnknownSaga() {
            final Optional<SagaOrchestratorResult> status = orchestrator.getStatus("nonexistent");
            assertThat(status).isEmpty();
        }
    }

    @Nested
    @DisplayName("Listener Notifications")
    class ListenerNotifications {

        private SagaOrchestratorListener listener;
        private HazelcastSagaOrchestrator orchestratorWithListener;

        @BeforeEach
        void setUpListener() {
            listener = mock(SagaOrchestratorListener.class);
            orchestratorWithListener = new HazelcastSagaOrchestrator(
                    stateStore, List.of(listener), scheduler);
        }

        @Test
        @DisplayName("should notify onSagaStarted")
        void shouldNotifyOnSagaStarted() throws Exception {
            orchestratorWithListener.start("saga-listen-1", threeStepSaga(), SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            verify(listener).onSagaStarted(eq("saga-listen-1"), any(SagaDefinition.class),
                    any(SagaContext.class));
        }

        @Test
        @DisplayName("should notify onStepStarted and onStepCompleted for each step")
        void shouldNotifyStepEvents() throws Exception {
            orchestratorWithListener.start("saga-listen-2", threeStepSaga(), SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            verify(listener).onStepStarted("saga-listen-2", "Step1", 0);
            verify(listener).onStepStarted("saga-listen-2", "Step2", 1);
            verify(listener).onStepStarted("saga-listen-2", "Step3", 2);

            verify(listener, times(3)).onStepCompleted(eq("saga-listen-2"), anyString(),
                    any(SagaStepResult.class));
        }

        @Test
        @DisplayName("should notify onCompensationStarted and onCompensationStepCompleted")
        void shouldNotifyCompensationEvents() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("CompListenSaga")
                    .step("Step1").action(successAction()).compensation(successCompensation())
                        .timeout(Duration.ofSeconds(5)).build()
                    .step("Step2").action(failAction("fail")).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            orchestratorWithListener.start("saga-listen-3", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            verify(listener).onCompensationStarted(eq("saga-listen-3"), eq("Step2"), anyInt());
            verify(listener, atLeastOnce()).onCompensationStepCompleted(eq("saga-listen-3"),
                    eq("Step1"), any(SagaStepResult.class));
        }

        @Test
        @DisplayName("should notify onSagaCompleted")
        void shouldNotifyOnSagaCompleted() throws Exception {
            orchestratorWithListener.start("saga-listen-4", threeStepSaga(), SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            verify(listener).onSagaCompleted(eq("saga-listen-4"), any(SagaOrchestratorResult.class));
        }

        @Test
        @DisplayName("should notify onSagaCompleted on compensation")
        void shouldNotifyOnSagaCompletedOnCompensation() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("CompCompleteSaga")
                    .step("Step1").action(failAction("fail")).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            orchestratorWithListener.start("saga-listen-5", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            verify(listener).onSagaCompleted(eq("saga-listen-5"), any(SagaOrchestratorResult.class));
        }

        @Test
        @DisplayName("should not fail when listener throws exception")
        @SuppressWarnings("unused")
        void shouldNotFailWhenListenerThrows() throws Exception {
            final SagaOrchestratorListener throwingListener = new SagaOrchestratorListener() {
                @Override
                public void onSagaStarted(final String sagaId, final SagaDefinition definition,
                                           final SagaContext context) {
                    throw new RuntimeException("Listener error");
                }
            };

            final HazelcastSagaOrchestrator orchWithBadListener = new HazelcastSagaOrchestrator(
                    stateStore, List.of(throwingListener), scheduler);

            final SagaOrchestratorResult result = orchWithBadListener.start(
                    "saga-bad-listener", threeStepSaga(), SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            // Saga should still complete despite listener error
            assertThat(result.isSuccessful()).isTrue();
        }
    }

    @Nested
    @DisplayName("Step Duration Metrics")
    class StepDurationMetrics {

        private SimpleMeterRegistry meterRegistry;
        private SagaMetrics sagaMetrics;
        private HazelcastSagaOrchestrator metricsOrchestrator;

        @BeforeEach
        void setUpMetrics() {
            meterRegistry = new SimpleMeterRegistry();
            sagaMetrics = new SagaMetrics(meterRegistry);
            metricsOrchestrator = new HazelcastSagaOrchestrator(
                    stateStore, Collections.emptyList(), scheduler, sagaMetrics);
        }

        @Test
        @DisplayName("should record step duration for successful steps")
        void shouldRecordStepDurationForSuccessfulSteps() throws Exception {
            metricsOrchestrator.start("saga-metrics-1", threeStepSaga(), SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            Timer step1Timer = meterRegistry.find("saga.step.duration")
                    .tag("sagaType", "TestSaga")
                    .tag("stepName", "Step1")
                    .timer();
            Timer step2Timer = meterRegistry.find("saga.step.duration")
                    .tag("sagaType", "TestSaga")
                    .tag("stepName", "Step2")
                    .timer();
            Timer step3Timer = meterRegistry.find("saga.step.duration")
                    .tag("sagaType", "TestSaga")
                    .tag("stepName", "Step3")
                    .timer();

            assertThat(step1Timer).isNotNull();
            assertThat(step1Timer.count()).isEqualTo(1);
            assertThat(step2Timer).isNotNull();
            assertThat(step2Timer.count()).isEqualTo(1);
            assertThat(step3Timer).isNotNull();
            assertThat(step3Timer.count()).isEqualTo(1);
        }

        @Test
        @DisplayName("should record step duration for failed step")
        void shouldRecordStepDurationForFailedStep() throws Exception {
            final SagaDefinition def = SagaDefinition.builder()
                    .name("FailMetricsSaga")
                    .step("Step1").action(failAction("boom")).noCompensation()
                        .timeout(Duration.ofSeconds(5)).build()
                    .build();

            metricsOrchestrator.start("saga-metrics-fail", def, SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            Timer failedTimer = meterRegistry.find("saga.step.duration")
                    .tag("sagaType", "FailMetricsSaga")
                    .tag("stepName", "Step1")
                    .timer();

            assertThat(failedTimer).isNotNull();
            assertThat(failedTimer.count()).isEqualTo(1);
        }

        @Test
        @DisplayName("should work without metrics (null sagaMetrics)")
        void shouldWorkWithoutMetrics() throws Exception {
            // Use the 3-arg constructor (no metrics)
            final SagaOrchestratorResult result = orchestrator.start(
                    "saga-no-metrics", threeStepSaga(), SagaContext.create())
                    .get(5, TimeUnit.SECONDS);

            assertThat(result.isSuccessful()).isTrue();
        }
    }
}
