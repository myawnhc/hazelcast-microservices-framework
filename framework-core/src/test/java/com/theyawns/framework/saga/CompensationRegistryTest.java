package com.theyawns.framework.saga;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.util.Optional;
import java.util.Set;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.*;

/**
 * Unit tests for CompensationRegistry.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("CompensationRegistry - Compensation mapping management")
class CompensationRegistryTest {

    private CompensationRegistry registry;

    @BeforeEach
    void setUp() {
        registry = new CompensationRegistry();
    }

    @Nested
    @DisplayName("Registration")
    class Registration {

        @Test
        @DisplayName("register should store compensation mapping")
        void registerShouldStoreMapping() {
            registry.register("StockReserved", "StockReleased", "inventory-service");

            assertTrue(registry.hasCompensation("StockReserved"));
            assertEquals(1, registry.size());
        }

        @Test
        @DisplayName("register should allow multiple mappings")
        void registerShouldAllowMultipleMappings() {
            registry.register("OrderCreated", "OrderCancelled", "order-service");
            registry.register("StockReserved", "StockReleased", "inventory-service");
            registry.register("PaymentProcessed", "PaymentRefunded", "payment-service");

            assertEquals(3, registry.size());
            assertTrue(registry.hasCompensation("OrderCreated"));
            assertTrue(registry.hasCompensation("StockReserved"));
            assertTrue(registry.hasCompensation("PaymentProcessed"));
        }

        @Test
        @DisplayName("register should overwrite existing mapping")
        void registerShouldOverwriteExisting() {
            registry.register("StockReserved", "StockReleased", "inventory-service");
            registry.register("StockReserved", "StockReleasedV2", "inventory-service-v2");

            Optional<CompensationRegistry.CompensationMapping> mapping =
                    registry.getCompensation("StockReserved");

            assertTrue(mapping.isPresent());
            assertEquals("StockReleasedV2", mapping.get().compensatingEventType());
            assertEquals("inventory-service-v2", mapping.get().service());
        }

        @Test
        @DisplayName("register with step number should store step")
        void registerWithStepNumberShouldStoreStep() {
            registry.register("StockReserved", "StockReleased", "inventory-service", 1);

            Optional<Integer> stepNumber = registry.getStepNumber("StockReserved");
            assertTrue(stepNumber.isPresent());
            assertEquals(1, stepNumber.get());
        }

        @Test
        @DisplayName("register should reject null eventType")
        void registerShouldRejectNullEventType() {
            assertThrows(NullPointerException.class, () ->
                    registry.register(null, "StockReleased", "inventory-service"));
        }

        @Test
        @DisplayName("register should reject null compensatingEventType")
        void registerShouldRejectNullCompensatingEventType() {
            assertThrows(NullPointerException.class, () ->
                    registry.register("StockReserved", null, "inventory-service"));
        }

        @Test
        @DisplayName("register should reject null service")
        void registerShouldRejectNullService() {
            assertThrows(NullPointerException.class, () ->
                    registry.register("StockReserved", "StockReleased", null));
        }

        @Test
        @DisplayName("register should reject blank eventType")
        void registerShouldRejectBlankEventType() {
            assertThrows(IllegalArgumentException.class, () ->
                    registry.register("   ", "StockReleased", "inventory-service"));
        }

        @Test
        @DisplayName("register should reject blank compensatingEventType")
        void registerShouldRejectBlankCompensatingEventType() {
            assertThrows(IllegalArgumentException.class, () ->
                    registry.register("StockReserved", "   ", "inventory-service"));
        }

        @Test
        @DisplayName("register should reject blank service")
        void registerShouldRejectBlankService() {
            assertThrows(IllegalArgumentException.class, () ->
                    registry.register("StockReserved", "StockReleased", ""));
        }
    }

    @Nested
    @DisplayName("Lookup")
    class Lookup {

        @BeforeEach
        void setUpMappings() {
            registry.register("OrderCreated", "OrderCancelled", "order-service", 0);
            registry.register("StockReserved", "StockReleased", "inventory-service", 1);
            registry.register("PaymentProcessed", "PaymentRefunded", "payment-service", 2);
        }

        @Test
        @DisplayName("getCompensation should return mapping for registered event")
        void getCompensationShouldReturnMappingForRegisteredEvent() {
            Optional<CompensationRegistry.CompensationMapping> mapping =
                    registry.getCompensation("StockReserved");

            assertTrue(mapping.isPresent());
            assertEquals("StockReleased", mapping.get().compensatingEventType());
            assertEquals("inventory-service", mapping.get().service());
        }

        @Test
        @DisplayName("getCompensation should return empty for unregistered event")
        void getCompensationShouldReturnEmptyForUnregisteredEvent() {
            Optional<CompensationRegistry.CompensationMapping> mapping =
                    registry.getCompensation("NonExistentEvent");

            assertTrue(mapping.isEmpty());
        }

        @Test
        @DisplayName("getCompensation should return empty for null event")
        void getCompensationShouldReturnEmptyForNullEvent() {
            Optional<CompensationRegistry.CompensationMapping> mapping =
                    registry.getCompensation(null);

            assertTrue(mapping.isEmpty());
        }

        @Test
        @DisplayName("getCompensatingEventType should return event type")
        void getCompensatingEventTypeShouldReturnEventType() {
            Optional<String> eventType = registry.getCompensatingEventType("PaymentProcessed");

            assertTrue(eventType.isPresent());
            assertEquals("PaymentRefunded", eventType.get());
        }

        @Test
        @DisplayName("getCompensatingService should return service name")
        void getCompensatingServiceShouldReturnServiceName() {
            Optional<String> service = registry.getCompensatingService("OrderCreated");

            assertTrue(service.isPresent());
            assertEquals("order-service", service.get());
        }

        @Test
        @DisplayName("hasCompensation should return true for registered event")
        void hasCompensationShouldReturnTrueForRegisteredEvent() {
            assertTrue(registry.hasCompensation("StockReserved"));
        }

        @Test
        @DisplayName("hasCompensation should return false for unregistered event")
        void hasCompensationShouldReturnFalseForUnregisteredEvent() {
            assertFalse(registry.hasCompensation("NonExistentEvent"));
        }

        @Test
        @DisplayName("hasCompensation should return false for null")
        void hasCompensationShouldReturnFalseForNull() {
            assertFalse(registry.hasCompensation(null));
        }

        @Test
        @DisplayName("getRegisteredEventTypes should return all registered types")
        void getRegisteredEventTypesShouldReturnAllRegisteredTypes() {
            Set<String> eventTypes = registry.getRegisteredEventTypes();

            assertEquals(3, eventTypes.size());
            assertTrue(eventTypes.contains("OrderCreated"));
            assertTrue(eventTypes.contains("StockReserved"));
            assertTrue(eventTypes.contains("PaymentProcessed"));
        }

        @Test
        @DisplayName("getRegisteredEventTypes should return unmodifiable set")
        void getRegisteredEventTypesShouldReturnUnmodifiableSet() {
            Set<String> eventTypes = registry.getRegisteredEventTypes();

            assertThrows(UnsupportedOperationException.class, () ->
                    eventTypes.add("NewEvent"));
        }
    }

    @Nested
    @DisplayName("Unregistration")
    class Unregistration {

        @BeforeEach
        void setUpMappings() {
            registry.register("StockReserved", "StockReleased", "inventory-service", 1);
        }

        @Test
        @DisplayName("unregister should remove mapping")
        void unregisterShouldRemoveMapping() {
            boolean removed = registry.unregister("StockReserved");

            assertTrue(removed);
            assertFalse(registry.hasCompensation("StockReserved"));
            assertEquals(0, registry.size());
        }

        @Test
        @DisplayName("unregister should return false for non-existent mapping")
        void unregisterShouldReturnFalseForNonExistent() {
            boolean removed = registry.unregister("NonExistentEvent");

            assertFalse(removed);
        }

        @Test
        @DisplayName("unregister should also remove step number")
        void unregisterShouldAlsoRemoveStepNumber() {
            registry.unregister("StockReserved");

            assertTrue(registry.getStepNumber("StockReserved").isEmpty());
        }

        @Test
        @DisplayName("clear should remove all mappings")
        void clearShouldRemoveAllMappings() {
            registry.register("OrderCreated", "OrderCancelled", "order-service");
            registry.register("PaymentProcessed", "PaymentRefunded", "payment-service");

            registry.clear();

            assertTrue(registry.isEmpty());
            assertEquals(0, registry.size());
        }
    }

    @Nested
    @DisplayName("State queries")
    class StateQueries {

        @Test
        @DisplayName("isEmpty should return true for new registry")
        void isEmptyShouldReturnTrueForNewRegistry() {
            assertTrue(registry.isEmpty());
        }

        @Test
        @DisplayName("isEmpty should return false after registration")
        void isEmptyShouldReturnFalseAfterRegistration() {
            registry.register("StockReserved", "StockReleased", "inventory-service");

            assertFalse(registry.isEmpty());
        }

        @Test
        @DisplayName("size should return number of mappings")
        void sizeShouldReturnNumberOfMappings() {
            assertEquals(0, registry.size());

            registry.register("StockReserved", "StockReleased", "inventory-service");
            assertEquals(1, registry.size());

            registry.register("OrderCreated", "OrderCancelled", "order-service");
            assertEquals(2, registry.size());
        }
    }

    @Nested
    @DisplayName("Thread safety")
    class ThreadSafety {

        @Test
        @DisplayName("concurrent registrations should not lose data")
        void concurrentRegistrationsShouldNotLoseData() throws InterruptedException {
            int threadCount = 10;
            int registrationsPerThread = 100;
            ExecutorService executor = Executors.newFixedThreadPool(threadCount);
            CountDownLatch latch = new CountDownLatch(threadCount);

            for (int t = 0; t < threadCount; t++) {
                final int threadNum = t;
                executor.submit(() -> {
                    try {
                        for (int i = 0; i < registrationsPerThread; i++) {
                            String eventType = "Event-" + threadNum + "-" + i;
                            registry.register(eventType, "Compensate-" + eventType, "service-" + threadNum);
                        }
                    } finally {
                        latch.countDown();
                    }
                });
            }

            assertTrue(latch.await(10, TimeUnit.SECONDS));
            executor.shutdown();

            assertEquals(threadCount * registrationsPerThread, registry.size());
        }

        @Test
        @DisplayName("concurrent reads and writes should not throw exceptions")
        void concurrentReadsAndWritesShouldNotThrow() throws InterruptedException {
            registry.register("InitialEvent", "InitialCompensation", "initial-service");

            int threadCount = 10;
            ExecutorService executor = Executors.newFixedThreadPool(threadCount);
            CountDownLatch latch = new CountDownLatch(threadCount);

            for (int t = 0; t < threadCount; t++) {
                final int threadNum = t;
                executor.submit(() -> {
                    try {
                        for (int i = 0; i < 100; i++) {
                            // Mix of reads and writes
                            if (i % 2 == 0) {
                                registry.register("Event-" + threadNum + "-" + i,
                                        "Comp-" + i, "service-" + threadNum);
                            } else {
                                registry.getCompensation("InitialEvent");
                                registry.hasCompensation("Event-" + threadNum + "-" + (i - 1));
                            }
                        }
                    } finally {
                        latch.countDown();
                    }
                });
            }

            assertTrue(latch.await(10, TimeUnit.SECONDS));
            executor.shutdown();

            // Should complete without exceptions
            assertTrue(registry.hasCompensation("InitialEvent"));
        }
    }

    @Nested
    @DisplayName("CompensationMapping record")
    class CompensationMappingTest {

        @Test
        @DisplayName("CompensationMapping should store values correctly")
        void compensationMappingShouldStoreValues() {
            CompensationRegistry.CompensationMapping mapping =
                    new CompensationRegistry.CompensationMapping("StockReleased", "inventory-service");

            assertEquals("StockReleased", mapping.compensatingEventType());
            assertEquals("inventory-service", mapping.service());
        }

        @Test
        @DisplayName("CompensationMapping should have meaningful toString")
        void compensationMappingShouldHaveMeaningfulToString() {
            CompensationRegistry.CompensationMapping mapping =
                    new CompensationRegistry.CompensationMapping("StockReleased", "inventory-service");

            String str = mapping.toString();
            assertTrue(str.contains("StockReleased"));
            assertTrue(str.contains("inventory-service"));
        }

        @Test
        @DisplayName("CompensationMapping should reject null compensatingEventType")
        void compensationMappingShouldRejectNullCompensatingEventType() {
            assertThrows(NullPointerException.class, () ->
                    new CompensationRegistry.CompensationMapping(null, "inventory-service"));
        }

        @Test
        @DisplayName("CompensationMapping should reject null service")
        void compensationMappingShouldRejectNullService() {
            assertThrows(NullPointerException.class, () ->
                    new CompensationRegistry.CompensationMapping("StockReleased", null));
        }

        @Test
        @DisplayName("CompensationMapping equals should work correctly")
        void compensationMappingEqualsShouldWork() {
            CompensationRegistry.CompensationMapping mapping1 =
                    new CompensationRegistry.CompensationMapping("StockReleased", "inventory-service");
            CompensationRegistry.CompensationMapping mapping2 =
                    new CompensationRegistry.CompensationMapping("StockReleased", "inventory-service");
            CompensationRegistry.CompensationMapping mapping3 =
                    new CompensationRegistry.CompensationMapping("StockReleased", "other-service");

            assertEquals(mapping1, mapping2);
            assertNotEquals(mapping1, mapping3);
        }
    }
}
