package com.theyawns.framework.saga;

import com.hazelcast.core.HazelcastInstance;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.test.context.runner.ApplicationContextRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;

/**
 * Tests for {@link SagaTimeoutAutoConfiguration}.
 *
 * <p>Validates that the auto-configuration:
 * <ul>
 *   <li>Creates beans when all required dependencies are present</li>
 *   <li>Respects the {@code saga.timeout.enabled} property</li>
 *   <li>Binds configuration properties correctly</li>
 *   <li>Skips bean creation when dependencies are missing</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("SagaTimeoutAutoConfiguration - Auto-configuration behavior")
class SagaTimeoutAutoConfigurationTest {

    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(SagaTimeoutAutoConfiguration.class));

    @Nested
    @DisplayName("With all dependencies present")
    class WithAllDependencies {

        @Test
        @DisplayName("should create SagaTimeoutDetector bean when enabled")
        void shouldCreateDetectorBeanWhenEnabled() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class)
                    .withPropertyValues("saga.timeout.enabled=true")
                    .run(context -> {
                        assertThat(context).hasSingleBean(SagaTimeoutDetector.class);
                        assertThat(context).hasSingleBean(SagaCompensator.class);
                    });
        }

        @Test
        @DisplayName("should create SagaTimeoutDetector bean by default (enabled is true by default)")
        void shouldCreateDetectorBeanByDefault() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(SagaTimeoutDetector.class);
                    });
        }

        @Test
        @DisplayName("should not create SagaTimeoutDetector when disabled")
        void shouldNotCreateDetectorWhenDisabled() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class)
                    .withPropertyValues("saga.timeout.enabled=false")
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(SagaTimeoutDetector.class);
                        // Compensator should still be available
                        assertThat(context).hasSingleBean(SagaCompensator.class);
                    });
        }

        @Test
        @DisplayName("should bind configuration properties")
        void shouldBindConfigurationProperties() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class)
                    .withPropertyValues(
                            "saga.timeout.enabled=true",
                            "saga.timeout.check-interval=10000",
                            "saga.timeout.default-deadline=45000",
                            "saga.timeout.auto-compensate=false",
                            "saga.timeout.max-batch-size=50"
                    )
                    .run(context -> {
                        assertThat(context).hasSingleBean(SagaTimeoutConfig.class);
                        SagaTimeoutConfig config = context.getBean(SagaTimeoutConfig.class);
                        assertThat(config.isEnabled()).isTrue();
                        assertThat(config.getCheckInterval().toMillis()).isEqualTo(10000);
                        assertThat(config.getDefaultDeadline().toMillis()).isEqualTo(45000);
                        assertThat(config.isAutoCompensate()).isFalse();
                        assertThat(config.getMaxBatchSize()).isEqualTo(50);
                    });
        }
    }

    @Nested
    @DisplayName("Without required dependencies")
    class WithoutRequiredDependencies {

        @Test
        @DisplayName("should not create beans when HazelcastInstance is missing")
        void shouldNotCreateBeansWhenHazelcastMissing() {
            contextRunner
                    .withUserConfiguration(NoHazelcastConfig.class)
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(SagaTimeoutDetector.class);
                        assertThat(context).doesNotHaveBean(SagaCompensator.class);
                    });
        }

        @Test
        @DisplayName("should not create beans when SagaStateStore is missing")
        void shouldNotCreateBeansWhenSagaStateStoreMissing() {
            contextRunner
                    .withUserConfiguration(NoSagaStateStoreConfig.class)
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(SagaTimeoutDetector.class);
                    });
        }
    }

    @Nested
    @DisplayName("Custom bean override")
    class CustomBeanOverride {

        @Test
        @DisplayName("should not override existing SagaCompensator bean")
        void shouldNotOverrideExistingCompensator() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class, CustomCompensatorConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(SagaCompensator.class);
                        assertThat(context.getBean(SagaCompensator.class))
                                .isInstanceOf(CustomCompensator.class);
                    });
        }
    }

    // ========== Test Configuration Classes ==========

    @Configuration
    static class FullDependenciesConfig {

        @Bean
        HazelcastInstance hazelcastInstance() {
            return mock(HazelcastInstance.class, invocation -> {
                if (invocation.getMethod().getName().equals("getTopic")) {
                    return mock(com.hazelcast.topic.ITopic.class);
                }
                if (invocation.getMethod().getName().equals("getMap")) {
                    return mock(com.hazelcast.map.IMap.class);
                }
                if (invocation.getMethod().getName().equals("getCPSubsystem")) {
                    throw new IllegalStateException("CP Subsystem not available");
                }
                return null;
            });
        }

        @Bean
        SagaStateStore sagaStateStore() {
            return mock(SagaStateStore.class);
        }

        @Bean
        CompensationRegistry compensationRegistry() {
            return new CompensationRegistry();
        }

        @Bean
        MeterRegistry meterRegistry() {
            return new SimpleMeterRegistry();
        }
    }

    @Configuration
    static class NoHazelcastConfig {

        @Bean
        SagaStateStore sagaStateStore() {
            return mock(SagaStateStore.class);
        }

        @Bean
        CompensationRegistry compensationRegistry() {
            return new CompensationRegistry();
        }

        @Bean
        MeterRegistry meterRegistry() {
            return new SimpleMeterRegistry();
        }
    }

    @Configuration
    static class NoSagaStateStoreConfig {

        @Bean
        HazelcastInstance hazelcastInstance() {
            return mock(HazelcastInstance.class);
        }

        @Bean
        CompensationRegistry compensationRegistry() {
            return new CompensationRegistry();
        }

        @Bean
        MeterRegistry meterRegistry() {
            return new SimpleMeterRegistry();
        }
    }

    @Configuration
    static class CustomCompensatorConfig {

        @Bean
        SagaCompensator sagaCompensator() {
            return new CustomCompensator();
        }
    }

    static class CustomCompensator implements SagaCompensator {

        @Override
        public java.util.concurrent.CompletableFuture<CompensationResult> compensate(SagaState sagaState) {
            return java.util.concurrent.CompletableFuture.completedFuture(
                    CompensationResult.noCompensationNeeded(sagaState.getSagaId()));
        }

        @Override
        public java.util.concurrent.CompletableFuture<CompensationResult> compensateStep(
                SagaState sagaState, SagaStepRecord stepRecord) {
            return java.util.concurrent.CompletableFuture.completedFuture(
                    CompensationResult.noCompensationNeeded(sagaState.getSagaId()));
        }

        @Override
        public boolean canCompensate(SagaState sagaState) {
            return false;
        }
    }
}
