package com.theyawns.framework.saga;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.cp.CPSubsystem;
import com.hazelcast.topic.ITopic;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.mockito.junit.jupiter.MockitoSettings;
import org.mockito.quality.Strictness;
import org.springframework.context.ApplicationEventPublisher;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.List;
import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.*;

/**
 * Unit tests for SagaTimeoutDetector.
 *
 * <p>Note: These tests use performTimeoutCheck() directly to avoid issues
 * with mocking FencedLock. The distributed lock behavior is tested
 * via the fallback path when CP Subsystem is not available.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@ExtendWith(MockitoExtension.class)
@MockitoSettings(strictness = Strictness.LENIENT)
@DisplayName("SagaTimeoutDetector - Timeout detection and handling")
class SagaTimeoutDetectorTest {

    @Mock
    private SagaStateStore sagaStateStore;

    @Mock
    private SagaCompensator compensator;

    @Mock
    private HazelcastInstance hazelcast;

    @Mock
    private CPSubsystem cpSubsystem;

    @Mock
    private ITopic<SagaTimedOutEvent.TimeoutDetails> topic;

    @Mock
    private ApplicationEventPublisher eventPublisher;

    private SagaTimeoutConfig config;
    private MeterRegistry meterRegistry;
    private SagaTimeoutDetector detector;

    @BeforeEach
    void setUp() {
        config = new SagaTimeoutConfig();
        config.setEnabled(true);
        config.setCheckInterval(Duration.ofSeconds(5));
        config.setDefaultDeadline(Duration.ofSeconds(30));
        config.setMaxBatchSize(100);
        config.setAutoCompensate(true);

        meterRegistry = new SimpleMeterRegistry();

        // Setup Hazelcast mocks - CP Subsystem throws to trigger fallback
        when(hazelcast.getCPSubsystem()).thenReturn(cpSubsystem);
        when(cpSubsystem.getLock(anyString())).thenThrow(
                new IllegalStateException("CP Subsystem is not enabled"));
        when(hazelcast.getTopic(anyString())).thenReturn((ITopic) topic);

        detector = new SagaTimeoutDetector(
                sagaStateStore,
                compensator,
                config,
                hazelcast,
                eventPublisher,
                meterRegistry
        );
    }

    @Nested
    @DisplayName("Constructor")
    class ConstructorTest {

        @Test
        @DisplayName("should reject null sagaStateStore")
        void shouldRejectNullSagaStateStore() {
            assertThrows(NullPointerException.class, () ->
                    new SagaTimeoutDetector(null, compensator, config, hazelcast, eventPublisher, meterRegistry));
        }

        @Test
        @DisplayName("should reject null compensator")
        void shouldRejectNullCompensator() {
            assertThrows(NullPointerException.class, () ->
                    new SagaTimeoutDetector(sagaStateStore, null, config, hazelcast, eventPublisher, meterRegistry));
        }

        @Test
        @DisplayName("should reject null config")
        void shouldRejectNullConfig() {
            assertThrows(NullPointerException.class, () ->
                    new SagaTimeoutDetector(sagaStateStore, compensator, null, hazelcast, eventPublisher, meterRegistry));
        }

        @Test
        @DisplayName("should reject null hazelcast")
        void shouldRejectNullHazelcast() {
            assertThrows(NullPointerException.class, () ->
                    new SagaTimeoutDetector(sagaStateStore, compensator, config, null, eventPublisher, meterRegistry));
        }

        @Test
        @DisplayName("should accept null eventPublisher")
        void shouldAcceptNullEventPublisher() {
            assertDoesNotThrow(() ->
                    new SagaTimeoutDetector(sagaStateStore, compensator, config, hazelcast, null, meterRegistry));
        }

        @Test
        @DisplayName("should accept null meterRegistry")
        void shouldAcceptNullMeterRegistry() {
            assertDoesNotThrow(() ->
                    new SagaTimeoutDetector(sagaStateStore, compensator, config, hazelcast, eventPublisher, null));
        }
    }

    @Nested
    @DisplayName("State queries")
    class StateQueries {

        @Test
        @DisplayName("isEnabled should return config value")
        void isEnabledShouldReturnConfigValue() {
            assertTrue(detector.isEnabled());

            config.setEnabled(false);
            assertFalse(detector.isEnabled());
        }

        @Test
        @DisplayName("isRunning should return false initially")
        void isRunningShouldReturnFalseInitially() {
            assertFalse(detector.isRunning());
        }

        @Test
        @DisplayName("getLastCheckTime should return 0 initially")
        void getLastCheckTimeShouldReturnZeroInitially() {
            assertEquals(0, detector.getLastCheckTime());
        }

        @Test
        @DisplayName("getTotalTimeoutsDetected should return 0 initially")
        void getTotalTimeoutsDetectedShouldReturnZeroInitially() {
            assertEquals(0, detector.getTotalTimeoutsDetected());
        }

        @Test
        @DisplayName("getConfig should return configuration")
        void getConfigShouldReturnConfiguration() {
            assertSame(config, detector.getConfig());
        }
    }

    @Nested
    @DisplayName("checkForTimedOutSagas - disabled")
    class CheckForTimedOutSagasDisabled {

        @Test
        @DisplayName("should skip check when disabled")
        void shouldSkipCheckWhenDisabled() {
            config.setEnabled(false);

            detector.checkForTimedOutSagas();

            verify(sagaStateStore, never()).findTimedOutSagas();
        }
    }

    @Nested
    @DisplayName("checkForTimedOutSagas - enabled with CP fallback")
    class CheckForTimedOutSagasEnabled {

        @Test
        @DisplayName("should fall back to non-locked execution when CP unavailable")
        void shouldFallBackToNonLockedExecutionWhenCpUnavailable() {
            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());

            // Should not throw, should fall back to non-locked execution
            detector.checkForTimedOutSagas();

            verify(sagaStateStore).findTimedOutSagas();
        }

        @Test
        @DisplayName("should find no timed-out sagas when none exist")
        void shouldFindNoTimedOutSagasWhenNoneExist() {
            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());

            detector.checkForTimedOutSagas();

            assertEquals(0, detector.getTotalTimeoutsDetected());
        }

        @Test
        @DisplayName("should process timed-out sagas")
        void shouldProcessTimedOutSagas() {
            SagaState timedOutSaga = createTimedOutSaga("saga-123");
            when(sagaStateStore.findTimedOutSagas()).thenReturn(List.of(timedOutSaga));
            when(sagaStateStore.completeSaga(anyString(), any(SagaStatus.class))).thenReturn(timedOutSaga);
            when(compensator.canCompensate(any())).thenReturn(true);
            when(compensator.compensate(any())).thenReturn(
                    CompletableFuture.completedFuture(SagaCompensator.CompensationResult.success("saga-123", 2)));

            detector.checkForTimedOutSagas();

            verify(sagaStateStore).completeSaga("saga-123", SagaStatus.TIMED_OUT);
            assertEquals(1, detector.getTotalTimeoutsDetected());
        }

        @Test
        @DisplayName("should respect max batch size")
        void shouldRespectMaxBatchSize() {
            config.setMaxBatchSize(2);

            List<SagaState> manySagas = Arrays.asList(
                    createTimedOutSaga("saga-1"),
                    createTimedOutSaga("saga-2"),
                    createTimedOutSaga("saga-3"),
                    createTimedOutSaga("saga-4")
            );

            when(sagaStateStore.findTimedOutSagas()).thenReturn(manySagas);
            when(sagaStateStore.completeSaga(anyString(), any(SagaStatus.class)))
                    .thenAnswer(inv -> createTimedOutSaga(inv.getArgument(0)));
            when(compensator.canCompensate(any())).thenReturn(false);

            detector.checkForTimedOutSagas();

            // Should only process 2 sagas (max batch size)
            verify(sagaStateStore, times(2)).completeSaga(anyString(), eq(SagaStatus.TIMED_OUT));
            assertEquals(2, detector.getTotalTimeoutsDetected());
        }

        @Test
        @DisplayName("should trigger compensation when auto-compensate enabled")
        void shouldTriggerCompensationWhenAutoCompensateEnabled() {
            config.setAutoCompensate(true);

            SagaState timedOutSaga = createTimedOutSaga("saga-123");
            when(sagaStateStore.findTimedOutSagas()).thenReturn(List.of(timedOutSaga));
            when(sagaStateStore.completeSaga(anyString(), any(SagaStatus.class))).thenReturn(timedOutSaga);
            when(compensator.canCompensate(any())).thenReturn(true);
            when(compensator.compensate(any())).thenReturn(
                    CompletableFuture.completedFuture(SagaCompensator.CompensationResult.success("saga-123", 2)));

            detector.checkForTimedOutSagas();

            verify(compensator).compensate(timedOutSaga);
        }

        @Test
        @DisplayName("should not trigger compensation when auto-compensate disabled")
        void shouldNotTriggerCompensationWhenAutoCompensateDisabled() {
            config.setAutoCompensate(false);

            SagaState timedOutSaga = createTimedOutSaga("saga-123");
            when(sagaStateStore.findTimedOutSagas()).thenReturn(List.of(timedOutSaga));
            when(sagaStateStore.completeSaga(anyString(), any(SagaStatus.class))).thenReturn(timedOutSaga);

            detector.checkForTimedOutSagas();

            verify(compensator, never()).compensate(any());
        }

        @Test
        @DisplayName("should publish timeout events")
        void shouldPublishTimeoutEvents() {
            SagaState timedOutSaga = createTimedOutSaga("saga-123");
            when(sagaStateStore.findTimedOutSagas()).thenReturn(List.of(timedOutSaga));
            when(sagaStateStore.completeSaga(anyString(), any(SagaStatus.class))).thenReturn(timedOutSaga);
            when(compensator.canCompensate(any())).thenReturn(false);

            detector.checkForTimedOutSagas();

            // Verify Spring event
            verify(eventPublisher).publishEvent(any(SagaTimedOutEvent.class));

            // Verify Hazelcast topic
            verify(topic).publish(any(SagaTimedOutEvent.TimeoutDetails.class));
        }

        @Test
        @DisplayName("should update last check time")
        void shouldUpdateLastCheckTime() {
            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());

            long beforeCheck = System.currentTimeMillis();
            detector.checkForTimedOutSagas();
            long afterCheck = System.currentTimeMillis();

            long lastCheck = detector.getLastCheckTime();
            assertTrue(lastCheck >= beforeCheck);
            assertTrue(lastCheck <= afterCheck);
        }
    }

    @Nested
    @DisplayName("performTimeoutCheck")
    class PerformTimeoutCheckTest {

        @Test
        @DisplayName("should process sagas directly")
        void shouldProcessSagasDirectly() {
            SagaState timedOutSaga = createTimedOutSaga("saga-123");
            when(sagaStateStore.findTimedOutSagas()).thenReturn(List.of(timedOutSaga));
            when(sagaStateStore.completeSaga(anyString(), any(SagaStatus.class))).thenReturn(timedOutSaga);
            when(compensator.canCompensate(any())).thenReturn(false);

            detector.performTimeoutCheck();

            verify(sagaStateStore).completeSaga("saga-123", SagaStatus.TIMED_OUT);
        }

        @Test
        @DisplayName("should return early if already running")
        void shouldReturnEarlyIfAlreadyRunning() {
            // This test verifies idempotency - calling performTimeoutCheck while
            // one is already in progress should skip
            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());

            detector.performTimeoutCheck();

            // Should complete without issues
            assertFalse(detector.isRunning());
        }
    }

    @Nested
    @DisplayName("triggerCheck")
    class TriggerCheckTest {

        @Test
        @DisplayName("should manually trigger a check")
        void shouldManuallyTriggerACheck() {
            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());

            detector.triggerCheck();

            verify(sagaStateStore).findTimedOutSagas();
        }
    }

    @Nested
    @DisplayName("Metrics")
    class MetricsTest {

        @Test
        @DisplayName("should increment timeouts detected counter")
        void shouldIncrementTimeoutsDetectedCounter() {
            SagaState timedOutSaga = createTimedOutSaga("saga-123");
            when(sagaStateStore.findTimedOutSagas()).thenReturn(List.of(timedOutSaga));
            when(sagaStateStore.completeSaga(anyString(), any(SagaStatus.class))).thenReturn(timedOutSaga);
            when(compensator.canCompensate(any())).thenReturn(false);

            detector.performTimeoutCheck();

            double count = meterRegistry.counter("saga.timeouts.detected").count();
            assertEquals(1.0, count, 0.001);
        }

        @Test
        @DisplayName("should increment compensations triggered counter")
        void shouldIncrementCompensationsTriggeredCounter() {
            SagaState timedOutSaga = createTimedOutSaga("saga-123");
            when(sagaStateStore.findTimedOutSagas()).thenReturn(List.of(timedOutSaga));
            when(sagaStateStore.completeSaga(anyString(), any(SagaStatus.class))).thenReturn(timedOutSaga);
            when(compensator.canCompensate(any())).thenReturn(true);
            when(compensator.compensate(any())).thenReturn(
                    CompletableFuture.completedFuture(SagaCompensator.CompensationResult.success("saga-123", 2)));

            detector.performTimeoutCheck();

            double count = meterRegistry.counter("saga.timeouts.compensations.triggered").count();
            assertEquals(1.0, count, 0.001);
        }

        @Test
        @DisplayName("should record check duration")
        void shouldRecordCheckDuration() {
            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());

            detector.performTimeoutCheck();

            long count = meterRegistry.timer("saga.timeout.check.duration").count();
            assertEquals(1, count);
        }
    }

    @Nested
    @DisplayName("Saga purge")
    class SagaPurgeTest {

        @Test
        @DisplayName("should purge completed sagas after configured number of check cycles")
        void shouldPurgeAfterConfiguredCheckCycles() {
            config.setPurgeEnabled(true);
            config.setPurgeIntervalChecks(3);
            config.setPurgeOlderThan(Duration.ofMinutes(10));

            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());
            when(sagaStateStore.purgeCompletedSagas(any(Duration.class))).thenReturn(5);

            // Run 3 checks — purge should happen on the 3rd
            detector.performTimeoutCheck();
            detector.performTimeoutCheck();
            detector.performTimeoutCheck();

            verify(sagaStateStore, times(1)).purgeCompletedSagas(Duration.ofMinutes(10));
        }

        @Test
        @DisplayName("should not purge before interval is reached")
        void shouldNotPurgeBeforeIntervalReached() {
            config.setPurgeEnabled(true);
            config.setPurgeIntervalChecks(3);

            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());

            // Run 2 checks — purge should NOT happen yet
            detector.performTimeoutCheck();
            detector.performTimeoutCheck();

            verify(sagaStateStore, never()).purgeCompletedSagas(any(Duration.class));
        }

        @Test
        @DisplayName("should not purge when purge is disabled")
        void shouldNotPurgeWhenDisabled() {
            config.setPurgeEnabled(false);
            config.setPurgeIntervalChecks(1);

            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());

            detector.performTimeoutCheck();

            verify(sagaStateStore, never()).purgeCompletedSagas(any(Duration.class));
        }

        @Test
        @DisplayName("should record purge removed metric")
        void shouldRecordPurgeRemovedMetric() {
            config.setPurgeEnabled(true);
            config.setPurgeIntervalChecks(1);

            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());
            when(sagaStateStore.purgeCompletedSagas(any(Duration.class))).thenReturn(7);

            detector.performTimeoutCheck();

            double count = meterRegistry.counter("saga.purge.removed").count();
            assertEquals(7.0, count, 0.001);
        }

        @Test
        @DisplayName("should handle purge errors gracefully")
        void shouldHandlePurgeErrorsGracefully() {
            config.setPurgeEnabled(true);
            config.setPurgeIntervalChecks(1);

            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());
            when(sagaStateStore.purgeCompletedSagas(any(Duration.class)))
                    .thenThrow(new RuntimeException("Purge failed"));

            // Should not throw — error is caught and logged
            assertDoesNotThrow(() -> detector.performTimeoutCheck());
        }

        @Test
        @DisplayName("should increment purge check counter")
        void shouldIncrementPurgeCheckCounter() {
            config.setPurgeEnabled(true);
            config.setPurgeIntervalChecks(10);

            when(sagaStateStore.findTimedOutSagas()).thenReturn(Collections.emptyList());

            detector.performTimeoutCheck();
            assertEquals(1, detector.getPurgeCheckCounter());

            detector.performTimeoutCheck();
            assertEquals(2, detector.getPurgeCheckCounter());
        }
    }

    @Nested
    @DisplayName("Error handling")
    class ErrorHandling {

        @Test
        @DisplayName("should continue processing other sagas when one fails")
        void shouldContinueProcessingOtherSagasWhenOneFails() {
            SagaState saga1 = createTimedOutSaga("saga-1");
            SagaState saga2 = createTimedOutSaga("saga-2");

            when(sagaStateStore.findTimedOutSagas()).thenReturn(Arrays.asList(saga1, saga2));
            when(sagaStateStore.completeSaga("saga-1", SagaStatus.TIMED_OUT))
                    .thenThrow(new RuntimeException("DB error"));
            when(sagaStateStore.completeSaga("saga-2", SagaStatus.TIMED_OUT)).thenReturn(saga2);
            when(compensator.canCompensate(any())).thenReturn(false);

            detector.performTimeoutCheck();

            // Should still process saga-2 despite saga-1 failure
            verify(sagaStateStore).completeSaga("saga-2", SagaStatus.TIMED_OUT);
        }
    }

    // Helper methods

    private SagaState createTimedOutSaga(String sagaId) {
        List<SagaStepRecord> steps = new ArrayList<>();
        steps.add(SagaStepRecord.builder()
                .stepNumber(0)
                .stepName("OrderCreated")
                .eventType("OrderCreated")
                .service("order-service")
                .status(StepStatus.COMPLETED)
                .build());

        return SagaState.builder()
                .sagaId(sagaId)
                .sagaType("OrderFulfillment")
                .correlationId("corr-" + sagaId)
                .status(SagaStatus.IN_PROGRESS)
                .startedAt(Instant.now().minus(Duration.ofMinutes(5)))
                .deadline(Instant.now().minus(Duration.ofSeconds(30)))
                .currentStep(1)
                .totalSteps(4)
                .steps(steps)
                .initiatingService("order-service")
                .initiatingEventId("evt-" + sagaId)
                .build();
    }
}
