package com.theyawns.framework.resilience;

import io.github.resilience4j.retry.Retry;
import io.github.resilience4j.retry.RetryConfig;
import io.github.resilience4j.retry.RetryRegistry;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.util.concurrent.atomic.AtomicInteger;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Tests for {@link RetryEventListener}.
 *
 * <p>Uses real {@link RetryRegistry} and {@link SimpleMeterRegistry} instances
 * (no mocking — Java 25 safe).
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("RetryEventListener - Retry observability")
class RetryEventListenerTest {

    private RetryRegistry retryRegistry;
    private MeterRegistry meterRegistry;

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
    }

    @Nested
    @DisplayName("Registration")
    class Registration {

        @Test
        @DisplayName("should register listeners on existing retry instances")
        void shouldRegisterListenersOnExistingRetryInstances() {
            final RetryConfig config = RetryConfig.custom()
                    .maxAttempts(2)
                    .waitDuration(Duration.ofMillis(1))
                    .build();
            retryRegistry = RetryRegistry.of(config);

            // Create a retry instance BEFORE the listener is registered
            retryRegistry.retry("pre-existing");

            // Register the listener — should hook into "pre-existing"
            new RetryEventListener(retryRegistry, meterRegistry);

            // Exercise the pre-existing instance — if listeners are hooked, no exception
            final Retry retry = retryRegistry.retry("pre-existing");
            final AtomicInteger attempts = new AtomicInteger(0);
            try {
                Retry.decorateSupplier(retry, () -> {
                    if (attempts.incrementAndGet() < 2) {
                        throw new RuntimeException("transient");
                    }
                    return "ok";
                }).get();
            } catch (Exception ignored) {
                // may fail, we just care that listeners are registered
            }

            // No assertion on logs, but verifying no NPE or registration errors
            assertThat(retry.getName()).isEqualTo("pre-existing");
        }

        @Test
        @DisplayName("should register listeners on retry instances added after creation")
        void shouldRegisterListenersOnNewRetryInstances() {
            retryRegistry = RetryRegistry.ofDefaults();
            new RetryEventListener(retryRegistry, meterRegistry);

            // Create a NEW retry instance after listener registration
            final Retry retry = retryRegistry.retry("post-creation");
            assertThat(retry.getName()).isEqualTo("post-creation");
        }
    }

    @Nested
    @DisplayName("Event handling")
    class EventHandling {

        @Test
        @DisplayName("should handle retry and success events on transient failure")
        void shouldHandleRetryAndSuccessEvents() {
            final RetryConfig config = RetryConfig.custom()
                    .maxAttempts(3)
                    .waitDuration(Duration.ofMillis(1))
                    .build();
            retryRegistry = RetryRegistry.of(config);
            new RetryEventListener(retryRegistry, meterRegistry);

            final Retry retry = retryRegistry.retry("transient-test");
            final AtomicInteger attempts = new AtomicInteger(0);

            final String result = Retry.decorateSupplier(retry, () -> {
                if (attempts.incrementAndGet() < 3) {
                    throw new RuntimeException("transient failure");
                }
                return "recovered";
            }).get();

            assertThat(result).isEqualTo("recovered");
            assertThat(attempts.get()).isEqualTo(3);
        }

        @Test
        @DisplayName("should handle error event when all retries exhausted")
        void shouldHandleErrorEvent() {
            final RetryConfig config = RetryConfig.custom()
                    .maxAttempts(2)
                    .waitDuration(Duration.ofMillis(1))
                    .build();
            retryRegistry = RetryRegistry.of(config);
            new RetryEventListener(retryRegistry, meterRegistry);

            final Retry retry = retryRegistry.retry("exhausted-test");

            assertThatThrownBy(() -> Retry.decorateSupplier(retry, () -> {
                throw new RuntimeException("persistent failure");
            }).get())
                    .isInstanceOf(RuntimeException.class)
                    .hasMessage("persistent failure");
        }

        @Test
        @DisplayName("should handle ignored error event for non-retryable exception")
        void shouldHandleIgnoredErrorEvent() {
            final RetryConfig config = RetryConfig.custom()
                    .maxAttempts(3)
                    .waitDuration(Duration.ofMillis(1))
                    .retryOnException(e -> !(e instanceof NonRetryableException))
                    .build();
            retryRegistry = RetryRegistry.of(config);
            new RetryEventListener(retryRegistry, meterRegistry);

            final Retry retry = retryRegistry.retry("ignored-test");

            assertThatThrownBy(() -> Retry.decorateSupplier(retry, () -> {
                throw new TestNonRetryableException("business failure");
            }).get())
                    .isInstanceOf(TestNonRetryableException.class)
                    .hasMessage("business failure");
        }
    }

    @Nested
    @DisplayName("Metrics")
    class Metrics {

        @Test
        @DisplayName("should increment ignored counter for non-retryable exceptions")
        void shouldIncrementIgnoredCounter() {
            final RetryConfig config = RetryConfig.custom()
                    .maxAttempts(3)
                    .waitDuration(Duration.ofMillis(1))
                    .retryOnException(e -> !(e instanceof NonRetryableException))
                    .build();
            retryRegistry = RetryRegistry.of(config);
            new RetryEventListener(retryRegistry, meterRegistry);

            final Retry retry = retryRegistry.retry("counter-test");

            try {
                Retry.decorateSupplier(retry, () -> {
                    throw new TestNonRetryableException("not retryable");
                }).get();
            } catch (TestNonRetryableException ignored) {
                // expected
            }

            final double count = meterRegistry.counter(
                    "framework.resilience.retry.ignored", "name", "counter-test").count();
            assertThat(count).isEqualTo(1.0);
        }

        @Test
        @DisplayName("should not increment ignored counter for retryable exceptions")
        void shouldNotIncrementIgnoredCounterForRetryableExceptions() {
            final RetryConfig config = RetryConfig.custom()
                    .maxAttempts(2)
                    .waitDuration(Duration.ofMillis(1))
                    .retryOnException(e -> !(e instanceof NonRetryableException))
                    .build();
            retryRegistry = RetryRegistry.of(config);
            new RetryEventListener(retryRegistry, meterRegistry);

            final Retry retry = retryRegistry.retry("retryable-counter-test");

            try {
                Retry.decorateSupplier(retry, () -> {
                    throw new RuntimeException("retryable");
                }).get();
            } catch (RuntimeException ignored) {
                // expected
            }

            final double count = meterRegistry.counter(
                    "framework.resilience.retry.ignored", "name", "retryable-counter-test").count();
            assertThat(count).isEqualTo(0.0);
        }
    }

    // ========== Test helpers ==========

    /**
     * Test exception that implements NonRetryableException for testing ignored error behavior.
     */
    private static class TestNonRetryableException extends RuntimeException implements NonRetryableException {
        TestNonRetryableException(final String message) {
            super(message);
        }
    }
}
