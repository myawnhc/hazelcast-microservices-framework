package com.theyawns.framework.resilience;

import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.retry.RetryConfig;
import io.github.resilience4j.retry.RetryRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicInteger;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Tests for {@link ResilientServiceInvoker}.
 *
 * <p>Uses real {@link CircuitBreakerRegistry} and {@link RetryRegistry} instances
 * (no mocking â€” Java 25 safe).
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("ResilientServiceInvoker - Resilient operation execution")
class ResilientServiceInvokerTest {

    private ResilienceProperties properties;
    private CircuitBreakerRegistry cbRegistry;
    private RetryRegistry retryRegistry;
    private ResilientServiceInvoker invoker;

    @BeforeEach
    void setUp() {
        properties = new ResilienceProperties();

        final CircuitBreakerConfig cbConfig = CircuitBreakerConfig.custom()
                .failureRateThreshold(50)
                .slidingWindowSize(4)
                .minimumNumberOfCalls(4)
                .permittedNumberOfCallsInHalfOpenState(1)
                .waitDurationInOpenState(Duration.ofSeconds(60))
                .build();
        cbRegistry = CircuitBreakerRegistry.of(cbConfig);

        final RetryConfig retryConfig = RetryConfig.custom()
                .maxAttempts(3)
                .waitDuration(Duration.ofMillis(10))
                .build();
        retryRegistry = RetryRegistry.of(retryConfig);

        invoker = new ResilientServiceInvoker(cbRegistry, retryRegistry, properties);
    }

    @Nested
    @DisplayName("Synchronous execute")
    class SyncExecute {

        @Test
        @DisplayName("should return result on successful call")
        void shouldReturnResultOnSuccess() {
            final String result = invoker.execute("test", () -> "hello");
            assertThat(result).isEqualTo("hello");
        }

        @Test
        @DisplayName("should retry on transient failure and succeed")
        void shouldRetryOnTransientFailureAndSucceed() {
            final AtomicInteger attempts = new AtomicInteger(0);

            final String result = invoker.execute("retryTest", () -> {
                if (attempts.incrementAndGet() < 3) {
                    throw new RuntimeException("transient failure");
                }
                return "recovered";
            });

            assertThat(result).isEqualTo("recovered");
            assertThat(attempts.get()).isEqualTo(3);
        }

        @Test
        @DisplayName("should throw ResilienceException after retries exhausted")
        void shouldThrowResilienceExceptionAfterRetriesExhausted() {
            assertThatThrownBy(() -> invoker.execute("failTest", () -> {
                throw new RuntimeException("persistent failure");
            }))
                    .isInstanceOf(ResilienceException.class)
                    .hasMessageContaining("failTest")
                    .hasMessageContaining("failed after retries");
        }

        @Test
        @DisplayName("should preserve operation name in ResilienceException")
        void shouldPreserveOperationNameInException() {
            try {
                invoker.execute("myOperation", () -> {
                    throw new RuntimeException("fail");
                });
            } catch (ResilienceException e) {
                assertThat(e.getOperationName()).isEqualTo("myOperation");
                assertThat(e.getCause()).isNotNull();
            }
        }

        @Test
        @DisplayName("should open circuit breaker after repeated failures")
        void shouldOpenCircuitBreakerAfterRepeatedFailures() {
            // Fill the sliding window with failures (4 calls needed)
            for (int i = 0; i < 4; i++) {
                try {
                    invoker.execute("cbTest", () -> {
                        throw new RuntimeException("failure");
                    });
                } catch (ResilienceException ignored) {
                    // expected
                }
            }

            final CircuitBreaker cb = cbRegistry.circuitBreaker("cbTest");
            assertThat(cb.getState()).isEqualTo(CircuitBreaker.State.OPEN);
        }

        @Test
        @DisplayName("should reject call when circuit breaker is open")
        void shouldRejectCallWhenCircuitBreakerIsOpen() {
            final CircuitBreaker cb = cbRegistry.circuitBreaker("openCB");
            cb.transitionToOpenState();

            assertThatThrownBy(() -> invoker.execute("openCB", () -> "should not run"))
                    .isInstanceOf(ResilienceException.class)
                    .hasMessageContaining("open, call rejected");
        }
    }

    @Nested
    @DisplayName("Void executeRunnable")
    class VoidExecuteRunnable {

        @Test
        @DisplayName("should execute runnable successfully")
        void shouldExecuteRunnableSuccessfully() {
            final AtomicInteger counter = new AtomicInteger(0);
            invoker.executeRunnable("runnableTest", counter::incrementAndGet);
            assertThat(counter.get()).isEqualTo(1);
        }

        @Test
        @DisplayName("should retry runnable on transient failure")
        void shouldRetryRunnableOnTransientFailure() {
            final AtomicInteger attempts = new AtomicInteger(0);

            invoker.executeRunnable("runnableRetry", () -> {
                if (attempts.incrementAndGet() < 3) {
                    throw new RuntimeException("transient");
                }
            });

            assertThat(attempts.get()).isEqualTo(3);
        }

        @Test
        @DisplayName("should throw ResilienceException when runnable fails after retries")
        void shouldThrowResilienceExceptionWhenRunnableFails() {
            assertThatThrownBy(() -> invoker.executeRunnable("runnableFail", () -> {
                throw new RuntimeException("persistent");
            }))
                    .isInstanceOf(ResilienceException.class)
                    .hasMessageContaining("runnableFail");
        }
    }

    @Nested
    @DisplayName("Async executeAsync")
    class AsyncExecuteAsync {

        @Test
        @DisplayName("should return completed future on success")
        void shouldReturnCompletedFutureOnSuccess() throws Exception {
            final CompletableFuture<String> future = invoker.executeAsync("asyncTest",
                    () -> CompletableFuture.completedFuture("async result"));

            assertThat(future.get()).isEqualTo("async result");
        }

        @Test
        @DisplayName("should return failed future when circuit breaker is open")
        void shouldReturnFailedFutureWhenCircuitBreakerOpen() {
            final CircuitBreaker cb = cbRegistry.circuitBreaker("asyncOpenCB");
            cb.transitionToOpenState();

            final CompletableFuture<String> future = invoker.executeAsync("asyncOpenCB",
                    () -> CompletableFuture.completedFuture("should not run"));

            assertThat(future.isCompletedExceptionally()).isTrue();
            assertThatThrownBy(future::get)
                    .isInstanceOf(ExecutionException.class)
                    .hasCauseInstanceOf(ResilienceException.class);
        }

        @Test
        @DisplayName("should return failed future when supplier throws after retries")
        void shouldReturnFailedFutureWhenSupplierThrows() {
            final CompletableFuture<String> future = invoker.executeAsync("asyncFail", () -> {
                throw new RuntimeException("async failure");
            });

            assertThat(future.isCompletedExceptionally()).isTrue();
        }
    }

    @Nested
    @DisplayName("Disabled passthrough")
    class DisabledPassthrough {

        @Test
        @DisplayName("should delegate directly when disabled")
        void shouldDelegateDirectlyWhenDisabled() {
            properties.setEnabled(false);

            final String result = invoker.execute("disabledTest", () -> "direct");
            assertThat(result).isEqualTo("direct");
        }

        @Test
        @DisplayName("should not intercept exceptions when disabled")
        void shouldNotInterceptExceptionsWhenDisabled() {
            properties.setEnabled(false);

            assertThatThrownBy(() -> invoker.execute("disabledFail", () -> {
                throw new RuntimeException("raw failure");
            }))
                    .isInstanceOf(RuntimeException.class)
                    .hasMessage("raw failure")
                    .isNotInstanceOf(ResilienceException.class);
        }

        @Test
        @DisplayName("should run runnable directly when disabled")
        void shouldRunRunnableDirectlyWhenDisabled() {
            properties.setEnabled(false);
            final AtomicInteger counter = new AtomicInteger(0);
            invoker.executeRunnable("disabledRunnable", counter::incrementAndGet);
            assertThat(counter.get()).isEqualTo(1);
        }

        @Test
        @DisplayName("should return future directly when disabled")
        void shouldReturnFutureDirectlyWhenDisabled() throws Exception {
            properties.setEnabled(false);
            final CompletableFuture<String> future = invoker.executeAsync("disabledAsync",
                    () -> CompletableFuture.completedFuture("direct async"));
            assertThat(future.get()).isEqualTo("direct async");
        }
    }

    @Nested
    @DisplayName("Accessors")
    class Accessors {

        @Test
        @DisplayName("should return circuit breaker instance by name")
        void shouldReturnCircuitBreakerByName() {
            final CircuitBreaker cb = invoker.getCircuitBreaker("myInstance");
            assertThat(cb).isNotNull();
            assertThat(cb.getName()).isEqualTo("myInstance");
        }

        @Test
        @DisplayName("should return retry instance by name")
        void shouldReturnRetryByName() {
            final io.github.resilience4j.retry.Retry retry = invoker.getRetry("myInstance");
            assertThat(retry).isNotNull();
            assertThat(retry.getName()).isEqualTo("myInstance");
        }

        @Test
        @DisplayName("should report enabled status")
        void shouldReportEnabledStatus() {
            assertThat(invoker.isEnabled()).isTrue();
            properties.setEnabled(false);
            assertThat(invoker.isEnabled()).isFalse();
        }
    }
}
