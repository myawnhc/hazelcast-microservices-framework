package com.theyawns.framework.resilience;

import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.retry.RetryConfig;
import io.github.resilience4j.retry.RetryRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Integration test for the full resilience lifecycle.
 *
 * <p>Tests realistic scenarios that exercise circuit breaker state transitions
 * (CLOSED → OPEN → HALF_OPEN → CLOSED) combined with retry behavior,
 * simulating a service that fails, recovers, and the circuit breaker responds.
 *
 * <p>Uses real Resilience4j registries (no mocks) and a tight sliding window
 * to make state transitions deterministic in a test context.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("Resilience Lifecycle Integration - Full circuit breaker + retry lifecycle")
class ResilienceLifecycleIntegrationTest {

    private ResilienceProperties properties;
    private ResilientServiceInvoker invoker;
    private CircuitBreakerRegistry cbRegistry;
    private SimpleMeterRegistry meterRegistry;

    @BeforeEach
    void setUp() {
        properties = new ResilienceProperties();
        meterRegistry = new SimpleMeterRegistry();

        // Tight sliding window for fast, deterministic state transitions
        final CircuitBreakerConfig cbConfig = CircuitBreakerConfig.custom()
                .failureRateThreshold(50)
                .slidingWindowSize(4)
                .minimumNumberOfCalls(4)
                .permittedNumberOfCallsInHalfOpenState(2)
                .waitDurationInOpenState(Duration.ofMillis(200))
                .automaticTransitionFromOpenToHalfOpenEnabled(true)
                .build();
        cbRegistry = CircuitBreakerRegistry.of(cbConfig);

        // Single attempt — no retry (isolate circuit breaker behavior)
        final RetryConfig retryConfig = RetryConfig.custom()
                .maxAttempts(1)
                .waitDuration(Duration.ofMillis(10))
                .build();
        final RetryRegistry retryRegistry = RetryRegistry.of(retryConfig);

        invoker = new ResilientServiceInvoker(cbRegistry, retryRegistry, properties);
    }

    @Test
    @DisplayName("should transition CLOSED → OPEN → HALF_OPEN → CLOSED on service recovery")
    void shouldTransitionThroughFullCircuitBreakerLifecycle() throws InterruptedException {
        final String name = "lifecycle-test";
        final AtomicBoolean serviceHealthy = new AtomicBoolean(false);

        // Phase 1: Service is down — fill sliding window with failures
        for (int i = 0; i < 4; i++) {
            try {
                invoker.execute(name, () -> {
                    if (!serviceHealthy.get()) {
                        throw new RuntimeException("Service unavailable");
                    }
                    return "ok";
                });
            } catch (ResilienceException ignored) {
                // expected
            }
        }

        // Verify: circuit breaker is now OPEN
        CircuitBreaker cb = cbRegistry.circuitBreaker(name);
        assertThat(cb.getState()).isEqualTo(CircuitBreaker.State.OPEN);

        // Phase 2: Calls are rejected while OPEN
        assertThatThrownBy(() -> invoker.execute(name, () -> "should not run"))
                .isInstanceOf(ResilienceException.class)
                .hasMessageContaining("open, call rejected");

        // Phase 3: Service recovers
        serviceHealthy.set(true);

        // Wait for automatic transition to HALF_OPEN
        Thread.sleep(300);

        assertThat(cb.getState()).isEqualTo(CircuitBreaker.State.HALF_OPEN);

        // Phase 4: Test calls in HALF_OPEN succeed → circuit returns to CLOSED
        for (int i = 0; i < 2; i++) {
            String result = invoker.execute(name, () -> "recovered");
            assertThat(result).isEqualTo("recovered");
        }

        assertThat(cb.getState()).isEqualTo(CircuitBreaker.State.CLOSED);
    }

    @Test
    @DisplayName("should transition HALF_OPEN → OPEN when test calls fail")
    void shouldReturnToOpenWhenHalfOpenCallsFail() throws InterruptedException {
        final String name = "half-open-fail";

        // Fill sliding window with failures → OPEN
        for (int i = 0; i < 4; i++) {
            try {
                invoker.execute(name, () -> {
                    throw new RuntimeException("down");
                });
            } catch (ResilienceException ignored) {
            }
        }

        CircuitBreaker cb = cbRegistry.circuitBreaker(name);
        assertThat(cb.getState()).isEqualTo(CircuitBreaker.State.OPEN);

        // Wait for HALF_OPEN
        Thread.sleep(300);
        assertThat(cb.getState()).isEqualTo(CircuitBreaker.State.HALF_OPEN);

        // Test calls in HALF_OPEN also fail → back to OPEN
        // (permittedNumberOfCallsInHalfOpenState=2, so both must fail)
        for (int i = 0; i < 2; i++) {
            try {
                invoker.execute(name, () -> {
                    throw new RuntimeException("still down");
                });
            } catch (ResilienceException ignored) {
            }
        }

        assertThat(cb.getState()).isEqualTo(CircuitBreaker.State.OPEN);
    }

    @Test
    @DisplayName("should isolate circuit breakers by name — one failure does not affect another")
    void shouldIsolateCircuitBreakersByName() {
        final String failingService = "service-A";
        final String healthyService = "service-B";

        // Fail service-A enough to open its circuit breaker
        for (int i = 0; i < 4; i++) {
            try {
                invoker.execute(failingService, () -> {
                    throw new RuntimeException("A is down");
                });
            } catch (ResilienceException ignored) {
            }
        }

        CircuitBreaker cbA = cbRegistry.circuitBreaker(failingService);
        CircuitBreaker cbB = cbRegistry.circuitBreaker(healthyService);

        assertThat(cbA.getState()).isEqualTo(CircuitBreaker.State.OPEN);
        assertThat(cbB.getState()).isEqualTo(CircuitBreaker.State.CLOSED);

        // service-B still works normally
        String result = invoker.execute(healthyService, () -> "B is fine");
        assertThat(result).isEqualTo("B is fine");
    }

    @Test
    @DisplayName("should work end-to-end with retry + circuit breaker combined")
    void shouldWorkEndToEndWithRetryAndCircuitBreaker() {
        // Rebuild with retry enabled (3 attempts)
        final RetryConfig retryConfig = RetryConfig.custom()
                .maxAttempts(3)
                .waitDuration(Duration.ofMillis(10))
                .retryOnException(e -> !(e instanceof NonRetryableException))
                .build();
        final RetryRegistry retryRegistry = RetryRegistry.of(retryConfig);
        final ResilientServiceInvoker retryInvoker =
                new ResilientServiceInvoker(cbRegistry, retryRegistry, properties);

        final String name = "retry-cb-combo";
        final AtomicInteger callCount = new AtomicInteger(0);

        // Operation fails twice, succeeds on third attempt
        String result = retryInvoker.execute(name, () -> {
            if (callCount.incrementAndGet() < 3) {
                throw new RuntimeException("transient");
            }
            return "success after retry";
        });

        assertThat(result).isEqualTo("success after retry");
        assertThat(callCount.get()).isEqualTo(3);

        // Circuit breaker still CLOSED because the final outcome was success
        CircuitBreaker cb = cbRegistry.circuitBreaker(name);
        assertThat(cb.getState()).isEqualTo(CircuitBreaker.State.CLOSED);
    }

    @Test
    @DisplayName("should not retry NonRetryableException but still count in circuit breaker")
    void shouldNotRetryNonRetryableButCountInCircuitBreaker() {
        final RetryConfig retryConfig = RetryConfig.custom()
                .maxAttempts(3)
                .waitDuration(Duration.ofMillis(10))
                .retryOnException(e -> !(e instanceof NonRetryableException))
                .build();
        final RetryRegistry retryRegistry = RetryRegistry.of(retryConfig);
        final ResilientServiceInvoker retryInvoker =
                new ResilientServiceInvoker(cbRegistry, retryRegistry, properties);

        final String name = "non-retryable-cb";
        final AtomicInteger callCount = new AtomicInteger(0);

        // Throw NonRetryableException 4 times to fill sliding window
        for (int i = 0; i < 4; i++) {
            try {
                retryInvoker.execute(name, () -> {
                    callCount.incrementAndGet();
                    throw new TestNonRetryableException("business error");
                });
            } catch (ResilienceException ignored) {
            }
        }

        // Each call should have been attempted exactly once (no retry)
        assertThat(callCount.get()).isEqualTo(4);

        // Circuit breaker should be OPEN from the 4 failures
        CircuitBreaker cb = cbRegistry.circuitBreaker(name);
        assertThat(cb.getState()).isEqualTo(CircuitBreaker.State.OPEN);
    }

    @Test
    @DisplayName("async executeAsync should reflect circuit breaker state")
    void asyncShouldReflectCircuitBreakerState() throws Exception {
        final String name = "async-lifecycle";

        // Succeed in CLOSED state
        CompletableFuture<String> good = invoker.executeAsync(name,
                () -> CompletableFuture.completedFuture("async ok"));
        assertThat(good.get()).isEqualTo("async ok");

        // Fill sliding window with failures
        for (int i = 0; i < 4; i++) {
            try {
                invoker.executeAsync(name, () -> {
                    throw new RuntimeException("async failure");
                }).get();
            } catch (ExecutionException ignored) {
            }
        }

        // Circuit is OPEN → async call returns failed future
        CompletableFuture<String> rejected = invoker.executeAsync(name,
                () -> CompletableFuture.completedFuture("should not run"));
        assertThat(rejected.isCompletedExceptionally()).isTrue();
    }

    /**
     * Test exception implementing NonRetryableException.
     */
    private static class TestNonRetryableException extends RuntimeException
            implements NonRetryableException {
        TestNonRetryableException(final String message) {
            super(message);
        }
    }
}
