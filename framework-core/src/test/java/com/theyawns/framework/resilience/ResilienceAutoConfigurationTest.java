package com.theyawns.framework.resilience;

import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.micrometer.tagged.TaggedCircuitBreakerMetrics;
import io.github.resilience4j.micrometer.tagged.TaggedRetryMetrics;
import io.github.resilience4j.retry.RetryRegistry;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.test.context.runner.ApplicationContextRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link ResilienceAutoConfiguration}.
 *
 * <p>Uses {@link ApplicationContextRunner} pattern to test auto-configuration
 * behavior without starting a full Spring context.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("ResilienceAutoConfiguration - Auto-configuration behavior")
class ResilienceAutoConfigurationTest {

    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(ResilienceAutoConfiguration.class));

    @Nested
    @DisplayName("Default configuration")
    class DefaultConfiguration {

        @Test
        @DisplayName("should create all beans by default")
        void shouldCreateAllBeansByDefault() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(CircuitBreakerRegistry.class);
                        assertThat(context).hasSingleBean(RetryRegistry.class);
                        assertThat(context).hasSingleBean(ResilientServiceInvoker.class);
                        assertThat(context).hasSingleBean(ResilienceProperties.class);
                        assertThat(context).hasSingleBean(TaggedCircuitBreakerMetrics.class);
                        assertThat(context).hasSingleBean(TaggedRetryMetrics.class);
                        assertThat(context).hasSingleBean(RetryEventListener.class);
                    });
        }

        @Test
        @DisplayName("should create beans when enabled property is not set (matchIfMissing)")
        void shouldCreateBeansWhenPropertyNotSet() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(ResilientServiceInvoker.class);
                    });
        }
    }

    @Nested
    @DisplayName("Property binding")
    class PropertyBinding {

        @Test
        @DisplayName("should bind circuit breaker properties")
        void shouldBindCircuitBreakerProperties() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class)
                    .withPropertyValues(
                            "framework.resilience.circuit-breaker.failure-rate-threshold=70",
                            "framework.resilience.circuit-breaker.sliding-window-size=20",
                            "framework.resilience.circuit-breaker.minimum-number-of-calls=10",
                            "framework.resilience.circuit-breaker.permitted-number-of-calls-in-half-open-state=5",
                            "framework.resilience.circuit-breaker.wait-duration-in-open-state=30s"
                    )
                    .run(context -> {
                        final ResilienceProperties props = context.getBean(ResilienceProperties.class);
                        assertThat(props.getCircuitBreaker().getFailureRateThreshold()).isEqualTo(70);
                        assertThat(props.getCircuitBreaker().getSlidingWindowSize()).isEqualTo(20);
                        assertThat(props.getCircuitBreaker().getMinimumNumberOfCalls()).isEqualTo(10);
                        assertThat(props.getCircuitBreaker().getPermittedNumberOfCallsInHalfOpenState())
                                .isEqualTo(5);
                        assertThat(props.getCircuitBreaker().getWaitDurationInOpenState().getSeconds())
                                .isEqualTo(30);
                    });
        }

        @Test
        @DisplayName("should bind retry properties")
        void shouldBindRetryProperties() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class)
                    .withPropertyValues(
                            "framework.resilience.retry.max-attempts=5",
                            "framework.resilience.retry.wait-duration=1s",
                            "framework.resilience.retry.enable-exponential-backoff=false",
                            "framework.resilience.retry.exponential-backoff-multiplier=3.0"
                    )
                    .run(context -> {
                        final ResilienceProperties props = context.getBean(ResilienceProperties.class);
                        assertThat(props.getRetry().getMaxAttempts()).isEqualTo(5);
                        assertThat(props.getRetry().getWaitDuration().toMillis()).isEqualTo(1000);
                        assertThat(props.getRetry().isEnableExponentialBackoff()).isFalse();
                        assertThat(props.getRetry().getExponentialBackoffMultiplier()).isEqualTo(3.0);
                    });
        }

        @Test
        @DisplayName("should bind sliding window type to TIME_BASED")
        void shouldBindSlidingWindowType() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class)
                    .withPropertyValues(
                            "framework.resilience.circuit-breaker.sliding-window-type=TIME_BASED"
                    )
                    .run(context -> {
                        final ResilienceProperties props = context.getBean(ResilienceProperties.class);
                        assertThat(props.getCircuitBreaker().getSlidingWindowType())
                                .isEqualTo(ResilienceProperties.SlidingWindowType.TIME_BASED);
                    });
        }
    }

    @Nested
    @DisplayName("Disabled configuration")
    class DisabledConfiguration {

        @Test
        @DisplayName("should not create beans when framework.resilience.enabled is explicitly false via ConditionalOnProperty")
        void shouldNotCreateBeansWhenDisabledViaProperty() {
            // Note: The @ConditionalOnProperty on the class matches "framework.resilience.enabled"
            // but doesn't have havingValue="true", so setting it to "false" will skip the config.
            // However, the property is just "enabled" under "framework.resilience", and the condition
            // uses matchIfMissing=true. Setting it to "false" means the string "false" — which
            // @ConditionalOnProperty without havingValue treats as falsy.
            new ApplicationContextRunner()
                    .withConfiguration(AutoConfigurations.of(ResilienceAutoConfiguration.class))
                    .withUserConfiguration(MeterRegistryConfig.class)
                    .withPropertyValues("framework.resilience.enabled=false")
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(CircuitBreakerRegistry.class);
                        assertThat(context).doesNotHaveBean(RetryRegistry.class);
                        assertThat(context).doesNotHaveBean(ResilientServiceInvoker.class);
                    });
        }
    }

    @Nested
    @DisplayName("Circuit breaker exception classification")
    class CircuitBreakerExceptionClassification {

        @Test
        @DisplayName("should not count NonRetryableException toward circuit breaker failure rate")
        void shouldNotCountNonRetryableExceptionAsFailure() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class)
                    .withPropertyValues(
                            "framework.resilience.circuit-breaker.sliding-window-size=5",
                            "framework.resilience.circuit-breaker.minimum-number-of-calls=5",
                            "framework.resilience.circuit-breaker.failure-rate-threshold=50"
                    )
                    .run(context -> {
                        final CircuitBreakerRegistry registry = context.getBean(CircuitBreakerRegistry.class);
                        final io.github.resilience4j.circuitbreaker.CircuitBreaker cb =
                                registry.circuitBreaker("cbExclusionTest");

                        // Throw NonRetryableException 5 times — should NOT trip the CB
                        for (int i = 0; i < 5; i++) {
                            try {
                                io.github.resilience4j.circuitbreaker.CircuitBreaker.decorateSupplier(cb, () -> {
                                    throw new TestNonRetryableException("business error");
                                }).get();
                            } catch (TestNonRetryableException ignored) {
                                // expected
                            }
                        }

                        // CB should still be CLOSED because NonRetryableException is excluded
                        assertThat(cb.getState())
                                .isEqualTo(io.github.resilience4j.circuitbreaker.CircuitBreaker.State.CLOSED);
                    });
        }

        @Test
        @DisplayName("should count regular exceptions toward circuit breaker failure rate")
        void shouldCountRegularExceptionsAsFailure() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class)
                    .withPropertyValues(
                            "framework.resilience.circuit-breaker.sliding-window-size=5",
                            "framework.resilience.circuit-breaker.minimum-number-of-calls=5",
                            "framework.resilience.circuit-breaker.failure-rate-threshold=50"
                    )
                    .run(context -> {
                        final CircuitBreakerRegistry registry = context.getBean(CircuitBreakerRegistry.class);
                        final io.github.resilience4j.circuitbreaker.CircuitBreaker cb =
                                registry.circuitBreaker("cbRegularTest");

                        // Throw regular RuntimeException 5 times — should trip the CB
                        for (int i = 0; i < 5; i++) {
                            try {
                                io.github.resilience4j.circuitbreaker.CircuitBreaker.decorateSupplier(cb, () -> {
                                    throw new RuntimeException("infrastructure error");
                                }).get();
                            } catch (RuntimeException ignored) {
                                // expected
                            }
                        }

                        // CB should be OPEN because 100% failure rate (>50% threshold)
                        assertThat(cb.getState())
                                .isEqualTo(io.github.resilience4j.circuitbreaker.CircuitBreaker.State.OPEN);
                    });
        }
    }

    @Nested
    @DisplayName("Retry configuration")
    class RetryConfiguration {

        @Test
        @DisplayName("should configure retry to ignore NonRetryableException subclasses")
        void shouldIgnoreNonRetryableExceptions() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class)
                    .run(context -> {
                        final RetryRegistry registry = context.getBean(RetryRegistry.class);
                        final io.github.resilience4j.retry.Retry retry = registry.retry("ignoreTest");
                        final java.util.concurrent.atomic.AtomicInteger attempts =
                                new java.util.concurrent.atomic.AtomicInteger(0);

                        try {
                            io.github.resilience4j.retry.Retry.decorateSupplier(retry, () -> {
                                attempts.incrementAndGet();
                                throw new TestNonRetryableException("not retryable");
                            }).get();
                        } catch (TestNonRetryableException ignored) {
                            // expected
                        }

                        // Should only have been called once — no retries
                        assertThat(attempts.get()).isEqualTo(1);
                    });
        }

        @Test
        @DisplayName("should create RetryEventListener bean by default")
        void shouldCreateRetryEventListenerBean() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(RetryEventListener.class);
                    });
        }
    }

    @Nested
    @DisplayName("Custom bean overrides")
    class CustomBeanOverrides {

        @Test
        @DisplayName("should not override existing CircuitBreakerRegistry bean")
        void shouldNotOverrideExistingCBRegistry() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class, CustomRegistryConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(CircuitBreakerRegistry.class);
                        // The custom one should be used (verified by checking it's the same instance)
                        assertThat(context.getBean(CircuitBreakerRegistry.class))
                                .isSameAs(context.getBean(CustomRegistryConfig.class).customCBRegistry);
                    });
        }

        @Test
        @DisplayName("should not override existing ResilientServiceInvoker bean")
        void shouldNotOverrideExistingInvoker() {
            contextRunner
                    .withUserConfiguration(MeterRegistryConfig.class, CustomInvokerConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(ResilientServiceInvoker.class);
                    });
        }
    }

    // ========== Test Configuration Classes ==========

    @Configuration
    static class MeterRegistryConfig {

        @Bean
        MeterRegistry meterRegistry() {
            return new SimpleMeterRegistry();
        }
    }

    @Configuration
    static class CustomRegistryConfig {

        final CircuitBreakerRegistry customCBRegistry = CircuitBreakerRegistry.ofDefaults();

        @Bean
        CircuitBreakerRegistry circuitBreakerRegistry() {
            return customCBRegistry;
        }
    }

    @Configuration
    static class CustomInvokerConfig {

        @Bean
        ResilientServiceInvoker resilientServiceInvoker() {
            return new ResilientServiceInvoker(
                    CircuitBreakerRegistry.ofDefaults(),
                    RetryRegistry.ofDefaults(),
                    new ResilienceProperties());
        }
    }

    // ========== Test Helpers ==========

    /**
     * Test exception that implements NonRetryableException for verifying retry filter config.
     */
    private static class TestNonRetryableException extends RuntimeException implements NonRetryableException {
        TestNonRetryableException(final String message) {
            super(message);
        }
    }
}
