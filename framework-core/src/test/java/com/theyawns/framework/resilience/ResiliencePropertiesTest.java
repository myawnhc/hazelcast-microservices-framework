package com.theyawns.framework.resilience;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import java.time.Duration;
import java.util.HashMap;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Tests for {@link ResilienceProperties} and its nested classes.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("ResilienceProperties - Configuration properties")
class ResiliencePropertiesTest {

    @Nested
    @DisplayName("Default values")
    class DefaultValues {

        @Test
        @DisplayName("should have resilience enabled by default")
        void shouldHaveResilienceEnabledByDefault() {
            final ResilienceProperties props = new ResilienceProperties();
            assertThat(props.isEnabled()).isTrue();
        }

        @Test
        @DisplayName("should have default circuit breaker properties")
        void shouldHaveDefaultCircuitBreakerProperties() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties().getCircuitBreaker();
            assertThat(cb.getFailureRateThreshold()).isEqualTo(50);
            assertThat(cb.getWaitDurationInOpenState()).isEqualTo(Duration.ofSeconds(10));
            assertThat(cb.getSlidingWindowSize()).isEqualTo(10);
            assertThat(cb.getSlidingWindowType())
                    .isEqualTo(ResilienceProperties.SlidingWindowType.COUNT_BASED);
            assertThat(cb.getMinimumNumberOfCalls()).isEqualTo(5);
            assertThat(cb.getPermittedNumberOfCallsInHalfOpenState()).isEqualTo(3);
        }

        @Test
        @DisplayName("should have default retry properties")
        void shouldHaveDefaultRetryProperties() {
            final ResilienceProperties.RetryProperties retry = new ResilienceProperties().getRetry();
            assertThat(retry.getMaxAttempts()).isEqualTo(3);
            assertThat(retry.getWaitDuration()).isEqualTo(Duration.ofMillis(500));
            assertThat(retry.isEnableExponentialBackoff()).isTrue();
            assertThat(retry.getExponentialBackoffMultiplier()).isEqualTo(2.0);
        }

        @Test
        @DisplayName("should have empty instances map by default")
        void shouldHaveEmptyInstancesMapByDefault() {
            final ResilienceProperties props = new ResilienceProperties();
            assertThat(props.getInstances()).isEmpty();
        }
    }

    @Nested
    @DisplayName("Circuit breaker property validation")
    class CircuitBreakerValidation {

        @Test
        @DisplayName("should reject failure rate threshold below 0")
        void shouldRejectFailureRateThresholdBelowZero() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties.CircuitBreakerProperties();
            assertThatThrownBy(() -> cb.setFailureRateThreshold(-1))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("failureRateThreshold must be between 0 and 100");
        }

        @Test
        @DisplayName("should reject failure rate threshold above 100")
        void shouldRejectFailureRateThresholdAbove100() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties.CircuitBreakerProperties();
            assertThatThrownBy(() -> cb.setFailureRateThreshold(101))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("failureRateThreshold must be between 0 and 100");
        }

        @Test
        @DisplayName("should accept failure rate threshold at boundaries")
        void shouldAcceptFailureRateThresholdAtBoundaries() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties.CircuitBreakerProperties();
            cb.setFailureRateThreshold(0);
            assertThat(cb.getFailureRateThreshold()).isEqualTo(0);
            cb.setFailureRateThreshold(100);
            assertThat(cb.getFailureRateThreshold()).isEqualTo(100);
        }

        @Test
        @DisplayName("should reject null wait duration in open state")
        void shouldRejectNullWaitDuration() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties.CircuitBreakerProperties();
            assertThatThrownBy(() -> cb.setWaitDurationInOpenState(null))
                    .isInstanceOf(NullPointerException.class);
        }

        @Test
        @DisplayName("should reject sliding window size below 1")
        void shouldRejectSlidingWindowSizeBelowOne() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties.CircuitBreakerProperties();
            assertThatThrownBy(() -> cb.setSlidingWindowSize(0))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("slidingWindowSize must be at least 1");
        }

        @Test
        @DisplayName("should reject null sliding window type")
        void shouldRejectNullSlidingWindowType() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties.CircuitBreakerProperties();
            assertThatThrownBy(() -> cb.setSlidingWindowType(null))
                    .isInstanceOf(NullPointerException.class);
        }

        @Test
        @DisplayName("should reject minimum number of calls below 1")
        void shouldRejectMinimumNumberOfCallsBelowOne() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties.CircuitBreakerProperties();
            assertThatThrownBy(() -> cb.setMinimumNumberOfCalls(0))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("minimumNumberOfCalls must be at least 1");
        }

        @Test
        @DisplayName("should reject permitted calls in half-open state below 1")
        void shouldRejectPermittedCallsInHalfOpenBelowOne() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties.CircuitBreakerProperties();
            assertThatThrownBy(() -> cb.setPermittedNumberOfCallsInHalfOpenState(0))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("permittedNumberOfCallsInHalfOpenState must be at least 1");
        }

        @Test
        @DisplayName("should accept valid sliding window type TIME_BASED")
        void shouldAcceptTimeBasedSlidingWindow() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties.CircuitBreakerProperties();
            cb.setSlidingWindowType(ResilienceProperties.SlidingWindowType.TIME_BASED);
            assertThat(cb.getSlidingWindowType())
                    .isEqualTo(ResilienceProperties.SlidingWindowType.TIME_BASED);
        }
    }

    @Nested
    @DisplayName("Retry property validation")
    class RetryValidation {

        @Test
        @DisplayName("should reject max attempts below 1")
        void shouldRejectMaxAttemptsBelowOne() {
            final ResilienceProperties.RetryProperties retry =
                    new ResilienceProperties.RetryProperties();
            assertThatThrownBy(() -> retry.setMaxAttempts(0))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("maxAttempts must be at least 1");
        }

        @Test
        @DisplayName("should reject null wait duration")
        void shouldRejectNullWaitDuration() {
            final ResilienceProperties.RetryProperties retry =
                    new ResilienceProperties.RetryProperties();
            assertThatThrownBy(() -> retry.setWaitDuration(null))
                    .isInstanceOf(NullPointerException.class);
        }

        @Test
        @DisplayName("should reject exponential backoff multiplier below 1.0")
        void shouldRejectMultiplierBelowOne() {
            final ResilienceProperties.RetryProperties retry =
                    new ResilienceProperties.RetryProperties();
            assertThatThrownBy(() -> retry.setExponentialBackoffMultiplier(0.5))
                    .isInstanceOf(IllegalArgumentException.class)
                    .hasMessageContaining("exponentialBackoffMultiplier must be at least 1.0");
        }

        @Test
        @DisplayName("should accept multiplier at boundary 1.0")
        void shouldAcceptMultiplierAtBoundary() {
            final ResilienceProperties.RetryProperties retry =
                    new ResilienceProperties.RetryProperties();
            retry.setExponentialBackoffMultiplier(1.0);
            assertThat(retry.getExponentialBackoffMultiplier()).isEqualTo(1.0);
        }

        @Test
        @DisplayName("should allow disabling exponential backoff")
        void shouldAllowDisablingExponentialBackoff() {
            final ResilienceProperties.RetryProperties retry =
                    new ResilienceProperties.RetryProperties();
            retry.setEnableExponentialBackoff(false);
            assertThat(retry.isEnableExponentialBackoff()).isFalse();
        }
    }

    @Nested
    @DisplayName("Per-instance overrides")
    class PerInstanceOverrides {

        @Test
        @DisplayName("should return default CB properties when no instance override")
        void shouldReturnDefaultCBWhenNoOverride() {
            final ResilienceProperties props = new ResilienceProperties();
            props.getCircuitBreaker().setFailureRateThreshold(60);

            final ResilienceProperties.CircuitBreakerProperties resolved =
                    props.getCircuitBreakerForInstance("orderSaga");
            assertThat(resolved.getFailureRateThreshold()).isEqualTo(60);
        }

        @Test
        @DisplayName("should return instance-specific CB properties when override exists")
        void shouldReturnInstanceCBWhenOverrideExists() {
            final ResilienceProperties props = new ResilienceProperties();
            props.getCircuitBreaker().setFailureRateThreshold(50);

            final ResilienceProperties.CircuitBreakerProperties customCB =
                    new ResilienceProperties.CircuitBreakerProperties();
            customCB.setFailureRateThreshold(70);

            final ResilienceProperties.InstanceProperties instanceProps =
                    new ResilienceProperties.InstanceProperties();
            instanceProps.setCircuitBreaker(customCB);

            final Map<String, ResilienceProperties.InstanceProperties> instances = new HashMap<>();
            instances.put("orderSaga", instanceProps);
            props.setInstances(instances);

            final ResilienceProperties.CircuitBreakerProperties resolved =
                    props.getCircuitBreakerForInstance("orderSaga");
            assertThat(resolved.getFailureRateThreshold()).isEqualTo(70);
        }

        @Test
        @DisplayName("should return default retry properties when no instance override")
        void shouldReturnDefaultRetryWhenNoOverride() {
            final ResilienceProperties props = new ResilienceProperties();
            props.getRetry().setMaxAttempts(5);

            final ResilienceProperties.RetryProperties resolved =
                    props.getRetryForInstance("paymentListener");
            assertThat(resolved.getMaxAttempts()).isEqualTo(5);
        }

        @Test
        @DisplayName("should return instance-specific retry properties when override exists")
        void shouldReturnInstanceRetryWhenOverrideExists() {
            final ResilienceProperties props = new ResilienceProperties();
            props.getRetry().setMaxAttempts(3);

            final ResilienceProperties.RetryProperties customRetry =
                    new ResilienceProperties.RetryProperties();
            customRetry.setMaxAttempts(7);

            final ResilienceProperties.InstanceProperties instanceProps =
                    new ResilienceProperties.InstanceProperties();
            instanceProps.setRetry(customRetry);

            final Map<String, ResilienceProperties.InstanceProperties> instances = new HashMap<>();
            instances.put("paymentListener", instanceProps);
            props.setInstances(instances);

            final ResilienceProperties.RetryProperties resolved =
                    props.getRetryForInstance("paymentListener");
            assertThat(resolved.getMaxAttempts()).isEqualTo(7);
        }

        @Test
        @DisplayName("should return default when instance has null CB override")
        void shouldReturnDefaultWhenInstanceHasNullCBOverride() {
            final ResilienceProperties props = new ResilienceProperties();
            props.getCircuitBreaker().setFailureRateThreshold(50);

            final ResilienceProperties.InstanceProperties instanceProps =
                    new ResilienceProperties.InstanceProperties();
            // CB is null by default

            final Map<String, ResilienceProperties.InstanceProperties> instances = new HashMap<>();
            instances.put("orderSaga", instanceProps);
            props.setInstances(instances);

            final ResilienceProperties.CircuitBreakerProperties resolved =
                    props.getCircuitBreakerForInstance("orderSaga");
            assertThat(resolved.getFailureRateThreshold()).isEqualTo(50);
        }
    }

    @Nested
    @DisplayName("Setters and null handling")
    class SettersAndNullHandling {

        @Test
        @DisplayName("should reject null circuit breaker properties")
        void shouldRejectNullCircuitBreakerProperties() {
            final ResilienceProperties props = new ResilienceProperties();
            assertThatThrownBy(() -> props.setCircuitBreaker(null))
                    .isInstanceOf(NullPointerException.class);
        }

        @Test
        @DisplayName("should reject null retry properties")
        void shouldRejectNullRetryProperties() {
            final ResilienceProperties props = new ResilienceProperties();
            assertThatThrownBy(() -> props.setRetry(null))
                    .isInstanceOf(NullPointerException.class);
        }

        @Test
        @DisplayName("should replace null instances map with empty map")
        void shouldReplaceNullInstancesMapWithEmpty() {
            final ResilienceProperties props = new ResilienceProperties();
            props.setInstances(null);
            assertThat(props.getInstances()).isNotNull().isEmpty();
        }

        @Test
        @DisplayName("should allow toggling enabled flag")
        void shouldAllowTogglingEnabledFlag() {
            final ResilienceProperties props = new ResilienceProperties();
            props.setEnabled(false);
            assertThat(props.isEnabled()).isFalse();
            props.setEnabled(true);
            assertThat(props.isEnabled()).isTrue();
        }
    }

    @Nested
    @DisplayName("toString")
    class ToStringTests {

        @Test
        @DisplayName("should include key information in ResilienceProperties toString")
        void shouldIncludeKeyInfoInToString() {
            final ResilienceProperties props = new ResilienceProperties();
            final String result = props.toString();
            assertThat(result).contains("enabled=true");
            assertThat(result).contains("instances=0");
        }

        @Test
        @DisplayName("should include key information in CircuitBreakerProperties toString")
        void shouldIncludeKeyInfoInCBToString() {
            final ResilienceProperties.CircuitBreakerProperties cb =
                    new ResilienceProperties.CircuitBreakerProperties();
            final String result = cb.toString();
            assertThat(result).contains("failureRateThreshold=50");
            assertThat(result).contains("slidingWindowSize=10");
        }

        @Test
        @DisplayName("should include key information in RetryProperties toString")
        void shouldIncludeKeyInfoInRetryToString() {
            final ResilienceProperties.RetryProperties retry =
                    new ResilienceProperties.RetryProperties();
            final String result = retry.toString();
            assertThat(result).contains("maxAttempts=3");
            assertThat(result).contains("enableExponentialBackoff=true");
        }

        @Test
        @DisplayName("should include key information in InstanceProperties toString")
        void shouldIncludeKeyInfoInInstanceToString() {
            final ResilienceProperties.InstanceProperties instance =
                    new ResilienceProperties.InstanceProperties();
            final String result = instance.toString();
            assertThat(result).contains("circuitBreaker=null");
            assertThat(result).contains("retry=null");
        }
    }
}
