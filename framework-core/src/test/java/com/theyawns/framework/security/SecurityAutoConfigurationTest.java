package com.theyawns.framework.security;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration;
import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration;
import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;
import org.springframework.boot.test.context.runner.WebApplicationContextRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link SecurityAutoConfiguration} and {@link PermitAllSecurityAutoConfiguration}.
 *
 * <p>Uses {@link WebApplicationContextRunner} to test auto-configuration behavior
 * in a servlet web application context without starting a full Spring context.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("SecurityAutoConfiguration - Auto-configuration behavior")
class SecurityAutoConfigurationTest {

    private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(
                    DispatcherServletAutoConfiguration.class,
                    WebMvcAutoConfiguration.class,
                    org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class,
                    SecurityFilterAutoConfiguration.class,
                    SecurityAutoConfiguration.class,
                    PermitAllSecurityAutoConfiguration.class
            ));

    @Nested
    @DisplayName("Disabled configuration (default)")
    class DisabledConfiguration {

        @Test
        @DisplayName("should create permit-all chain when property is absent")
        void shouldCreatePermitAllChainByDefault() {
            contextRunner.run(context -> {
                assertThat(context).hasSingleBean(SecurityFilterChain.class);
                assertThat(context).doesNotHaveBean(SecurityProperties.class);
            });
        }

        @Test
        @DisplayName("should create permit-all chain when explicitly disabled")
        void shouldCreatePermitAllChainWhenExplicitlyDisabled() {
            contextRunner
                    .withPropertyValues("framework.security.enabled=false")
                    .run(context -> {
                        assertThat(context).hasSingleBean(SecurityFilterChain.class);
                        assertThat(context).doesNotHaveBean(SecurityProperties.class);
                    });
        }
    }

    @Nested
    @DisplayName("Enabled configuration")
    class EnabledConfiguration {

        @Test
        @DisplayName("should create JWT-secured chain when enabled with JwtDecoder")
        void shouldCreateJwtSecuredChainWhenEnabled() {
            contextRunner
                    .withPropertyValues("framework.security.enabled=true")
                    .withUserConfiguration(MockJwtDecoderConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(SecurityFilterChain.class);
                        assertThat(context).hasSingleBean(SecurityProperties.class);
                    });
        }

        @Test
        @DisplayName("should bind SecurityProperties when enabled")
        void shouldBindSecurityPropertiesWhenEnabled() {
            contextRunner
                    .withPropertyValues("framework.security.enabled=true")
                    .withUserConfiguration(MockJwtDecoderConfig.class)
                    .run(context -> {
                        final SecurityProperties props = context.getBean(SecurityProperties.class);
                        assertThat(props.isEnabled()).isTrue();
                        assertThat(props.getPublicPaths()).containsExactly("/actuator/**");
                    });
        }
    }

    @Nested
    @DisplayName("Property binding")
    class PropertyBinding {

        @Test
        @DisplayName("should bind custom public paths")
        void shouldBindCustomPublicPaths() {
            contextRunner
                    .withPropertyValues(
                            "framework.security.enabled=true",
                            "framework.security.public-paths[0]=/health",
                            "framework.security.public-paths[1]=/info"
                    )
                    .withUserConfiguration(MockJwtDecoderConfig.class)
                    .run(context -> {
                        final SecurityProperties props = context.getBean(SecurityProperties.class);
                        assertThat(props.getPublicPaths()).containsExactly("/health", "/info");
                    });
        }

        @Test
        @DisplayName("should use default public paths when not overridden")
        void shouldUseDefaultPublicPaths() {
            contextRunner
                    .withPropertyValues("framework.security.enabled=true")
                    .withUserConfiguration(MockJwtDecoderConfig.class)
                    .run(context -> {
                        final SecurityProperties props = context.getBean(SecurityProperties.class);
                        assertThat(props.getPublicPaths()).containsExactly("/actuator/**");
                    });
        }
    }

    @Nested
    @DisplayName("Custom bean overrides")
    class CustomBeanOverrides {

        @Test
        @DisplayName("should not override existing SecurityFilterChain bean")
        void shouldNotOverrideExistingSecurityFilterChain() {
            contextRunner
                    .withPropertyValues("framework.security.enabled=false")
                    .withUserConfiguration(CustomSecurityChainConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(SecurityFilterChain.class);
                    });
        }
    }

    // ========== Test Configuration Classes ==========

    @Configuration
    static class MockJwtDecoderConfig {

        @Bean
        JwtDecoder jwtDecoder() {
            return token -> {
                throw new UnsupportedOperationException("mock JwtDecoder for testing");
            };
        }
    }

    @Configuration
    static class CustomSecurityChainConfig {

        @Bean
        SecurityFilterChain customSecurityFilterChain(final HttpSecurity http) throws Exception {
            http.authorizeHttpRequests(auth -> auth.anyRequest().permitAll());
            return http.build();
        }
    }
}
