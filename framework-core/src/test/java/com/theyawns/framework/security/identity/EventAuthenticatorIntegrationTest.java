package com.theyawns.framework.security.identity;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration tests for {@link EventAuthenticator}.
 *
 * <p>Tests the full wrap → transmit → unwrap cycle using real Hazelcast
 * {@link GenericRecord} objects. Two {@link ServiceIdentity} instances with
 * the same shared secret simulate cross-service communication; a third with
 * a different secret simulates an unauthorized service.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("EventAuthenticator - Integration")
class EventAuthenticatorIntegrationTest {

    private static final String SHARED_SECRET = "cross-service-shared-secret-key";
    private static final String DIFFERENT_SECRET = "completely-different-secret-key";
    private static final String EVENT_TYPE = "OrderCreated";

    // Service A (producer) and Service B (consumer) share the same secret
    private final ServiceIdentity serviceA = new ServiceIdentity("order-service", SHARED_SECRET);
    private final ServiceIdentity serviceB = new ServiceIdentity("inventory-service", SHARED_SECRET);

    // Service C has a different secret (unauthorized)
    private final ServiceIdentity serviceC = new ServiceIdentity("rogue-service", DIFFERENT_SECRET);

    private final EventAuthenticator producerAuth = new EventAuthenticator(serviceA);
    private final EventAuthenticator consumerAuth = new EventAuthenticator(serviceB);
    private final EventAuthenticator unauthorizedAuth = new EventAuthenticator(serviceC);

    private GenericRecord createTestEvent(final String eventId, final String source) {
        return GenericRecordBuilder.compact("TestDomainEvent")
                .setString("eventId", eventId)
                .setString("eventType", EVENT_TYPE)
                .setString("source", source)
                .setString("key", "order-42")
                .setString("sagaId", "saga-100")
                .setInt64("timestamp", System.currentTimeMillis())
                .build();
    }

    @Nested
    @DisplayName("Cross-service communication (same shared secret)")
    class CrossServiceCommunication {

        @Test
        @DisplayName("should wrap event with service A and unwrap/verify with service B")
        void shouldWrapAndUnwrapAcrossServices() {
            final GenericRecord event = createTestEvent("evt-int-001", "order-service");

            // Service A wraps
            final GenericRecord envelope = producerAuth.wrapWithAuthentication(event, EVENT_TYPE);
            assertThat(EventAuthenticator.isEnvelope(envelope)).isTrue();
            assertThat(envelope.getString(EventAuthenticator.FIELD_SOURCE_SERVICE)).isEqualTo("order-service");

            // Service B unwraps and verifies — same secret, should succeed
            final GenericRecord unwrapped = consumerAuth.unwrapAndVerify(envelope);
            assertThat(unwrapped).isNotNull();
            assertThat(unwrapped.getString("eventId")).isEqualTo("evt-int-001");
            assertThat(unwrapped.getString("source")).isEqualTo("order-service");
            assertThat(unwrapped.getString("key")).isEqualTo("order-42");
            assertThat(unwrapped.getString("sagaId")).isEqualTo("saga-100");
        }

        @Test
        @DisplayName("should preserve all event fields through full wrap/unwrap cycle")
        void shouldPreserveAllFields() {
            final GenericRecord event = createTestEvent("evt-int-002", "order-service");
            final long originalTimestamp = event.getInt64("timestamp");

            final GenericRecord envelope = producerAuth.wrapWithAuthentication(event, EVENT_TYPE);
            final GenericRecord unwrapped = consumerAuth.unwrapAndVerify(envelope);

            assertThat(unwrapped.getString("eventId")).isEqualTo("evt-int-002");
            assertThat(unwrapped.getString("eventType")).isEqualTo(EVENT_TYPE);
            assertThat(unwrapped.getString("source")).isEqualTo("order-service");
            assertThat(unwrapped.getString("key")).isEqualTo("order-42");
            assertThat(unwrapped.getString("sagaId")).isEqualTo("saga-100");
            assertThat(unwrapped.getInt64("timestamp")).isEqualTo(originalTimestamp);
        }

        @Test
        @DisplayName("should handle multiple events in sequence")
        void shouldHandleMultipleEvents() {
            for (int i = 1; i <= 5; i++) {
                final String eventId = "evt-seq-" + i;
                final GenericRecord event = createTestEvent(eventId, "order-service");
                final GenericRecord envelope = producerAuth.wrapWithAuthentication(event, EVENT_TYPE);
                final GenericRecord unwrapped = consumerAuth.unwrapAndVerify(envelope);
                assertThat(unwrapped.getString("eventId")).isEqualTo(eventId);
            }
        }
    }

    @Nested
    @DisplayName("Tampered signature detection")
    class TamperedSignatureDetection {

        @Test
        @DisplayName("should warn when signature is from a different secret (warn-only mode)")
        void shouldWarnOnDifferentSecret() {
            final GenericRecord event = createTestEvent("evt-int-003", "order-service");

            // Service A wraps with its secret
            final GenericRecord envelope = producerAuth.wrapWithAuthentication(event, EVENT_TYPE);

            // Service C (different secret) tries to unwrap — should warn but return payload
            final GenericRecord result = unauthorizedAuth.unwrapAndVerify(envelope);
            assertThat(result).isNotNull();
            assertThat(result.getString("eventId")).isEqualTo("evt-int-003");
        }

        @Test
        @DisplayName("should detect tampered payload by rebuilding envelope with modified event")
        void shouldDetectTamperedPayload() {
            final GenericRecord originalEvent = createTestEvent("evt-int-004", "order-service");
            final GenericRecord envelope = producerAuth.wrapWithAuthentication(originalEvent, EVENT_TYPE);

            // Create a tampered event with different eventId
            final GenericRecord tamperedEvent = GenericRecordBuilder.compact("TestDomainEvent")
                    .setString("eventId", "evt-TAMPERED")
                    .setString("eventType", EVENT_TYPE)
                    .setString("source", "order-service")
                    .setString("key", "order-42")
                    .setString("sagaId", "saga-100")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .build();

            // Build a new envelope with the original signature but tampered payload
            final GenericRecord tamperedEnvelope = GenericRecordBuilder.compact(EventAuthenticator.ENVELOPE_SCHEMA)
                    .setString(EventAuthenticator.FIELD_SOURCE_SERVICE,
                            envelope.getString(EventAuthenticator.FIELD_SOURCE_SERVICE))
                    .setString(EventAuthenticator.FIELD_EVENT_SIGNATURE,
                            envelope.getString(EventAuthenticator.FIELD_EVENT_SIGNATURE))
                    .setInt64(EventAuthenticator.FIELD_SIGNED_AT,
                            envelope.getInt64(EventAuthenticator.FIELD_SIGNED_AT))
                    .setString(EventAuthenticator.FIELD_EVENT_TYPE,
                            envelope.getString(EventAuthenticator.FIELD_EVENT_TYPE))
                    .setGenericRecord(EventAuthenticator.FIELD_PAYLOAD, tamperedEvent)
                    .build();

            // Consumer should detect the mismatch (warn-only mode returns payload anyway)
            final GenericRecord result = consumerAuth.unwrapAndVerify(tamperedEnvelope);
            assertThat(result).isNotNull();
            // Payload is returned even though signature is invalid (warn-only)
            assertThat(result.getString("eventId")).isEqualTo("evt-TAMPERED");
        }
    }

    @Nested
    @DisplayName("Backward compatibility")
    class BackwardCompatibility {

        @Test
        @DisplayName("should pass through raw event unchanged when not an envelope")
        void shouldPassThroughRawEvent() {
            final GenericRecord rawEvent = createTestEvent("evt-int-005", "legacy-service");

            // Consumer receives a raw event (service didn't have identity configured)
            final GenericRecord result = consumerAuth.unwrapAndVerify(rawEvent);

            assertThat(result.getString("eventId")).isEqualTo("evt-int-005");
            assertThat(result.getString("source")).isEqualTo("legacy-service");
        }

        @Test
        @DisplayName("should not detect raw event as envelope")
        void shouldNotDetectRawEventAsEnvelope() {
            final GenericRecord rawEvent = createTestEvent("evt-int-006", "legacy-service");
            assertThat(EventAuthenticator.isEnvelope(rawEvent)).isFalse();
        }
    }

    @Nested
    @DisplayName("Null payload handling")
    class NullPayloadHandling {

        @Test
        @DisplayName("should return raw record when envelope has null payload")
        void shouldReturnRawRecordWhenNullPayload() {
            // Manually build an envelope with null payload (simulates corrupt data)
            final GenericRecord envelopeWithNullPayload = GenericRecordBuilder.compact(EventAuthenticator.ENVELOPE_SCHEMA)
                    .setString(EventAuthenticator.FIELD_SOURCE_SERVICE, "bad-service")
                    .setString(EventAuthenticator.FIELD_EVENT_SIGNATURE, "some-signature")
                    .setInt64(EventAuthenticator.FIELD_SIGNED_AT, System.currentTimeMillis())
                    .setString(EventAuthenticator.FIELD_EVENT_TYPE, EVENT_TYPE)
                    .setGenericRecord(EventAuthenticator.FIELD_PAYLOAD, null)
                    .build();

            // Should log a warning and return the raw envelope record
            final GenericRecord result = consumerAuth.unwrapAndVerify(envelopeWithNullPayload);
            assertThat(result).isNotNull();
            // The raw envelope itself is returned since payload is null
            assertThat(result.getString(EventAuthenticator.FIELD_SOURCE_SERVICE)).isEqualTo("bad-service");
        }
    }

    @Nested
    @DisplayName("Envelope metadata")
    class EnvelopeMetadata {

        @Test
        @DisplayName("should include correct source service in envelope")
        void shouldIncludeCorrectSourceService() {
            final GenericRecord event = createTestEvent("evt-int-007", "order-service");
            final GenericRecord envelope = producerAuth.wrapWithAuthentication(event, EVENT_TYPE);
            assertThat(envelope.getString(EventAuthenticator.FIELD_SOURCE_SERVICE)).isEqualTo("order-service");
        }

        @Test
        @DisplayName("should include event type in envelope")
        void shouldIncludeEventType() {
            final GenericRecord event = createTestEvent("evt-int-008", "order-service");
            final GenericRecord envelope = producerAuth.wrapWithAuthentication(event, "StockReserved");
            assertThat(envelope.getString(EventAuthenticator.FIELD_EVENT_TYPE)).isEqualTo("StockReserved");
        }

        @Test
        @DisplayName("should include signing timestamp in envelope")
        void shouldIncludeSigningTimestamp() {
            final long before = System.currentTimeMillis();
            final GenericRecord event = createTestEvent("evt-int-009", "order-service");
            final GenericRecord envelope = producerAuth.wrapWithAuthentication(event, EVENT_TYPE);
            final long after = System.currentTimeMillis();

            final long signedAt = envelope.getInt64(EventAuthenticator.FIELD_SIGNED_AT);
            assertThat(signedAt).isBetween(before, after);
        }

        @Test
        @DisplayName("should produce non-blank signature in envelope")
        void shouldProduceNonBlankSignature() {
            final GenericRecord event = createTestEvent("evt-int-010", "order-service");
            final GenericRecord envelope = producerAuth.wrapWithAuthentication(event, EVENT_TYPE);
            assertThat(envelope.getString(EventAuthenticator.FIELD_EVENT_SIGNATURE)).isNotBlank();
        }
    }
}
