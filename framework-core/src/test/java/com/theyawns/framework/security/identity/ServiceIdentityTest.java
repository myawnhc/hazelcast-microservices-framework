package com.theyawns.framework.security.identity;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Unit tests for {@link ServiceIdentity}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("ServiceIdentity - HMAC signing and verification")
class ServiceIdentityTest {

    private static final String SERVICE_NAME = "test-service";
    private static final String SHARED_SECRET = "test-secret-key-for-hmac-256";

    private ServiceIdentity identity;

    @BeforeEach
    void setUp() {
        identity = new ServiceIdentity(SERVICE_NAME, SHARED_SECRET);
    }

    @Test
    @DisplayName("should return configured service name")
    void shouldReturnServiceName() {
        assertThat(identity.getServiceName()).isEqualTo(SERVICE_NAME);
    }

    @Test
    @DisplayName("should produce consistent HMAC for same data")
    void shouldProduceConsistentHmac() {
        final String data = "event-123|OrderCreated|order-service";
        final String signature1 = identity.sign(data);
        final String signature2 = identity.sign(data);

        assertThat(signature1).isNotNull().isNotBlank();
        assertThat(signature1).isEqualTo(signature2);
    }

    @Test
    @DisplayName("should produce different HMAC for different data")
    void shouldProduceDifferentHmacForDifferentData() {
        final String sig1 = identity.sign("data-1");
        final String sig2 = identity.sign("data-2");

        assertThat(sig1).isNotEqualTo(sig2);
    }

    @Test
    @DisplayName("should produce different HMAC with different secret")
    void shouldProduceDifferentHmacWithDifferentSecret() {
        final ServiceIdentity other = new ServiceIdentity("other-service", "different-secret");
        final String data = "same-data";

        final String sig1 = identity.sign(data);
        final String sig2 = other.sign(data);

        assertThat(sig1).isNotEqualTo(sig2);
    }

    @Test
    @DisplayName("should verify valid signature")
    void shouldVerifyValidSignature() {
        final String data = "event-456|StockReserved|inventory-service";
        final String signature = identity.sign(data);

        assertThat(identity.verify(data, signature)).isTrue();
    }

    @Test
    @DisplayName("should reject invalid signature")
    void shouldRejectInvalidSignature() {
        final String data = "event-789|PaymentProcessed|payment-service";
        final String invalidSignature = "dGhpcyBpcyBub3QgYSB2YWxpZCBzaWduYXR1cmU=";

        assertThat(identity.verify(data, invalidSignature)).isFalse();
    }

    @Test
    @DisplayName("should reject signature from different secret")
    void shouldRejectSignatureFromDifferentSecret() {
        final ServiceIdentity other = new ServiceIdentity("other", "different-key");
        final String data = "some-data";
        final String otherSignature = other.sign(data);

        assertThat(identity.verify(data, otherSignature)).isFalse();
    }

    @Test
    @DisplayName("should verify across identical identities with same secret")
    void shouldVerifyAcrossIdenticalSecrets() {
        final ServiceIdentity producer = new ServiceIdentity("producer", SHARED_SECRET);
        final ServiceIdentity consumer = new ServiceIdentity("consumer", SHARED_SECRET);
        final String data = "cross-service-data";

        final String signature = producer.sign(data);
        assertThat(consumer.verify(data, signature)).isTrue();
    }

    @Test
    @DisplayName("should produce Base64-encoded signature")
    void shouldProduceBase64EncodedSignature() {
        final String signature = identity.sign("test-data");
        // Base64 characters: A-Z, a-z, 0-9, +, /, =
        assertThat(signature).matches("[A-Za-z0-9+/=]+");
    }

    @Test
    @DisplayName("should throw on null service name")
    void shouldThrowOnNullServiceName() {
        assertThatThrownBy(() -> new ServiceIdentity(null, SHARED_SECRET))
                .isInstanceOf(NullPointerException.class);
    }

    @Test
    @DisplayName("should throw on null shared secret")
    void shouldThrowOnNullSharedSecret() {
        assertThatThrownBy(() -> new ServiceIdentity(SERVICE_NAME, null))
                .isInstanceOf(NullPointerException.class);
    }

    @Test
    @DisplayName("should throw on null sign data")
    void shouldThrowOnNullSignData() {
        assertThatThrownBy(() -> identity.sign(null))
                .isInstanceOf(NullPointerException.class);
    }

    @Test
    @DisplayName("should throw on null verify data")
    void shouldThrowOnNullVerifyData() {
        assertThatThrownBy(() -> identity.verify(null, "sig"))
                .isInstanceOf(NullPointerException.class);
    }

    @Test
    @DisplayName("should throw on null verify signature")
    void shouldThrowOnNullVerifySignature() {
        assertThatThrownBy(() -> identity.verify("data", null))
                .isInstanceOf(NullPointerException.class);
    }

    @Test
    @DisplayName("toString should not expose secret")
    void toStringShouldNotExposeSecret() {
        final String str = identity.toString();
        assertThat(str).contains(SERVICE_NAME);
        assertThat(str).doesNotContain(SHARED_SECRET);
    }
}
