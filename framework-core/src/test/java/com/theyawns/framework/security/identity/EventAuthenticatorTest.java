package com.theyawns.framework.security.identity;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Unit tests for {@link EventAuthenticator}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("EventAuthenticator - Event envelope wrapping and verification")
class EventAuthenticatorTest {

    private static final String SERVICE_NAME = "order-service";
    private static final String SHARED_SECRET = "test-secret-key-for-hmac";
    private static final String EVENT_TYPE = "OrderCreated";

    private ServiceIdentity serviceIdentity;
    private EventAuthenticator authenticator;

    @BeforeEach
    void setUp() {
        serviceIdentity = new ServiceIdentity(SERVICE_NAME, SHARED_SECRET);
        authenticator = new EventAuthenticator(serviceIdentity);
    }

    private GenericRecord createTestEvent(final String eventId, final String source) {
        return GenericRecordBuilder.compact("TestEvent")
                .setString("eventId", eventId)
                .setString("eventType", EVENT_TYPE)
                .setString("source", source)
                .setString("key", "order-001")
                .setString("sagaId", "saga-123")
                .build();
    }

    @Test
    @DisplayName("should wrap event in authenticated envelope")
    void shouldWrapEventInEnvelope() {
        final GenericRecord event = createTestEvent("evt-001", SERVICE_NAME);
        final GenericRecord envelope = authenticator.wrapWithAuthentication(event, EVENT_TYPE);

        assertThat(envelope).isNotNull();
        assertThat(envelope.getString(EventAuthenticator.FIELD_SOURCE_SERVICE)).isEqualTo(SERVICE_NAME);
        assertThat(envelope.getString(EventAuthenticator.FIELD_EVENT_TYPE)).isEqualTo(EVENT_TYPE);
        assertThat(envelope.getString(EventAuthenticator.FIELD_EVENT_SIGNATURE)).isNotBlank();
        assertThat(envelope.getInt64(EventAuthenticator.FIELD_SIGNED_AT)).isGreaterThan(0);
        assertThat(envelope.getGenericRecord(EventAuthenticator.FIELD_PAYLOAD)).isNotNull();
    }

    @Test
    @DisplayName("should unwrap and verify valid envelope")
    void shouldUnwrapAndVerifyValidEnvelope() {
        final GenericRecord event = createTestEvent("evt-002", SERVICE_NAME);
        final GenericRecord envelope = authenticator.wrapWithAuthentication(event, EVENT_TYPE);

        final GenericRecord unwrapped = authenticator.unwrapAndVerify(envelope);

        assertThat(unwrapped).isNotNull();
        assertThat(unwrapped.getString("eventId")).isEqualTo("evt-002");
        assertThat(unwrapped.getString("source")).isEqualTo(SERVICE_NAME);
        assertThat(unwrapped.getString("key")).isEqualTo("order-001");
    }

    @Test
    @DisplayName("should pass through raw event when not an envelope")
    void shouldPassThroughRawEvent() {
        final GenericRecord rawEvent = createTestEvent("evt-003", SERVICE_NAME);

        final GenericRecord result = authenticator.unwrapAndVerify(rawEvent);

        // Should return the same record (not an envelope, so pass-through)
        assertThat(result.getString("eventId")).isEqualTo("evt-003");
        assertThat(result.getString("source")).isEqualTo(SERVICE_NAME);
    }

    @Test
    @DisplayName("should detect envelope correctly")
    void shouldDetectEnvelope() {
        final GenericRecord event = createTestEvent("evt-004", SERVICE_NAME);
        final GenericRecord envelope = authenticator.wrapWithAuthentication(event, EVENT_TYPE);

        assertThat(EventAuthenticator.isEnvelope(envelope)).isTrue();
        assertThat(EventAuthenticator.isEnvelope(event)).isFalse();
    }

    @Test
    @DisplayName("should handle null record in isEnvelope")
    void shouldHandleNullInIsEnvelope() {
        assertThat(EventAuthenticator.isEnvelope(null)).isFalse();
    }

    @Test
    @DisplayName("should verify event signed by same secret")
    void shouldVerifyEventSignedBySameSecret() {
        // Producer and consumer share the same secret
        final ServiceIdentity producer = new ServiceIdentity("producer-service", SHARED_SECRET);
        final ServiceIdentity consumer = new ServiceIdentity("consumer-service", SHARED_SECRET);
        final EventAuthenticator producerAuth = new EventAuthenticator(producer);
        final EventAuthenticator consumerAuth = new EventAuthenticator(consumer);

        final GenericRecord event = createTestEvent("evt-005", "producer-service");
        final GenericRecord envelope = producerAuth.wrapWithAuthentication(event, EVENT_TYPE);

        // Consumer should be able to unwrap and verify
        final GenericRecord unwrapped = consumerAuth.unwrapAndVerify(envelope);
        assertThat(unwrapped.getString("eventId")).isEqualTo("evt-005");
    }

    @Test
    @DisplayName("should log warning for invalid signature but still return payload")
    void shouldLogWarningForInvalidSignatureButReturnPayload() {
        // Create envelope with one secret
        final ServiceIdentity producer = new ServiceIdentity("producer", "secret-A");
        final EventAuthenticator producerAuth = new EventAuthenticator(producer);
        final GenericRecord event = createTestEvent("evt-006", "producer");
        final GenericRecord envelope = producerAuth.wrapWithAuthentication(event, EVENT_TYPE);

        // Verify with different secret â€” should warn but still return payload
        final ServiceIdentity consumer = new ServiceIdentity("consumer", "secret-B");
        final EventAuthenticator consumerAuth = new EventAuthenticator(consumer);
        final GenericRecord result = consumerAuth.unwrapAndVerify(envelope);

        // Payload should still be returned (warn-only mode)
        assertThat(result.getString("eventId")).isEqualTo("evt-006");
    }

    @Test
    @DisplayName("should preserve all event fields through wrap/unwrap cycle")
    void shouldPreserveAllFieldsThroughCycle() {
        final GenericRecord event = createTestEvent("evt-007", SERVICE_NAME);
        final GenericRecord envelope = authenticator.wrapWithAuthentication(event, EVENT_TYPE);
        final GenericRecord unwrapped = authenticator.unwrapAndVerify(envelope);

        assertThat(unwrapped.getString("eventId")).isEqualTo("evt-007");
        assertThat(unwrapped.getString("eventType")).isEqualTo(EVENT_TYPE);
        assertThat(unwrapped.getString("source")).isEqualTo(SERVICE_NAME);
        assertThat(unwrapped.getString("key")).isEqualTo("order-001");
        assertThat(unwrapped.getString("sagaId")).isEqualTo("saga-123");
    }

    @Test
    @DisplayName("should throw on null event in wrapWithAuthentication")
    void shouldThrowOnNullEvent() {
        assertThatThrownBy(() -> authenticator.wrapWithAuthentication(null, EVENT_TYPE))
                .isInstanceOf(NullPointerException.class);
    }

    @Test
    @DisplayName("should throw on null eventType in wrapWithAuthentication")
    void shouldThrowOnNullEventType() {
        final GenericRecord event = createTestEvent("evt-008", SERVICE_NAME);
        assertThatThrownBy(() -> authenticator.wrapWithAuthentication(event, null))
                .isInstanceOf(NullPointerException.class);
    }

    @Test
    @DisplayName("should throw on null record in unwrapAndVerify")
    void shouldThrowOnNullRecordInUnwrap() {
        assertThatThrownBy(() -> authenticator.unwrapAndVerify(null))
                .isInstanceOf(NullPointerException.class);
    }

    @Test
    @DisplayName("should throw on null serviceIdentity in constructor")
    void shouldThrowOnNullServiceIdentity() {
        assertThatThrownBy(() -> new EventAuthenticator(null))
                .isInstanceOf(NullPointerException.class);
    }
}
