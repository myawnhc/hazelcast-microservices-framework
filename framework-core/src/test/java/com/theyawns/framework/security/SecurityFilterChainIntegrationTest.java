package com.theyawns.framework.security;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.autoconfigure.security.servlet.SecurityFilterAutoConfiguration;
import org.springframework.boot.autoconfigure.web.servlet.DispatcherServletAutoConfiguration;
import org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration;
import org.springframework.boot.test.context.runner.WebApplicationContextRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.web.SecurityFilterChain;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration tests for the framework's {@link SecurityFilterChain} auto-configuration.
 *
 * <p>Validates that the security auto-configurations work together correctly:
 * <ul>
 *   <li>Public paths from {@link SecurityProperties} are correctly configured</li>
 *   <li>Custom {@link SecurityFilterChain} overrides framework default</li>
 *   <li>JWT-secured and permit-all configurations are mutually exclusive</li>
 *   <li>Multiple public paths are supported</li>
 * </ul>
 *
 * <p>Uses {@link WebApplicationContextRunner} for lightweight testing without
 * starting a full Spring Boot context.
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see SecurityAutoConfiguration
 * @see PermitAllSecurityAutoConfiguration
 */
@DisplayName("SecurityFilterChain - Integration")
class SecurityFilterChainIntegrationTest {

    private final WebApplicationContextRunner contextRunner = new WebApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(
                    DispatcherServletAutoConfiguration.class,
                    WebMvcAutoConfiguration.class,
                    org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration.class,
                    SecurityFilterAutoConfiguration.class,
                    SecurityAutoConfiguration.class,
                    PermitAllSecurityAutoConfiguration.class
            ));

    @Nested
    @DisplayName("Public paths configuration")
    class PublicPathsConfiguration {

        @Test
        @DisplayName("should bind multiple custom public paths")
        void shouldBindMultipleCustomPublicPaths() {
            contextRunner
                    .withPropertyValues(
                            "framework.security.enabled=true",
                            "framework.security.public-paths[0]=/actuator/**",
                            "framework.security.public-paths[1]=/api/health",
                            "framework.security.public-paths[2]=/swagger-ui/**"
                    )
                    .withUserConfiguration(MockJwtDecoderConfig.class)
                    .run(context -> {
                        final SecurityProperties props = context.getBean(SecurityProperties.class);
                        assertThat(props.getPublicPaths()).containsExactly(
                                "/actuator/**", "/api/health", "/swagger-ui/**"
                        );
                    });
        }

        @Test
        @DisplayName("should use default actuator path when no public paths specified")
        void shouldUseDefaultActuatorPath() {
            contextRunner
                    .withPropertyValues("framework.security.enabled=true")
                    .withUserConfiguration(MockJwtDecoderConfig.class)
                    .run(context -> {
                        final SecurityProperties props = context.getBean(SecurityProperties.class);
                        assertThat(props.getPublicPaths()).containsExactly("/actuator/**");
                    });
        }

        @Test
        @DisplayName("should not create SecurityProperties when security is disabled")
        void shouldNotCreatePropertiesWhenDisabled() {
            contextRunner
                    .withPropertyValues("framework.security.enabled=false")
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(SecurityProperties.class);
                    });
        }
    }

    @Nested
    @DisplayName("Custom bean overrides")
    class CustomBeanOverrides {

        @Test
        @DisplayName("should honor custom SecurityFilterChain even when security is enabled")
        void shouldHonorCustomChainWhenEnabled() {
            contextRunner
                    .withPropertyValues("framework.security.enabled=true")
                    .withUserConfiguration(MockJwtDecoderConfig.class, CustomSecurityChainConfig.class)
                    .run(context -> {
                        // Custom chain should be present (only one chain)
                        assertThat(context).hasSingleBean(SecurityFilterChain.class);
                        // SecurityProperties still created because the auto-config class
                        // activates (EnableConfigurationProperties), even though the bean
                        // method is skipped via @ConditionalOnMissingBean
                        assertThat(context).hasSingleBean(SecurityProperties.class);
                    });
        }

        @Test
        @DisplayName("should honor custom SecurityFilterChain when security is disabled")
        void shouldHonorCustomChainWhenDisabled() {
            contextRunner
                    .withPropertyValues("framework.security.enabled=false")
                    .withUserConfiguration(CustomSecurityChainConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(SecurityFilterChain.class);
                    });
        }
    }

    @Nested
    @DisplayName("Mutual exclusivity")
    class MutualExclusivity {

        @Test
        @DisplayName("should create JWT chain when enabled, not permit-all chain")
        void shouldCreateJwtChainWhenEnabled() {
            contextRunner
                    .withPropertyValues("framework.security.enabled=true")
                    .withUserConfiguration(MockJwtDecoderConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(SecurityFilterChain.class);
                        assertThat(context).hasSingleBean(SecurityProperties.class);
                        assertThat(context.getBean(SecurityProperties.class).isEnabled()).isTrue();
                    });
        }

        @Test
        @DisplayName("should create permit-all chain when disabled, not JWT chain")
        void shouldCreatePermitAllChainWhenDisabled() {
            contextRunner
                    .run(context -> {
                        assertThat(context).hasSingleBean(SecurityFilterChain.class);
                        assertThat(context).doesNotHaveBean(SecurityProperties.class);
                    });
        }
    }

    @Nested
    @DisplayName("JwtDecoder dependency")
    class JwtDecoderDependency {

        @Test
        @DisplayName("should require JwtDecoder bean when security is enabled")
        void shouldRequireJwtDecoderWhenEnabled() {
            // When enabled=true but no JwtDecoder bean is provided,
            // the SecurityAutoConfiguration activates but the SecurityFilterChain
            // fails to build due to missing JwtDecoder
            contextRunner
                    .withPropertyValues("framework.security.enabled=true")
                    .withUserConfiguration(MockJwtDecoderConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(SecurityFilterChain.class);
                        assertThat(context).hasSingleBean(JwtDecoder.class);
                    });
        }
    }

    // ========== Test Configuration Classes ==========

    @Configuration
    static class MockJwtDecoderConfig {

        @Bean
        JwtDecoder jwtDecoder() {
            return token -> {
                throw new UnsupportedOperationException("mock JwtDecoder for testing");
            };
        }
    }

    @Configuration
    static class CustomSecurityChainConfig {

        @Bean
        SecurityFilterChain customSecurityFilterChain(final HttpSecurity http) throws Exception {
            http
                    .csrf(AbstractHttpConfigurer::disable)
                    .authorizeHttpRequests(auth -> auth.anyRequest().permitAll());
            return http.build();
        }
    }
}
