package com.theyawns.framework.config;

import com.hazelcast.config.Config;
import com.hazelcast.core.HazelcastInstance;
import com.theyawns.framework.edition.EditionAutoConfiguration;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.test.context.runner.ApplicationContextRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link HazelcastFeatureAutoConfiguration}.
 *
 * <p>Uses {@link ApplicationContextRunner} to validate that customizer beans
 * are created/suppressed based on Enterprise Edition detection and feature flags.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("HazelcastFeatureAutoConfiguration - Enterprise feature customizer beans")
class HazelcastFeatureAutoConfigurationTest {

    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(
                    EditionAutoConfiguration.class,
                    HazelcastFeatureAutoConfiguration.class
            ));

    @Nested
    @DisplayName("Community Edition (no license)")
    class CommunityEdition {

        @Test
        @DisplayName("should not create any customizer beans")
        void shouldNotCreateCustomizerBeans() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues(
                            "framework.edition.license.env-var=NONEXISTENT_TEST_LICENSE_VAR_12345"
                    )
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(HazelcastConfigCustomizer.class);
                        assertThat(context).doesNotHaveBean(HazelcastClientConfigCustomizer.class);
                    });
        }
    }

    @Nested
    @DisplayName("Explicitly disabled features")
    class DisabledFeatures {

        @Test
        @DisplayName("should not create HD Memory customizer when explicitly disabled")
        void shouldNotCreateHdMemoryWhenDisabled() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues(
                            "framework.edition.license.env-var=NONEXISTENT_TEST_LICENSE_VAR_12345",
                            "framework.features.hd-memory.enabled=false"
                    )
                    .run(context -> {
                        assertThat(context).doesNotHaveBean("hdMemoryConfigCustomizer");
                    });
        }

        @Test
        @DisplayName("should not create TPC customizers when explicitly disabled")
        void shouldNotCreateTpcWhenDisabled() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues(
                            "framework.edition.license.env-var=NONEXISTENT_TEST_LICENSE_VAR_12345",
                            "framework.features.thread-per-core.enabled=false"
                    )
                    .run(context -> {
                        assertThat(context).doesNotHaveBean("tpcConfigCustomizer");
                        assertThat(context).doesNotHaveBean("tpcClientConfigCustomizer");
                    });
        }
    }

    @Nested
    @DisplayName("Property binding for feature settings")
    class PropertyBinding {

        @Test
        @DisplayName("should bind HD Memory capacity and allocator from properties")
        void shouldBindHdMemoryProperties() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues(
                            "framework.edition.license.env-var=NONEXISTENT_TEST_LICENSE_VAR_12345",
                            "framework.features.hd-memory.capacity-mb=2048",
                            "framework.features.hd-memory.allocator-type=STANDARD"
                    )
                    .run(context -> {
                        final var props = context.getBean(
                                com.theyawns.framework.edition.EditionProperties.class);
                        assertThat(props.getFeatures().getHdMemory().getCapacityMb()).isEqualTo(2048);
                        assertThat(props.getFeatures().getHdMemory().getAllocatorType()).isEqualTo("STANDARD");
                    });
        }

        @Test
        @DisplayName("should bind TPC eventloop count and client enabled from properties")
        void shouldBindTpcProperties() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues(
                            "framework.edition.license.env-var=NONEXISTENT_TEST_LICENSE_VAR_12345",
                            "framework.features.tpc.eventloop-count=8",
                            "framework.features.tpc.client-enabled=false"
                    )
                    .run(context -> {
                        final var props = context.getBean(
                                com.theyawns.framework.edition.EditionProperties.class);
                        assertThat(props.getFeatures().getTpc().getEventloopCount()).isEqualTo(8);
                        assertThat(props.getFeatures().getTpc().isClientEnabled()).isFalse();
                    });
        }
    }

    // ========== Test Configuration Classes ==========

    @Configuration
    static class HazelcastConfig {

        @Bean
        HazelcastInstance hazelcastInstance() {
            final HazelcastInstance mock = mock(HazelcastInstance.class);
            // Use real Config (not mockable on Java 25 with Mockito inline)
            final Config config = new Config();
            when(mock.getConfig()).thenReturn(config);
            return mock;
        }
    }
}
