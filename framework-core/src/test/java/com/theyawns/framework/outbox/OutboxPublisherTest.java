package com.theyawns.framework.outbox;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.hazelcast.topic.ITopic;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.Collections;
import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.contains;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.doReturn;
import static org.mockito.Mockito.doThrow;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link OutboxPublisher}.
 *
 * <p>Uses Mockito mocks for {@link OutboxStore} and {@link HazelcastInstance}
 * (both interfaces, safe to mock on Java 25).
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("OutboxPublisher - Outbox entry delivery")
@ExtendWith(MockitoExtension.class)
class OutboxPublisherTest {

    @Mock
    private OutboxStore outboxStore;

    @Mock
    private HazelcastInstance sharedHazelcast;

    private SimpleMeterRegistry meterRegistry;
    private OutboxProperties properties;

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        properties = new OutboxProperties();
        properties.setMaxBatchSize(50);
        properties.setMaxRetries(3);
    }

    private GenericRecord createTestRecord(final String eventId, final String eventType) {
        return GenericRecordBuilder.compact("TestEvent")
                .setString("eventId", eventId)
                .setString("eventType", eventType)
                .build();
    }

    private OutboxEntry createTestEntry(final String eventId, final String eventType) {
        return new OutboxEntry(eventId, eventType, createTestRecord(eventId, eventType));
    }

    @Nested
    @DisplayName("Constructor validation")
    class ConstructorValidation {

        @Test
        @DisplayName("should reject null outboxStore")
        void shouldRejectNullOutboxStore() {
            assertThatThrownBy(() -> new OutboxPublisher(null, sharedHazelcast, properties, meterRegistry))
                    .isInstanceOf(NullPointerException.class)
                    .hasMessageContaining("outboxStore");
        }

        @Test
        @DisplayName("should accept null sharedHazelcast for graceful degradation")
        void shouldAcceptNullSharedHazelcast() {
            final OutboxPublisher publisher = new OutboxPublisher(outboxStore, null, properties, meterRegistry);

            assertThat(publisher).isNotNull();
        }

        @Test
        @DisplayName("should reject null properties")
        void shouldRejectNullProperties() {
            assertThatThrownBy(() -> new OutboxPublisher(outboxStore, sharedHazelcast, null, meterRegistry))
                    .isInstanceOf(NullPointerException.class)
                    .hasMessageContaining("properties");
        }

        @Test
        @DisplayName("should reject null meterRegistry")
        void shouldRejectNullMeterRegistry() {
            assertThatThrownBy(() -> new OutboxPublisher(outboxStore, sharedHazelcast, properties, null))
                    .isInstanceOf(NullPointerException.class)
                    .hasMessageContaining("meterRegistry");
        }
    }

    @Nested
    @DisplayName("Poll-publish-mark cycle")
    class PollPublishMarkCycle {

        @Test
        @DisplayName("should claim, publish to ITopic, and mark delivered")
        void shouldClaimPublishAndMarkDelivered() {
            // Arrange
            final OutboxEntry entry = createTestEntry("evt-1", "OrderCreated");
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> topic = mock(ITopic.class);

            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(List.of(entry));
            doReturn(topic).when(sharedHazelcast).getTopic("OrderCreated");

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            verify(topic).publish(entry.getEventRecord());
            verify(outboxStore).markDelivered("evt-1");
        }

        @Test
        @DisplayName("should process multiple entries in a single batch")
        void shouldProcessMultipleEntriesInSingleBatch() {
            // Arrange
            final OutboxEntry entry1 = createTestEntry("evt-1", "OrderCreated");
            final OutboxEntry entry2 = createTestEntry("evt-2", "StockReserved");
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> orderTopic = mock(ITopic.class);
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> stockTopic = mock(ITopic.class);

            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(List.of(entry1, entry2));
            doReturn(orderTopic).when(sharedHazelcast).getTopic("OrderCreated");
            doReturn(stockTopic).when(sharedHazelcast).getTopic("StockReserved");

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            verify(orderTopic).publish(entry1.getEventRecord());
            verify(stockTopic).publish(entry2.getEventRecord());
            verify(outboxStore).markDelivered("evt-1");
            verify(outboxStore).markDelivered("evt-2");
        }

        @Test
        @DisplayName("should not call markDelivered when claim returns empty list")
        void shouldNotCallMarkDeliveredWhenClaimReturnsEmpty() {
            // Arrange
            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(Collections.emptyList());

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            verify(outboxStore, never()).markDelivered(anyString());
            verify(outboxStore, never()).markFailed(anyString(), anyString());
            verify(outboxStore, never()).incrementRetryCount(anyString(), anyString());
        }

        @Test
        @DisplayName("should increment delivered counter metric on success")
        void shouldIncrementDeliveredCounterMetricOnSuccess() {
            // Arrange
            final OutboxEntry entry = createTestEntry("evt-1", "OrderCreated");
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> topic = mock(ITopic.class);

            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(List.of(entry));
            doReturn(topic).when(sharedHazelcast).getTopic("OrderCreated");

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            assertThat(meterRegistry.counter("outbox.entries.delivered").count()).isEqualTo(1.0);
        }

        @Test
        @DisplayName("should call releaseExpiredClaims before claiming new entries")
        void shouldSweepStaleClaimsBeforeClaiming() {
            // Arrange
            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(Collections.emptyList());

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            verify(outboxStore).releaseExpiredClaims(30_000L);
        }
    }

    @Nested
    @DisplayName("Retry on failure")
    class RetryOnFailure {

        @Test
        @DisplayName("should increment retry count when publish fails and retries not exhausted")
        void shouldIncrementRetryCountWhenPublishFails() {
            // Arrange
            final OutboxEntry entry = createTestEntry("evt-1", "OrderCreated");
            // retryCount is 0 by default, maxRetries is 3 => 0 + 1 < 3, so retry
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> topic = mock(ITopic.class);

            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(List.of(entry));
            doReturn(topic).when(sharedHazelcast).getTopic("OrderCreated");
            doThrow(new RuntimeException("Connection refused")).when(topic).publish(any());

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            verify(outboxStore).incrementRetryCount(eq("evt-1"), eq("Connection refused"));
            verify(outboxStore, never()).markDelivered(anyString());
            verify(outboxStore, never()).markFailed(anyString(), anyString());
        }

        @Test
        @DisplayName("should increment retry count when retry count is below max minus one")
        void shouldIncrementRetryCountWhenBelowMaxMinusOne() {
            // Arrange: entry with retryCount=1, maxRetries=3 => 1 + 1 < 3, so retry
            final OutboxEntry entry = createTestEntry("evt-1", "OrderCreated");
            entry.setRetryCount(1);
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> topic = mock(ITopic.class);

            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(List.of(entry));
            doReturn(topic).when(sharedHazelcast).getTopic("OrderCreated");
            doThrow(new RuntimeException("Timeout")).when(topic).publish(any());

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            verify(outboxStore).incrementRetryCount(eq("evt-1"), eq("Timeout"));
            verify(outboxStore, never()).markFailed(anyString(), anyString());
        }
    }

    @Nested
    @DisplayName("Max retry handling")
    class MaxRetryHandling {

        @Test
        @DisplayName("should mark as failed when retryCount + 1 equals maxRetries")
        void shouldMarkAsFailedWhenRetriesExhausted() {
            // Arrange: entry with retryCount=2, maxRetries=3 => 2 + 1 >= 3, so fail permanently
            final OutboxEntry entry = createTestEntry("evt-1", "OrderCreated");
            entry.setRetryCount(2);
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> topic = mock(ITopic.class);

            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(List.of(entry));
            doReturn(topic).when(sharedHazelcast).getTopic("OrderCreated");
            doThrow(new RuntimeException("Cluster unreachable")).when(topic).publish(any());

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            verify(outboxStore).markFailed(eq("evt-1"), contains("Max retries exceeded"));
            verify(outboxStore, never()).incrementRetryCount(anyString(), anyString());
            verify(outboxStore, never()).markDelivered(anyString());
        }

        @Test
        @DisplayName("should mark as failed when retryCount + 1 exceeds maxRetries")
        void shouldMarkAsFailedWhenRetriesExceeded() {
            // Arrange: entry with retryCount=4, maxRetries=3 => 4 + 1 >= 3, so fail permanently
            final OutboxEntry entry = createTestEntry("evt-1", "OrderCreated");
            entry.setRetryCount(4);
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> topic = mock(ITopic.class);

            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(List.of(entry));
            doReturn(topic).when(sharedHazelcast).getTopic("OrderCreated");
            doThrow(new RuntimeException("Still down")).when(topic).publish(any());

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            verify(outboxStore).markFailed(eq("evt-1"), contains("Max retries exceeded"));
            verify(outboxStore, never()).incrementRetryCount(anyString(), anyString());
        }

        @Test
        @DisplayName("should increment failed counter metric when marking as failed")
        void shouldIncrementFailedCounterMetricWhenMarkingAsFailed() {
            // Arrange
            final OutboxEntry entry = createTestEntry("evt-1", "OrderCreated");
            entry.setRetryCount(2);
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> topic = mock(ITopic.class);

            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(List.of(entry));
            doReturn(topic).when(sharedHazelcast).getTopic("OrderCreated");
            doThrow(new RuntimeException("Error")).when(topic).publish(any());

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            assertThat(meterRegistry.counter("outbox.entries.failed").count()).isEqualTo(1.0);
        }

        @Test
        @DisplayName("should handle maxRetries of 1 correctly")
        void shouldHandleMaxRetriesOfOneCorrectly() {
            // Arrange: maxRetries=1, retryCount=0 => 0 + 1 >= 1, so fail immediately
            properties.setMaxRetries(1);
            final OutboxEntry entry = createTestEntry("evt-1", "OrderCreated");
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> topic = mock(ITopic.class);

            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(List.of(entry));
            doReturn(topic).when(sharedHazelcast).getTopic("OrderCreated");
            doThrow(new RuntimeException("First and final failure")).when(topic).publish(any());

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            verify(outboxStore).markFailed(eq("evt-1"), contains("Max retries exceeded"));
            verify(outboxStore, never()).incrementRetryCount(anyString(), anyString());
        }
    }

    @Nested
    @DisplayName("Null shared Hazelcast (graceful degradation)")
    class NullSharedHazelcast {

        @Test
        @DisplayName("should skip delivery when sharedHazelcast is null")
        void shouldSkipDeliveryWhenSharedHazelcastIsNull() {
            // Arrange
            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, null, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert: should not claim, not mark delivered, not mark failed
            verify(outboxStore, never()).claimPending(anyInt(), anyString());
            verify(outboxStore, never()).markDelivered(anyString());
            verify(outboxStore, never()).markFailed(anyString(), anyString());
        }

        @Test
        @DisplayName("should not throw when sharedHazelcast is null")
        void shouldNotThrowWhenSharedHazelcastIsNull() {
            // Arrange
            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, null, properties, meterRegistry);

            // Act & Assert: no exception
            publisher.publishPendingEntries();
        }

        @Test
        @DisplayName("should only log warning once when sharedHazelcast is null")
        void shouldOnlyLogWarningOnceWhenSharedHazelcastIsNull() {
            // Arrange
            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, null, properties, meterRegistry);

            // Act: call multiple times
            publisher.publishPendingEntries();
            publisher.publishPendingEntries();
            publisher.publishPendingEntries();

            // Assert: outboxStore was never polled (all calls short-circuited)
            verify(outboxStore, never()).claimPending(anyInt(), anyString());
        }
    }

    @Nested
    @DisplayName("Event-driven wake-up")
    class EventDrivenWakeUp {

        @Test
        @DisplayName("should wake up immediately when notifyNewEntry is called before waitForWork")
        void shouldWakeUpImmediatelyWhenNotified() {
            // Arrange
            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act: signal first, then wait â€” should return immediately
            publisher.notifyNewEntry();
            final boolean wokeBySignal = publisher.waitForWork();

            // Assert
            assertThat(wokeBySignal).isTrue();
        }

        @Test
        @DisplayName("should timeout when waitForWork called without notification")
        void shouldTimeoutWhenNotNotified() {
            // Arrange: use a very short poll interval so the test completes quickly
            properties.setPollInterval(java.time.Duration.ofMillis(50));
            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            final long start = System.currentTimeMillis();
            final boolean wokeBySignal = publisher.waitForWork();
            final long elapsed = System.currentTimeMillis() - start;

            // Assert: should have timed out (not woken by signal)
            assertThat(wokeBySignal).isFalse();
            assertThat(elapsed).isGreaterThanOrEqualTo(40); // allow minor timing slack
        }

        @Test
        @DisplayName("should coalesce multiple rapid notifyNewEntry calls into one permit")
        void shouldCoalesceMultipleNotifications() {
            // Arrange
            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act: call notifyNewEntry multiple times
            publisher.notifyNewEntry();
            publisher.notifyNewEntry();
            publisher.notifyNewEntry();

            // First wait should succeed (consumes the single permit)
            final boolean firstWake = publisher.waitForWork();

            // Second wait should timeout (no more permits)
            properties.setPollInterval(java.time.Duration.ofMillis(50));
            // Note: properties are read at waitForWork() call time
            final OutboxPublisher publisher2 = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);
            publisher2.notifyNewEntry();
            publisher2.notifyNewEntry();
            publisher2.notifyNewEntry();
            final boolean secondWake = publisher2.waitForWork();

            // Assert: first wakes, second also wakes (but only one permit consumed)
            assertThat(firstWake).isTrue();
            assertThat(secondWake).isTrue();
        }
    }

    @Nested
    @DisplayName("Mixed success and failure in batch")
    class MixedBatch {

        @Test
        @DisplayName("should mark successful entries as delivered and failed entries for retry")
        void shouldHandleMixedSuccessAndFailureInBatch() {
            // Arrange
            final OutboxEntry entry1 = createTestEntry("evt-1", "OrderCreated");
            final OutboxEntry entry2 = createTestEntry("evt-2", "StockReserved");
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> orderTopic = mock(ITopic.class);
            @SuppressWarnings("unchecked")
            final ITopic<GenericRecord> stockTopic = mock(ITopic.class);

            when(outboxStore.claimPending(eq(50), anyString())).thenReturn(List.of(entry1, entry2));
            doReturn(orderTopic).when(sharedHazelcast).getTopic("OrderCreated");
            doReturn(stockTopic).when(sharedHazelcast).getTopic("StockReserved");
            doThrow(new RuntimeException("Network error")).when(stockTopic).publish(any());

            final OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, sharedHazelcast, properties, meterRegistry);

            // Act
            publisher.publishPendingEntries();

            // Assert
            verify(outboxStore).markDelivered("evt-1");
            verify(outboxStore).incrementRetryCount(eq("evt-2"), eq("Network error"));
            verify(outboxStore, never()).markFailed(anyString(), anyString());
        }
    }
}
