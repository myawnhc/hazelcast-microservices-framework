package com.theyawns.framework.outbox;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.Message;
import com.hazelcast.topic.MessageListener;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.util.List;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration test for the outbox delivery guarantee.
 *
 * <p>Verifies that the complete outbox cycle works end-to-end:
 * write → poll → publish → mark delivered. Uses a real embedded
 * Hazelcast instance to exercise IMap storage, GenericRecord
 * serialization, and ITopic delivery.
 *
 * <p>Also tests failure scenarios: retry increment on publish failure,
 * and permanent failure marking when retries are exhausted.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("Outbox Delivery Integration - End-to-end outbox guarantee")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class OutboxDeliveryIntegrationTest {

    private HazelcastInstance hazelcast;
    private SimpleMeterRegistry meterRegistry;
    private OutboxProperties properties;
    private HazelcastOutboxStore outboxStore;

    @BeforeAll
    void startHazelcast() {
        Config config = new Config();
        config.setClusterName("outbox-integration-" + System.nanoTime());
        config.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
        config.getNetworkConfig().getJoin().getAutoDetectionConfig().setEnabled(false);
        config.getJetConfig().setEnabled(false);
        hazelcast = Hazelcast.newHazelcastInstance(config);
    }

    @AfterAll
    void stopHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        properties = new OutboxProperties();
        outboxStore = new HazelcastOutboxStore(hazelcast, meterRegistry);
        // Clear the outbox map before each test to avoid cross-test pollution
        hazelcast.getMap("framework_OUTBOX").clear();
    }

    private GenericRecord createTestEventRecord(final String eventId, final String eventType) {
        return GenericRecordBuilder.compact("TestEvent")
                .setString("eventId", eventId)
                .setString("eventType", eventType)
                .setString("key", "test-key-1")
                .build();
    }

    @Nested
    @DisplayName("Full delivery cycle")
    class FullDeliveryCycle {

        @Test
        @DisplayName("should write, publish, and mark delivered end-to-end")
        void shouldWritePublishAndMarkDelivered() throws InterruptedException {
            // Arrange
            String eventType = "TestDelivery_" + System.nanoTime();
            GenericRecord eventRecord = createTestEventRecord("evt-deliver-001", eventType);
            OutboxEntry entry = new OutboxEntry("evt-deliver-001", eventType, eventRecord);

            // Set up ITopic listener to verify delivery
            CountDownLatch latch = new CountDownLatch(1);
            CopyOnWriteArrayList<GenericRecord> received = new CopyOnWriteArrayList<>();
            ITopic<GenericRecord> topic = hazelcast.getTopic(eventType);
            topic.addMessageListener(new MessageListener<GenericRecord>() {
                @Override
                public void onMessage(Message<GenericRecord> message) {
                    received.add(message.getMessageObject());
                    latch.countDown();
                }
            });

            // Act — write to outbox
            outboxStore.write(entry);
            assertThat(outboxStore.pendingCount()).isEqualTo(1);

            // Act — simulate publisher: poll, publish, mark delivered
            OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, hazelcast, properties, meterRegistry);
            publisher.publishPendingEntries();

            // Assert — event was delivered to ITopic
            boolean delivered = latch.await(5, TimeUnit.SECONDS);
            assertThat(delivered).isTrue();
            assertThat(received).hasSize(1);
            assertThat(received.get(0).getString("eventId")).isEqualTo("evt-deliver-001");

            // Assert — outbox entry marked as DELIVERED
            assertThat(outboxStore.pendingCount()).isZero();
        }

        @Test
        @DisplayName("should deliver multiple entries in batch order")
        void shouldDeliverMultipleEntriesInBatchOrder() throws InterruptedException {
            // Arrange
            String eventType = "TestBatch_" + System.nanoTime();
            CopyOnWriteArrayList<String> receivedIds = new CopyOnWriteArrayList<>();
            CountDownLatch latch = new CountDownLatch(3);
            ITopic<GenericRecord> topic = hazelcast.getTopic(eventType);
            topic.addMessageListener(new MessageListener<GenericRecord>() {
                @Override
                public void onMessage(Message<GenericRecord> message) {
                    receivedIds.add(message.getMessageObject().getString("eventId"));
                    latch.countDown();
                }
            });

            // Write 3 entries with slight delay to ensure ordering
            for (int i = 1; i <= 3; i++) {
                GenericRecord record = createTestEventRecord("evt-batch-" + i, eventType);
                outboxStore.write(new OutboxEntry("evt-batch-" + i, eventType, record));
                Thread.sleep(5); // Ensure distinct createdAt timestamps
            }
            assertThat(outboxStore.pendingCount()).isEqualTo(3);

            // Act
            OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, hazelcast, properties, meterRegistry);
            publisher.publishPendingEntries();

            // Assert
            boolean allDelivered = latch.await(5, TimeUnit.SECONDS);
            assertThat(allDelivered).isTrue();
            assertThat(receivedIds).hasSize(3);
            // Verify FIFO order (oldest first)
            assertThat(receivedIds).containsExactly("evt-batch-1", "evt-batch-2", "evt-batch-3");
            assertThat(outboxStore.pendingCount()).isZero();
        }
    }

    @Nested
    @DisplayName("Failure and retry")
    class FailureAndRetry {

        @Test
        @DisplayName("should keep entries pending when shared cluster is unavailable")
        void shouldKeepEntriesPendingWhenNoSharedCluster() {
            // Arrange — write an entry
            String eventType = "FailTest_" + System.nanoTime();
            GenericRecord record = createTestEventRecord("evt-fail-001", eventType);
            outboxStore.write(new OutboxEntry("evt-fail-001", eventType, record));

            // Act — publisher with null shared cluster (simulates unavailability)
            OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, null, properties, meterRegistry);
            publisher.publishPendingEntries();

            // Assert — entry still pending (publisher skipped due to null shared cluster)
            assertThat(outboxStore.pendingCount()).isEqualTo(1);

            // Verify no delivery metrics recorded
            double delivered = meterRegistry.counter("outbox.entries.delivered").count();
            assertThat(delivered).isZero();
        }

        @Test
        @DisplayName("should respect max-batch-size limit")
        void shouldRespectMaxBatchSizeLimit() throws InterruptedException {
            // Arrange — write 5 entries but set batch size to 2
            properties.setMaxBatchSize(2);
            String eventType = "BatchLimit_" + System.nanoTime();
            CountDownLatch latch = new CountDownLatch(2);
            ITopic<GenericRecord> topic = hazelcast.getTopic(eventType);
            topic.addMessageListener(msg -> latch.countDown());

            for (int i = 1; i <= 5; i++) {
                GenericRecord record = createTestEventRecord("evt-limit-" + i, eventType);
                outboxStore.write(new OutboxEntry("evt-limit-" + i, eventType, record));
                Thread.sleep(5);
            }
            assertThat(outboxStore.pendingCount()).isEqualTo(5);

            // Act — first poll delivers only 2
            OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, hazelcast, properties, meterRegistry);
            publisher.publishPendingEntries();

            boolean firstBatch = latch.await(5, TimeUnit.SECONDS);
            assertThat(firstBatch).isTrue();

            // Assert — 3 still pending
            assertThat(outboxStore.pendingCount()).isEqualTo(3);
        }

        @Test
        @DisplayName("should mark entry as FAILED after max retries exceeded")
        void shouldMarkEntryAsFailedAfterMaxRetries() {
            // Arrange
            properties.setMaxRetries(2);
            String eventType = "MaxRetry_" + System.nanoTime();
            GenericRecord record = createTestEventRecord("evt-maxretry", eventType);
            OutboxEntry entry = new OutboxEntry("evt-maxretry", eventType, record);

            // Simulate incrementing retries manually (as if previous publish cycles failed)
            outboxStore.write(entry);
            outboxStore.incrementRetryCount("evt-maxretry", "attempt 1 failed");
            outboxStore.incrementRetryCount("evt-maxretry", "attempt 2 failed");

            // The entry now has retryCount=2, which equals maxRetries=2
            List<OutboxEntry> pending = outboxStore.pollPending(10);
            assertThat(pending).hasSize(1);
            assertThat(pending.get(0).getRetryCount()).isEqualTo(2);
        }
    }

    @Nested
    @DisplayName("Metrics")
    class Metrics {

        @Test
        @DisplayName("should record delivery metrics after successful publish")
        void shouldRecordDeliveryMetrics() {
            // Arrange
            String eventType = "MetricsTest_" + System.nanoTime();
            GenericRecord record = createTestEventRecord("evt-metrics", eventType);
            outboxStore.write(new OutboxEntry("evt-metrics", eventType, record));

            // Act
            OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, hazelcast, properties, meterRegistry);
            publisher.publishPendingEntries();

            // Assert
            double written = meterRegistry.counter("outbox.entries.written").count();
            double delivered = meterRegistry.counter("outbox.entries.delivered").count();
            assertThat(written).isEqualTo(1.0);
            assertThat(delivered).isEqualTo(1.0);
        }

        @Test
        @DisplayName("should record duration timer for publish cycle")
        void shouldRecordDurationTimer() {
            // Arrange
            String eventType = "TimerTest_" + System.nanoTime();
            GenericRecord record = createTestEventRecord("evt-timer", eventType);
            outboxStore.write(new OutboxEntry("evt-timer", eventType, record));

            // Act
            OutboxPublisher publisher = new OutboxPublisher(
                    outboxStore, hazelcast, properties, meterRegistry);
            publisher.publishPendingEntries();

            // Assert
            assertThat(meterRegistry.timer("outbox.publish.duration").count()).isEqualTo(1);
        }
    }

    @Nested
    @DisplayName("Idempotent redelivery")
    class IdempotentRedelivery {

        @Test
        @DisplayName("should survive duplicate write with same eventId")
        void shouldSurviveDuplicateWrite() {
            // Arrange — write same event twice
            String eventType = "DuplicateWrite_" + System.nanoTime();
            GenericRecord record = createTestEventRecord("evt-dup", eventType);
            outboxStore.write(new OutboxEntry("evt-dup", eventType, record));
            outboxStore.write(new OutboxEntry("evt-dup", eventType, record));

            // Assert — only one entry (IMap set overwrites)
            assertThat(outboxStore.pendingCount()).isEqualTo(1);
        }
    }
}
