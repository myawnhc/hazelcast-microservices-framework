package com.theyawns.framework.outbox;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.test.context.runner.ApplicationContextRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link OutboxAutoConfiguration}.
 *
 * <p>Uses {@link ApplicationContextRunner} pattern to test auto-configuration
 * behavior without starting a full Spring context. Provides mock
 * {@link HazelcastInstance} and {@link SimpleMeterRegistry} as user configurations.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("OutboxAutoConfiguration - Auto-configuration behavior")
class OutboxAutoConfigurationTest {

    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(OutboxAutoConfiguration.class))
            .withPropertyValues("framework.edition.license.env-var=NONEXISTENT_TEST_LICENSE_VAR_12345");

    @Nested
    @DisplayName("Default configuration")
    class DefaultConfiguration {

        @Test
        @DisplayName("should create OutboxStore bean when HazelcastInstance exists")
        void shouldCreateOutboxStoreBeanWhenHazelcastExists() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(OutboxStore.class);
                    });
        }

        @Test
        @DisplayName("should create OutboxPublisher bean when HazelcastInstance exists")
        void shouldCreateOutboxPublisherBeanWhenHazelcastExists() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(OutboxPublisher.class);
                    });
        }

        @Test
        @DisplayName("should create OutboxProperties bean when HazelcastInstance exists")
        void shouldCreateOutboxPropertiesBeanWhenHazelcastExists() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(OutboxProperties.class);
                    });
        }

        @Test
        @DisplayName("should create all outbox beans by default (enabled is true by default)")
        void shouldCreateAllOutboxBeansByDefault() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(OutboxStore.class);
                        assertThat(context).hasSingleBean(OutboxPublisher.class);
                        assertThat(context).hasSingleBean(OutboxProperties.class);
                    });
        }
    }

    @Nested
    @DisplayName("Disabled configuration")
    class DisabledConfiguration {

        @Test
        @DisplayName("should not create beans when framework.outbox.enabled is false")
        void shouldNotCreateBeansWhenDisabled() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class)
                    .withPropertyValues("framework.outbox.enabled=false")
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(OutboxStore.class);
                        assertThat(context).doesNotHaveBean(OutboxPublisher.class);
                    });
        }
    }

    @Nested
    @DisplayName("Missing dependencies")
    class MissingDependencies {

        @Test
        @DisplayName("should not create beans when HazelcastInstance is missing")
        void shouldNotCreateBeansWhenHazelcastMissing() {
            contextRunner
                    .withUserConfiguration(NoHazelcastConfig.class)
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(OutboxStore.class);
                        assertThat(context).doesNotHaveBean(OutboxPublisher.class);
                    });
        }
    }

    @Nested
    @DisplayName("Property binding")
    class PropertyBinding {

        @Test
        @DisplayName("should bind outbox properties from configuration")
        void shouldBindOutboxProperties() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class)
                    .withPropertyValues(
                            "framework.outbox.max-batch-size=100",
                            "framework.outbox.max-retries=10",
                            "framework.outbox.poll-interval=2s",
                            "framework.outbox.entry-ttl=48h"
                    )
                    .run(context -> {
                        assertThat(context).hasSingleBean(OutboxProperties.class);
                        final OutboxProperties props = context.getBean(OutboxProperties.class);
                        assertThat(props.getMaxBatchSize()).isEqualTo(100);
                        assertThat(props.getMaxRetries()).isEqualTo(10);
                        assertThat(props.getPollInterval().toSeconds()).isEqualTo(2);
                        assertThat(props.getEntryTtl().toHours()).isEqualTo(48);
                    });
        }
    }

    @Nested
    @DisplayName("Custom bean overrides")
    class CustomBeanOverrides {

        @Test
        @DisplayName("should not override existing OutboxStore bean")
        void shouldNotOverrideExistingOutboxStore() {
            contextRunner
                    .withUserConfiguration(FullDependenciesConfig.class, CustomOutboxStoreConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(OutboxStore.class);
                        assertThat(context.getBean(OutboxStore.class))
                                .isInstanceOf(CustomOutboxStore.class);
                    });
        }
    }

    // ========== Test Configuration Classes ==========

    @Configuration
    static class FullDependenciesConfig {

        @Bean(destroyMethod = "shutdown")
        HazelcastInstance hazelcastInstance() {
            final Config config = new Config();
            config.setClusterName("outbox-autoconfig-test-" + System.nanoTime());
            config.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
            config.getNetworkConfig().getJoin().getAutoDetectionConfig().setEnabled(false);
            config.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(false);
            return Hazelcast.newHazelcastInstance(config);
        }

        @Bean
        MeterRegistry meterRegistry() {
            return new SimpleMeterRegistry();
        }
    }

    @Configuration
    static class NoHazelcastConfig {

        @Bean
        MeterRegistry meterRegistry() {
            return new SimpleMeterRegistry();
        }
    }

    @Configuration
    static class CustomOutboxStoreConfig {

        @Bean
        OutboxStore outboxStore() {
            return new CustomOutboxStore();
        }
    }

    /**
     * Custom OutboxStore implementation for testing ConditionalOnMissingBean.
     */
    static class CustomOutboxStore implements OutboxStore {

        @Override
        public void write(final OutboxEntry entry) {
            // no-op
        }

        @Override
        public java.util.List<OutboxEntry> pollPending(final int maxBatchSize) {
            return java.util.Collections.emptyList();
        }

        @Override
        public void markDelivered(final String eventId) {
            // no-op
        }

        @Override
        public void markFailed(final String eventId, final String reason) {
            // no-op
        }

        @Override
        public void incrementRetryCount(final String eventId, final String failureReason) {
            // no-op
        }

        @Override
        public long pendingCount() {
            return 0;
        }

        @Override
        public java.util.List<OutboxEntry> claimPending(final int maxBatchSize, final String claimantId) {
            return java.util.Collections.emptyList();
        }

        @Override
        public int releaseExpiredClaims(final long staleTimeoutMs) {
            return 0;
        }
    }
}
