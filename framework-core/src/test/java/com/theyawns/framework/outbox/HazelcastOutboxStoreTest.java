package com.theyawns.framework.outbox;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.AfterEach;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;
import static org.assertj.core.api.Assertions.assertThatThrownBy;

/**
 * Integration tests for {@link HazelcastOutboxStore} using a real embedded Hazelcast instance.
 *
 * <p>Uses {@code @TestInstance(PER_CLASS)} to share a single Hazelcast instance
 * across all tests, avoiding the overhead of starting/stopping per test and
 * working around Java 25 Mockito limitations with Hazelcast concrete classes.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@DisplayName("HazelcastOutboxStore - IMap-backed outbox store")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class HazelcastOutboxStoreTest {

    private HazelcastInstance hazelcast;
    private SimpleMeterRegistry meterRegistry;
    private HazelcastOutboxStore outboxStore;

    @BeforeAll
    void setUpClass() {
        final Config config = new Config();
        config.setClusterName("outbox-test-cluster-" + System.currentTimeMillis());
        config.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
        config.getNetworkConfig().getJoin().getAutoDetectionConfig().setEnabled(false);
        config.getNetworkConfig().getJoin().getTcpIpConfig().setEnabled(false);

        hazelcast = Hazelcast.newHazelcastInstance(config);
    }

    @AfterAll
    void tearDownClass() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void setUp() {
        meterRegistry = new SimpleMeterRegistry();
        outboxStore = new HazelcastOutboxStore(hazelcast, meterRegistry);
    }

    @AfterEach
    void tearDown() {
        hazelcast.getMap("framework_OUTBOX").clear();
    }

    private GenericRecord createTestRecord(final String eventId, final String eventType) {
        return GenericRecordBuilder.compact("TestEvent")
                .setString("eventId", eventId)
                .setString("eventType", eventType)
                .build();
    }

    private OutboxEntry createTestEntry(final String eventId, final String eventType) {
        return new OutboxEntry(eventId, eventType, createTestRecord(eventId, eventType));
    }

    @Nested
    @DisplayName("Write")
    class Write {

        @Test
        @DisplayName("should store entry in outbox map")
        void shouldStoreEntryInOutboxMap() {
            final OutboxEntry entry = createTestEntry("evt-1", "OrderCreated");

            outboxStore.write(entry);

            assertThat(outboxStore.pendingCount()).isEqualTo(1);
        }

        @Test
        @DisplayName("should increment written counter metric")
        void shouldIncrementWrittenCounterMetric() {
            final OutboxEntry entry = createTestEntry("evt-1", "OrderCreated");

            outboxStore.write(entry);

            assertThat(meterRegistry.counter("outbox.entries.written").count()).isEqualTo(1.0);
        }

        @Test
        @DisplayName("should reject null entry")
        void shouldRejectNullEntry() {
            assertThatThrownBy(() -> outboxStore.write(null))
                    .isInstanceOf(NullPointerException.class);
        }

        @Test
        @DisplayName("should store multiple entries")
        void shouldStoreMultipleEntries() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.write(createTestEntry("evt-2", "StockReserved"));
            outboxStore.write(createTestEntry("evt-3", "PaymentProcessed"));

            assertThat(outboxStore.pendingCount()).isEqualTo(3);
        }
    }

    @Nested
    @DisplayName("Poll pending")
    class PollPending {

        @Test
        @DisplayName("should return empty list when no entries exist")
        void shouldReturnEmptyListWhenNoEntriesExist() {
            final List<OutboxEntry> pending = outboxStore.pollPending(10);

            assertThat(pending).isEmpty();
        }

        @Test
        @DisplayName("should return only PENDING entries")
        void shouldReturnOnlyPendingEntries() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.write(createTestEntry("evt-2", "StockReserved"));
            outboxStore.markDelivered("evt-1");

            final List<OutboxEntry> pending = outboxStore.pollPending(10);

            assertThat(pending).hasSize(1);
            assertThat(pending.get(0).getEventId()).isEqualTo("evt-2");
        }

        @Test
        @DisplayName("should respect maxBatchSize limit")
        void shouldRespectMaxBatchSizeLimit() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.write(createTestEntry("evt-2", "StockReserved"));
            outboxStore.write(createTestEntry("evt-3", "PaymentProcessed"));

            final List<OutboxEntry> pending = outboxStore.pollPending(2);

            assertThat(pending).hasSize(2);
        }

        @Test
        @DisplayName("should not return FAILED entries")
        void shouldNotReturnFailedEntries() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.write(createTestEntry("evt-2", "StockReserved"));
            outboxStore.markFailed("evt-1", "Max retries exceeded");

            final List<OutboxEntry> pending = outboxStore.pollPending(10);

            assertThat(pending).hasSize(1);
            assertThat(pending.get(0).getEventId()).isEqualTo("evt-2");
        }
    }

    @Nested
    @DisplayName("Mark delivered")
    class MarkDelivered {

        @Test
        @DisplayName("should change status to DELIVERED")
        void shouldChangeStatusToDelivered() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));

            outboxStore.markDelivered("evt-1");

            final List<OutboxEntry> pending = outboxStore.pollPending(10);
            assertThat(pending).isEmpty();
            assertThat(outboxStore.pendingCount()).isEqualTo(0);
        }

        @Test
        @DisplayName("should set lastAttemptAt when marking delivered")
        void shouldSetLastAttemptAtWhenMarkingDelivered() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));

            outboxStore.markDelivered("evt-1");

            // Verify via re-reading from map (entry is no longer PENDING, but still in map)
            // We can verify pendingCount dropped to 0
            assertThat(outboxStore.pendingCount()).isEqualTo(0);
        }

        @Test
        @DisplayName("should handle non-existent eventId gracefully")
        void shouldHandleNonExistentEventIdGracefully() {
            // Should not throw
            outboxStore.markDelivered("non-existent-id");

            assertThat(outboxStore.pendingCount()).isEqualTo(0);
        }
    }

    @Nested
    @DisplayName("Mark failed")
    class MarkFailed {

        @Test
        @DisplayName("should change status to FAILED")
        void shouldChangeStatusToFailed() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));

            outboxStore.markFailed("evt-1", "Max retries exceeded");

            assertThat(outboxStore.pendingCount()).isEqualTo(0);
        }

        @Test
        @DisplayName("should handle non-existent eventId gracefully")
        void shouldHandleNonExistentEventIdGracefully() {
            // Should not throw
            outboxStore.markFailed("non-existent-id", "Some reason");

            assertThat(outboxStore.pendingCount()).isEqualTo(0);
        }
    }

    @Nested
    @DisplayName("Increment retry count")
    class IncrementRetryCount {

        @Test
        @DisplayName("should increment retry count by one")
        void shouldIncrementRetryCountByOne() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));

            outboxStore.incrementRetryCount("evt-1", "Connection timeout");

            final List<OutboxEntry> pending = outboxStore.pollPending(10);
            assertThat(pending).hasSize(1);
            assertThat(pending.get(0).getRetryCount()).isEqualTo(1);
        }

        @Test
        @DisplayName("should increment retry count multiple times")
        void shouldIncrementRetryCountMultipleTimes() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));

            outboxStore.incrementRetryCount("evt-1", "First failure");
            outboxStore.incrementRetryCount("evt-1", "Second failure");
            outboxStore.incrementRetryCount("evt-1", "Third failure");

            final List<OutboxEntry> pending = outboxStore.pollPending(10);
            assertThat(pending).hasSize(1);
            assertThat(pending.get(0).getRetryCount()).isEqualTo(3);
            assertThat(pending.get(0).getFailureReason()).isEqualTo("Third failure");
        }

        @Test
        @DisplayName("should keep entry in PENDING status after increment")
        void shouldKeepEntryInPendingStatusAfterIncrement() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));

            outboxStore.incrementRetryCount("evt-1", "Connection timeout");

            assertThat(outboxStore.pendingCount()).isEqualTo(1);
        }

        @Test
        @DisplayName("should handle non-existent eventId gracefully")
        void shouldHandleNonExistentEventIdGracefully() {
            // Should not throw
            outboxStore.incrementRetryCount("non-existent-id", "Some reason");

            assertThat(outboxStore.pendingCount()).isEqualTo(0);
        }
    }

    @Nested
    @DisplayName("Pending count")
    class PendingCount {

        @Test
        @DisplayName("should return 0 when no entries exist")
        void shouldReturnZeroWhenNoEntriesExist() {
            assertThat(outboxStore.pendingCount()).isEqualTo(0);
        }

        @Test
        @DisplayName("should return count of PENDING entries only")
        void shouldReturnCountOfPendingEntriesOnly() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.write(createTestEntry("evt-2", "StockReserved"));
            outboxStore.write(createTestEntry("evt-3", "PaymentProcessed"));
            outboxStore.markDelivered("evt-1");
            outboxStore.markFailed("evt-2", "Max retries");

            assertThat(outboxStore.pendingCount()).isEqualTo(1);
        }
    }

    @Nested
    @DisplayName("Claim pending")
    class ClaimPending {

        @Test
        @DisplayName("should return empty list when no entries exist")
        void shouldReturnEmptyListWhenNoEntriesExist() {
            final List<OutboxEntry> claimed = outboxStore.claimPending(10, "member-1");

            assertThat(claimed).isEmpty();
        }

        @Test
        @DisplayName("should claim PENDING entries and transition to CLAIMED status")
        void shouldClaimPendingEntries() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.write(createTestEntry("evt-2", "StockReserved"));

            final List<OutboxEntry> claimed = outboxStore.claimPending(10, "member-1");

            assertThat(claimed).hasSize(2);
            // After claiming, entries should no longer be PENDING
            assertThat(outboxStore.pendingCount()).isEqualTo(0);
        }

        @Test
        @DisplayName("should set claimantId on claimed entries")
        void shouldSetClaimantIdOnClaimedEntries() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));

            final List<OutboxEntry> claimed = outboxStore.claimPending(10, "member-uuid-123");

            assertThat(claimed).hasSize(1);
            assertThat(claimed.get(0).getClaimantId()).isEqualTo("member-uuid-123");
        }

        @Test
        @DisplayName("should not claim already-claimed entries")
        void shouldNotClaimAlreadyClaimedEntries() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));

            // First member claims
            final List<OutboxEntry> first = outboxStore.claimPending(10, "member-1");
            assertThat(first).hasSize(1);

            // Second member tries to claim — should get nothing
            final List<OutboxEntry> second = outboxStore.claimPending(10, "member-2");
            assertThat(second).isEmpty();
        }

        @Test
        @DisplayName("should respect maxBatchSize limit")
        void shouldRespectMaxBatchSizeLimit() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.write(createTestEntry("evt-2", "StockReserved"));
            outboxStore.write(createTestEntry("evt-3", "PaymentProcessed"));

            final List<OutboxEntry> claimed = outboxStore.claimPending(2, "member-1");

            assertThat(claimed).hasSize(2);
            // One entry should still be PENDING
            assertThat(outboxStore.pendingCount()).isEqualTo(1);
        }

        @Test
        @DisplayName("should not claim DELIVERED entries")
        void shouldNotClaimDeliveredEntries() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.markDelivered("evt-1");

            final List<OutboxEntry> claimed = outboxStore.claimPending(10, "member-1");

            assertThat(claimed).isEmpty();
        }

        @Test
        @DisplayName("should not claim FAILED entries")
        void shouldNotClaimFailedEntries() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.markFailed("evt-1", "Max retries exceeded");

            final List<OutboxEntry> claimed = outboxStore.claimPending(10, "member-1");

            assertThat(claimed).isEmpty();
        }
    }

    @Nested
    @DisplayName("Release expired claims")
    class ReleaseExpiredClaims {

        @Test
        @DisplayName("should return 0 when no claimed entries exist")
        void shouldReturnZeroWhenNoClaimedEntriesExist() {
            final int released = outboxStore.releaseExpiredClaims(30_000);

            assertThat(released).isEqualTo(0);
        }

        @Test
        @DisplayName("should not release fresh claims")
        void shouldNotReleaseFreshClaims() {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.claimPending(10, "member-1");

            // Use a very long timeout — claim is too fresh to be stale
            final int released = outboxStore.releaseExpiredClaims(30_000);

            assertThat(released).isEqualTo(0);
            // Entry should still be claimed (not pending)
            assertThat(outboxStore.pendingCount()).isEqualTo(0);
        }

        @Test
        @DisplayName("should release stale claims back to PENDING")
        void shouldReleaseStaleClaims() throws InterruptedException {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.claimPending(10, "member-1");

            // Wait 5ms to ensure claimedAt is in the past, then use 0ms timeout
            Thread.sleep(5);
            final int released = outboxStore.releaseExpiredClaims(0);

            assertThat(released).isEqualTo(1);
            // Entry should be PENDING again
            assertThat(outboxStore.pendingCount()).isEqualTo(1);
        }

        @Test
        @DisplayName("should allow reclaiming after release")
        void shouldAllowReclaimingAfterRelease() throws InterruptedException {
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.claimPending(10, "member-1");

            // Wait 5ms to ensure claimedAt is in the past, then release with 0ms timeout
            Thread.sleep(5);
            outboxStore.releaseExpiredClaims(0);

            // A different member should now be able to claim
            final List<OutboxEntry> reclaimed = outboxStore.claimPending(10, "member-2");
            assertThat(reclaimed).hasSize(1);
            assertThat(reclaimed.get(0).getClaimantId()).isEqualTo("member-2");
        }
    }

    @Nested
    @DisplayName("Full lifecycle")
    class FullLifecycle {

        @Test
        @DisplayName("should support write-poll-deliver cycle")
        void shouldSupportWritePollDeliverCycle() {
            // Arrange: write entries
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));
            outboxStore.write(createTestEntry("evt-2", "StockReserved"));
            assertThat(outboxStore.pendingCount()).isEqualTo(2);

            // Act: poll pending
            final List<OutboxEntry> pending = outboxStore.pollPending(10);
            assertThat(pending).hasSize(2);

            // Act: mark first as delivered
            outboxStore.markDelivered("evt-1");
            assertThat(outboxStore.pendingCount()).isEqualTo(1);

            // Act: increment retry on second (simulating transient failure)
            outboxStore.incrementRetryCount("evt-2", "Transient error");
            assertThat(outboxStore.pendingCount()).isEqualTo(1);

            // Act: re-poll and deliver second
            final List<OutboxEntry> retryBatch = outboxStore.pollPending(10);
            assertThat(retryBatch).hasSize(1);
            assertThat(retryBatch.get(0).getRetryCount()).isEqualTo(1);

            outboxStore.markDelivered("evt-2");
            assertThat(outboxStore.pendingCount()).isEqualTo(0);
        }

        @Test
        @DisplayName("should support write-retry-fail cycle")
        void shouldSupportWriteRetryFailCycle() {
            // Arrange: write entry
            outboxStore.write(createTestEntry("evt-1", "OrderCreated"));

            // Act: simulate multiple retries
            outboxStore.incrementRetryCount("evt-1", "Attempt 1 failed");
            outboxStore.incrementRetryCount("evt-1", "Attempt 2 failed");
            outboxStore.incrementRetryCount("evt-1", "Attempt 3 failed");

            // Verify still pending
            assertThat(outboxStore.pendingCount()).isEqualTo(1);

            // Act: mark as permanently failed
            outboxStore.markFailed("evt-1", "Max retries exceeded after 3 attempts");

            // Assert: no longer pending
            assertThat(outboxStore.pendingCount()).isEqualTo(0);
            assertThat(outboxStore.pollPending(10)).isEmpty();
        }
    }
}
