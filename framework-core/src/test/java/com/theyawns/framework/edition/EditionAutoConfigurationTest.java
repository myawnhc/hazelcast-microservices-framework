package com.theyawns.framework.edition;

import com.hazelcast.config.Config;
import com.hazelcast.core.HazelcastInstance;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.boot.actuate.info.Info;
import org.springframework.boot.autoconfigure.AutoConfigurations;
import org.springframework.boot.test.context.runner.ApplicationContextRunner;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Tests for {@link EditionAutoConfiguration}.
 *
 * <p>Uses {@link ApplicationContextRunner} to test auto-configuration behavior
 * without starting a full Spring Boot application.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("EditionAutoConfiguration - Auto-configuration behavior")
class EditionAutoConfigurationTest {

    private final ApplicationContextRunner contextRunner = new ApplicationContextRunner()
            .withConfiguration(AutoConfigurations.of(EditionAutoConfiguration.class));

    @Nested
    @DisplayName("With HazelcastInstance present")
    class WithHazelcast {

        @Test
        @DisplayName("should create EditionDetector bean")
        void shouldCreateEditionDetectorBean() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(EditionDetector.class);
                        assertThat(context).hasSingleBean(EditionProperties.class);
                    });
        }

        @Test
        @DisplayName("should create EditionInfoContributor bean by default")
        void shouldCreateInfoContributorByDefault() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(EditionInfoContributor.class);
                    });
        }

        @Test
        @DisplayName("should not create EditionInfoContributor when actuator exposure disabled")
        void shouldNotCreateInfoContributorWhenDisabled() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues("framework.observability.expose-in-actuator=false")
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(EditionInfoContributor.class);
                    });
        }

        @Test
        @DisplayName("should bind default configuration properties")
        void shouldBindDefaultProperties() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .run(context -> {
                        final EditionProperties props = context.getBean(EditionProperties.class);
                        assertThat(props.getMode()).isEqualTo("auto");
                        assertThat(props.getLicense().getEnvVar()).isEqualTo("HZ_LICENSEKEY");
                        assertThat(props.getLicense().getMissingBehavior()).isEqualTo("warn");
                    });
        }

        @Test
        @DisplayName("should bind custom configuration properties")
        void shouldBindCustomProperties() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues(
                            "framework.edition.mode=community",
                            "framework.edition.license.env-var=CUSTOM_LICENSE_VAR",
                            "framework.edition.license.missing-behavior=fail",
                            "framework.features.vector-store.enabled=false",
                            "framework.features.vector-store.fallback-behavior=empty-results",
                            "framework.observability.log-edition-status=false"
                    )
                    .run(context -> {
                        final EditionProperties props = context.getBean(EditionProperties.class);
                        assertThat(props.getMode()).isEqualTo("community");
                        assertThat(props.getLicense().getEnvVar()).isEqualTo("CUSTOM_LICENSE_VAR");
                        assertThat(props.getLicense().getMissingBehavior()).isEqualTo("fail");
                        assertThat(props.getFeatures().getVectorStore().getEnabled()).isEqualTo("false");
                        assertThat(props.getFeatures().getVectorStore().getFallbackBehavior())
                                .isEqualTo("empty-results");
                        assertThat(props.getObservability().isLogEditionStatus()).isFalse();
                    });
        }

        @Test
        @DisplayName("should detect Community Edition when license env var is absent")
        void shouldDetectCommunityByDefault() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    // Use a non-existent env var to guarantee Community detection
                    .withPropertyValues(
                            "framework.edition.license.env-var=NONEXISTENT_TEST_LICENSE_VAR_12345"
                    )
                    .run(context -> {
                        final EditionDetector detector = context.getBean(EditionDetector.class);
                        assertThat(detector.isCommunity()).isTrue();
                        assertThat(detector.isEnterprise()).isFalse();
                        assertThat(detector.getAvailableFeatures()).isEmpty();
                    });
        }

        @Test
        @DisplayName("should bind TPC configuration properties")
        void shouldBindTpcProperties() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues(
                            "framework.features.tpc.enabled=auto",
                            "framework.features.tpc.fallback-behavior=standard-threading",
                            "framework.features.tpc.eventloop-count=4",
                            "framework.features.tpc.client-enabled=false"
                    )
                    .run(context -> {
                        final EditionProperties props = context.getBean(EditionProperties.class);
                        final EditionProperties.TpcFeatureConfig tpcConfig = props.getFeatures().getTpc();
                        assertThat(tpcConfig.getEnabled()).isEqualTo("auto");
                        assertThat(tpcConfig.getEventloopCount()).isEqualTo(4);
                        assertThat(tpcConfig.isClientEnabled()).isFalse();
                    });
        }

        @Test
        @DisplayName("should bind HD Memory extended configuration properties")
        void shouldBindHdMemoryExtendedProperties() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues(
                            "framework.features.hd-memory.capacity-mb=1024",
                            "framework.features.hd-memory.allocator-type=STANDARD"
                    )
                    .run(context -> {
                        final EditionProperties props = context.getBean(EditionProperties.class);
                        final EditionProperties.HdMemoryFeatureConfig hdConfig = props.getFeatures().getHdMemory();
                        assertThat(hdConfig.getCapacityMb()).isEqualTo(1024);
                        assertThat(hdConfig.getAllocatorType()).isEqualTo("STANDARD");
                    });
        }

        @Test
        @DisplayName("should detect Community when mode explicitly set to community")
        void shouldDetectCommunityWhenExplicitlySet() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    .withPropertyValues("framework.edition.mode=community")
                    .run(context -> {
                        final EditionDetector detector = context.getBean(EditionDetector.class);
                        assertThat(detector.getEdition())
                                .isEqualTo(EditionDetector.Edition.COMMUNITY);
                    });
        }
    }

    @Nested
    @DisplayName("Without HazelcastInstance")
    class WithoutHazelcast {

        @Test
        @DisplayName("should not create any beans when HazelcastInstance is missing")
        void shouldNotCreateBeansWhenHazelcastMissing() {
            contextRunner
                    .run(context -> {
                        assertThat(context).doesNotHaveBean(EditionDetector.class);
                        assertThat(context).doesNotHaveBean(EditionInfoContributor.class);
                    });
        }
    }

    @Nested
    @DisplayName("Custom bean override")
    class CustomBeanOverride {

        @Test
        @DisplayName("should not override existing EditionDetector bean")
        void shouldNotOverrideExistingDetector() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class, CustomDetectorConfig.class)
                    .run(context -> {
                        assertThat(context).hasSingleBean(EditionDetector.class);
                        // Should use the custom one, not auto-configured
                        final EditionDetector detector = context.getBean(EditionDetector.class);
                        assertThat(detector.getEdition())
                                .isEqualTo(EditionDetector.Edition.COMMUNITY);
                    });
        }
    }

    @Nested
    @DisplayName("EditionInfoContributor")
    class InfoContributorTests {

        @Test
        @DisplayName("should contribute edition info to actuator")
        void shouldContributeEditionInfo() {
            contextRunner
                    .withUserConfiguration(HazelcastConfig.class)
                    // Use a non-existent env var to guarantee Community detection
                    .withPropertyValues(
                            "framework.edition.license.env-var=NONEXISTENT_TEST_LICENSE_VAR_12345"
                    )
                    .run(context -> {
                        final EditionInfoContributor contributor =
                                context.getBean(EditionInfoContributor.class);

                        final Info.Builder builder = new Info.Builder();
                        contributor.contribute(builder);
                        final Info info = builder.build();

                        @SuppressWarnings("unchecked")
                        final Map<String, Object> hazelcastInfo =
                                (Map<String, Object>) info.getDetails().get("hazelcast");

                        assertThat(hazelcastInfo).isNotNull();
                        assertThat(hazelcastInfo.get("edition")).isEqualTo("COMMUNITY");
                        assertThat(hazelcastInfo.get("licenseConfigured")).isEqualTo(false);
                        assertThat(hazelcastInfo).containsKey("availableFeatures");
                        assertThat(hazelcastInfo).containsKey("featureConfiguration");
                    });
        }
    }

    // ========== Test Configuration Classes ==========

    @Configuration
    static class HazelcastConfig {

        @Bean
        HazelcastInstance hazelcastInstance() {
            final HazelcastInstance mock = mock(HazelcastInstance.class);
            // Use real Config (not mockable on Java 25 with Mockito inline)
            final Config config = new Config();
            when(mock.getConfig()).thenReturn(config);
            return mock;
        }
    }

    @Configuration
    static class CustomDetectorConfig {

        @Bean
        EditionDetector editionDetector(HazelcastInstance hazelcast) {
            final EditionProperties props = new EditionProperties();
            props.getEdition().setMode("community");
            final EditionDetector detector = new EditionDetector(props, hazelcast);
            detector.detectEdition();
            return detector;
        }
    }
}
