package com.theyawns.framework.config;

import com.hazelcast.config.Config;
import com.hazelcast.config.EventJournalConfig;
import com.hazelcast.config.IndexConfig;
import com.hazelcast.config.IndexType;
import com.hazelcast.config.JoinConfig;
import com.hazelcast.config.MapConfig;
import com.hazelcast.config.TcpIpConfig;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.util.Arrays;
import java.util.List;

/**
 * Spring configuration for Hazelcast Community Edition.
 * Provides a pre-configured HazelcastInstance suitable for event sourcing.
 *
 * <p>Key configurations:
 * <ul>
 *   <li>Event Journal enabled for pending events maps</li>
 *   <li>Backup configuration for reliability</li>
 *   <li>Near cache for fast view reads</li>
 * </ul>
 *
 * <p>This configuration uses only Community Edition features:
 * <ul>
 *   <li>FlakeIdGenerator for sequence numbers</li>
 *   <li>IMap for storage</li>
 *   <li>ITopic for pub/sub</li>
 *   <li>Jet for pipeline processing</li>
 *   <li>Event Journal for change capture</li>
 * </ul>
 *
 * <p>To customize, provide your own HazelcastInstance bean and this
 * auto-configuration will back off.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Configuration
public class HazelcastConfig {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastConfig.class);

    @Value("${hazelcast.cluster-name:event-sourcing-cluster}")
    private String clusterName;

    @Value("${hazelcast.event-journal.capacity:10000}")
    private int eventJournalCapacity;

    @Value("${hazelcast.event-journal.time-to-live-seconds:3600}")
    private int eventJournalTtlSeconds;

    @Value("${hazelcast.map.backup-count:1}")
    private int backupCount;

    @Value("${hazelcast.network.port:5701}")
    private int networkPort;

    @Value("${hazelcast.network.port-auto-increment:true}")
    private boolean portAutoIncrement;

    @Autowired(required = false)
    private List<HazelcastConfigCustomizer> configCustomizers;

    /**
     * Comma-separated list of cluster member addresses for TCP/IP discovery.
     * If set, TCP/IP join is used instead of multicast (required for Docker).
     * Example: "hazelcast-1:5701,hazelcast-2:5701,hazelcast-3:5701"
     */
    @Value("${hazelcast.cluster.members:#{null}}")
    private String clusterMembers;

    /**
     * Creates a Hazelcast instance configured for event sourcing.
     * Only created if no other HazelcastInstance bean is defined.
     *
     * @return the configured HazelcastInstance
     */
    @Bean
    @ConditionalOnMissingBean(HazelcastInstance.class)
    public HazelcastInstance hazelcastInstance() {
        Config config = new Config();
        config.setClusterName(clusterName);

        // Network configuration
        config.getNetworkConfig()
                .setPort(networkPort)
                .setPortAutoIncrement(portAutoIncrement);

        // Configure cluster discovery
        configureClusterDiscovery(config);

        // Configure pending events maps with Event Journal
        configurePendingMaps(config);

        // Configure event store maps
        configureEventStoreMaps(config);

        // Configure view maps
        configureViewMaps(config);

        // Configure completions maps
        configureCompletionsMaps(config);

        // Configure outbox maps with indexes for efficient polling
        configureOutboxMaps(config);

        // Enable Jet
        config.getJetConfig().setEnabled(true);

        // Apply framework-level customizers (e.g., HD Memory, TPC)
        if (configCustomizers != null) {
            configCustomizers.forEach(c -> c.customize(config));
        }

        logger.info("Creating Hazelcast instance with cluster name: {}", clusterName);
        return Hazelcast.newHazelcastInstance(config);
    }

    /**
     * Configures maps for pending events with Event Journal enabled.
     * These maps trigger the Jet pipeline via their event journals.
     */
    private void configurePendingMaps(Config config) {
        MapConfig pendingMapConfig = new MapConfig("*_PENDING");
        pendingMapConfig.setBackupCount(backupCount);

        // Enable Event Journal - required for Jet pipeline source
        EventJournalConfig journalConfig = new EventJournalConfig()
                .setEnabled(true)
                .setCapacity(eventJournalCapacity)
                .setTimeToLiveSeconds(eventJournalTtlSeconds);
        pendingMapConfig.setEventJournalConfig(journalConfig);

        config.addMapConfig(pendingMapConfig);
        logger.debug("Configured pending maps with event journal capacity: {}", eventJournalCapacity);
    }

    /**
     * Configures maps for event storage.
     * These are append-only and should never be evicted.
     */
    private void configureEventStoreMaps(Config config) {
        MapConfig eventStoreMapConfig = new MapConfig("*_ES");
        eventStoreMapConfig.setBackupCount(backupCount);

        // No eviction for event store - events are permanent
        eventStoreMapConfig.getEvictionConfig()
                .setEvictionPolicy(com.hazelcast.config.EvictionPolicy.NONE);

        config.addMapConfig(eventStoreMapConfig);
        logger.debug("Configured event store maps with backup count: {}", backupCount);
    }

    /**
     * Configures maps for materialized views.
     * These can be rebuilt from events if needed.
     */
    private void configureViewMaps(Config config) {
        MapConfig viewMapConfig = new MapConfig("*_VIEW");
        viewMapConfig.setBackupCount(backupCount);

        // Allow backup reads for faster queries
        viewMapConfig.setReadBackupData(true);

        config.addMapConfig(viewMapConfig);
        logger.debug("Configured view maps with read-backup-data enabled");
    }

    /**
     * Configures maps for completion tracking.
     */
    private void configureCompletionsMaps(Config config) {
        MapConfig completionsMapConfig = new MapConfig("*_COMPLETIONS");
        completionsMapConfig.setBackupCount(backupCount);

        // Completions can be evicted after TTL
        completionsMapConfig.setTimeToLiveSeconds(3600); // 1 hour

        config.addMapConfig(completionsMapConfig);
        logger.debug("Configured completions maps with 1 hour TTL");
    }

    /**
     * Configures the outbox map with indexes for efficient polling.
     * A HASH index on {@code status} avoids full-scan deserialization for
     * equality predicates. A SORTED index on {@code createdAt} enables
     * server-side ordering inside {@code PagingPredicate}.
     */
    private void configureOutboxMaps(Config config) {
        MapConfig outboxMapConfig = new MapConfig("framework_OUTBOX");
        outboxMapConfig.setBackupCount(backupCount);
        outboxMapConfig.addIndexConfig(
                new IndexConfig(IndexType.HASH, "status"));
        outboxMapConfig.addIndexConfig(
                new IndexConfig(IndexType.SORTED, "createdAt"));
        config.addMapConfig(outboxMapConfig);
        logger.debug("Configured outbox map with HASH(status) and SORTED(createdAt) indexes");
    }

    /**
     * Configures cluster discovery mechanism.
     * Uses TCP/IP join if cluster members are specified (Docker/production),
     * otherwise falls back to multicast for local development.
     */
    private void configureClusterDiscovery(Config config) {
        JoinConfig joinConfig = config.getNetworkConfig().getJoin();

        if (clusterMembers != null && !clusterMembers.trim().isEmpty()) {
            // Docker/Production mode: Use TCP/IP discovery
            joinConfig.getMulticastConfig().setEnabled(false);

            TcpIpConfig tcpIpConfig = joinConfig.getTcpIpConfig();
            tcpIpConfig.setEnabled(true);

            List<String> members = Arrays.asList(clusterMembers.split(","));
            for (String member : members) {
                tcpIpConfig.addMember(member.trim());
            }

            logger.info("Configured TCP/IP cluster discovery with members: {}", clusterMembers);
        } else {
            // Development mode: Use multicast for auto-discovery
            joinConfig.getMulticastConfig().setEnabled(true);
            joinConfig.getTcpIpConfig().setEnabled(false);

            logger.info("Configured multicast cluster discovery for local development");
        }
    }
}
