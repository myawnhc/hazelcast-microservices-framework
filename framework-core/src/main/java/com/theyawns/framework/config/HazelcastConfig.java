package com.theyawns.framework.config;

import com.hazelcast.config.Config;
import com.hazelcast.config.EventJournalConfig;
import com.hazelcast.config.MapConfig;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Spring configuration for Hazelcast Community Edition.
 * Provides a pre-configured HazelcastInstance suitable for event sourcing.
 *
 * <p>Key configurations:
 * <ul>
 *   <li>Event Journal enabled for pending events maps</li>
 *   <li>Backup configuration for reliability</li>
 *   <li>Near cache for fast view reads</li>
 * </ul>
 *
 * <p>This configuration uses only Community Edition features:
 * <ul>
 *   <li>FlakeIdGenerator for sequence numbers</li>
 *   <li>IMap for storage</li>
 *   <li>ITopic for pub/sub</li>
 *   <li>Jet for pipeline processing</li>
 *   <li>Event Journal for change capture</li>
 * </ul>
 *
 * <p>To customize, provide your own HazelcastInstance bean and this
 * auto-configuration will back off.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Configuration
public class HazelcastConfig {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastConfig.class);

    @Value("${hazelcast.cluster-name:event-sourcing-cluster}")
    private String clusterName;

    @Value("${hazelcast.event-journal.capacity:10000}")
    private int eventJournalCapacity;

    @Value("${hazelcast.event-journal.time-to-live-seconds:3600}")
    private int eventJournalTtlSeconds;

    @Value("${hazelcast.map.backup-count:1}")
    private int backupCount;

    @Value("${hazelcast.network.port:5701}")
    private int networkPort;

    @Value("${hazelcast.network.port-auto-increment:true}")
    private boolean portAutoIncrement;

    /**
     * Creates a Hazelcast instance configured for event sourcing.
     * Only created if no other HazelcastInstance bean is defined.
     *
     * @return the configured HazelcastInstance
     */
    @Bean
    @ConditionalOnMissingBean(HazelcastInstance.class)
    public HazelcastInstance hazelcastInstance() {
        Config config = new Config();
        config.setClusterName(clusterName);

        // Network configuration
        config.getNetworkConfig()
                .setPort(networkPort)
                .setPortAutoIncrement(portAutoIncrement);

        // Enable multicast for development (auto-discovery)
        config.getNetworkConfig().getJoin().getMulticastConfig()
                .setEnabled(true);

        // Configure pending events maps with Event Journal
        configurePendingMaps(config);

        // Configure event store maps
        configureEventStoreMaps(config);

        // Configure view maps
        configureViewMaps(config);

        // Configure completions maps
        configureCompletionsMaps(config);

        // Enable Jet
        config.getJetConfig().setEnabled(true);

        logger.info("Creating Hazelcast instance with cluster name: {}", clusterName);
        return Hazelcast.newHazelcastInstance(config);
    }

    /**
     * Configures maps for pending events with Event Journal enabled.
     * These maps trigger the Jet pipeline via their event journals.
     */
    private void configurePendingMaps(Config config) {
        MapConfig pendingMapConfig = new MapConfig("*_PENDING");
        pendingMapConfig.setBackupCount(backupCount);

        // Enable Event Journal - required for Jet pipeline source
        EventJournalConfig journalConfig = new EventJournalConfig()
                .setEnabled(true)
                .setCapacity(eventJournalCapacity)
                .setTimeToLiveSeconds(eventJournalTtlSeconds);
        pendingMapConfig.setEventJournalConfig(journalConfig);

        config.addMapConfig(pendingMapConfig);
        logger.debug("Configured pending maps with event journal capacity: {}", eventJournalCapacity);
    }

    /**
     * Configures maps for event storage.
     * These are append-only and should never be evicted.
     */
    private void configureEventStoreMaps(Config config) {
        MapConfig eventStoreMapConfig = new MapConfig("*_ES");
        eventStoreMapConfig.setBackupCount(backupCount);

        // No eviction for event store - events are permanent
        eventStoreMapConfig.getEvictionConfig()
                .setEvictionPolicy(com.hazelcast.config.EvictionPolicy.NONE);

        config.addMapConfig(eventStoreMapConfig);
        logger.debug("Configured event store maps with backup count: {}", backupCount);
    }

    /**
     * Configures maps for materialized views.
     * These can be rebuilt from events if needed.
     */
    private void configureViewMaps(Config config) {
        MapConfig viewMapConfig = new MapConfig("*_VIEW");
        viewMapConfig.setBackupCount(backupCount);

        // Allow backup reads for faster queries
        viewMapConfig.setReadBackupData(true);

        config.addMapConfig(viewMapConfig);
        logger.debug("Configured view maps with read-backup-data enabled");
    }

    /**
     * Configures maps for completion tracking.
     */
    private void configureCompletionsMaps(Config config) {
        MapConfig completionsMapConfig = new MapConfig("*_COMPLETIONS");
        completionsMapConfig.setBackupCount(backupCount);

        // Completions can be evicted after TTL
        completionsMapConfig.setTimeToLiveSeconds(3600); // 1 hour

        config.addMapConfig(completionsMapConfig);
        logger.debug("Configured completions maps with 1 hour TTL");
    }
}
