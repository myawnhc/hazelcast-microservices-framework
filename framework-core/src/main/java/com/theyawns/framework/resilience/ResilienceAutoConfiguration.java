package com.theyawns.framework.resilience;

import io.github.resilience4j.circuitbreaker.CircuitBreakerConfig;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.micrometer.tagged.TaggedCircuitBreakerMetrics;
import io.github.resilience4j.micrometer.tagged.TaggedRetryMetrics;
import io.github.resilience4j.retry.RetryConfig;
import io.github.resilience4j.retry.RetryRegistry;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import java.time.Duration;

/**
 * Auto-configuration for Resilience4j circuit breaker and retry integration.
 *
 * <p>This configuration is enabled by default when Resilience4j is on the classpath
 * and provides:
 * <ul>
 *   <li>{@link CircuitBreakerRegistry} - Configured from {@link ResilienceProperties}</li>
 *   <li>{@link RetryRegistry} - Configured with optional exponential backoff</li>
 *   <li>{@link ResilientServiceInvoker} - General-purpose resilient operation wrapper</li>
 *   <li>Micrometer metrics bindings for circuit breaker and retry</li>
 * </ul>
 *
 * <p>To disable all resilience features, set:
 * <pre>
 * framework.resilience.enabled=false
 * </pre>
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see ResilienceProperties
 * @see ResilientServiceInvoker
 */
@Configuration
@ConditionalOnClass(CircuitBreakerRegistry.class)
@ConditionalOnProperty(name = "framework.resilience.enabled", matchIfMissing = true)
@EnableConfigurationProperties(ResilienceProperties.class)
public class ResilienceAutoConfiguration {

    private static final Logger logger = LoggerFactory.getLogger(ResilienceAutoConfiguration.class);

    /**
     * Creates the CircuitBreakerRegistry bean configured from properties.
     *
     * @param properties the resilience configuration properties
     * @return the circuit breaker registry
     */
    @Bean
    @ConditionalOnMissingBean
    public CircuitBreakerRegistry circuitBreakerRegistry(final ResilienceProperties properties) {
        final ResilienceProperties.CircuitBreakerProperties cbProps = properties.getCircuitBreaker();

        final CircuitBreakerConfig defaultConfig = CircuitBreakerConfig.custom()
                .failureRateThreshold(cbProps.getFailureRateThreshold())
                .waitDurationInOpenState(cbProps.getWaitDurationInOpenState())
                .slidingWindowSize(cbProps.getSlidingWindowSize())
                .slidingWindowType(mapSlidingWindowType(cbProps.getSlidingWindowType()))
                .minimumNumberOfCalls(cbProps.getMinimumNumberOfCalls())
                .permittedNumberOfCallsInHalfOpenState(cbProps.getPermittedNumberOfCallsInHalfOpenState())
                .build();

        final CircuitBreakerRegistry registry = CircuitBreakerRegistry.of(defaultConfig);

        logger.info("Created CircuitBreakerRegistry with default config: failureRateThreshold={}, " +
                        "waitDurationInOpenState={}, slidingWindowSize={}, slidingWindowType={}",
                cbProps.getFailureRateThreshold(),
                cbProps.getWaitDurationInOpenState(),
                cbProps.getSlidingWindowSize(),
                cbProps.getSlidingWindowType());

        return registry;
    }

    /**
     * Creates the RetryRegistry bean configured from properties.
     *
     * @param properties the resilience configuration properties
     * @return the retry registry
     */
    @Bean
    @ConditionalOnMissingBean
    public RetryRegistry retryRegistry(final ResilienceProperties properties) {
        final ResilienceProperties.RetryProperties retryProps = properties.getRetry();

        final RetryConfig.Builder<?> builder = RetryConfig.custom()
                .maxAttempts(retryProps.getMaxAttempts());

        if (retryProps.isEnableExponentialBackoff()) {
            builder.intervalFunction(io.github.resilience4j.core.IntervalFunction
                    .ofExponentialBackoff(
                            retryProps.getWaitDuration(),
                            retryProps.getExponentialBackoffMultiplier()));
        } else {
            builder.waitDuration(retryProps.getWaitDuration());
        }

        final RetryRegistry registry = RetryRegistry.of(builder.build());

        logger.info("Created RetryRegistry with default config: maxAttempts={}, " +
                        "waitDuration={}, exponentialBackoff={}, multiplier={}",
                retryProps.getMaxAttempts(),
                retryProps.getWaitDuration(),
                retryProps.isEnableExponentialBackoff(),
                retryProps.getExponentialBackoffMultiplier());

        return registry;
    }

    /**
     * Creates the ResilientServiceInvoker bean.
     *
     * @param circuitBreakerRegistry the circuit breaker registry
     * @param retryRegistry the retry registry
     * @param properties the resilience properties
     * @return the resilient service invoker
     */
    @Bean
    @ConditionalOnMissingBean
    public ResilientServiceInvoker resilientServiceInvoker(
            final CircuitBreakerRegistry circuitBreakerRegistry,
            final RetryRegistry retryRegistry,
            final ResilienceProperties properties) {
        logger.info("Creating ResilientServiceInvoker bean (enabled={})", properties.isEnabled());
        return new ResilientServiceInvoker(circuitBreakerRegistry, retryRegistry, properties);
    }

    /**
     * Binds circuit breaker metrics to Micrometer.
     *
     * @param circuitBreakerRegistry the circuit breaker registry
     * @param meterRegistry the Micrometer meter registry
     * @return the tagged circuit breaker metrics
     */
    @Bean
    @ConditionalOnMissingBean(TaggedCircuitBreakerMetrics.class)
    public TaggedCircuitBreakerMetrics taggedCircuitBreakerMetrics(
            final CircuitBreakerRegistry circuitBreakerRegistry,
            final MeterRegistry meterRegistry) {
        final TaggedCircuitBreakerMetrics metrics =
                TaggedCircuitBreakerMetrics.ofCircuitBreakerRegistry(circuitBreakerRegistry);
        metrics.bindTo(meterRegistry);
        logger.debug("Bound circuit breaker metrics to Micrometer");
        return metrics;
    }

    /**
     * Binds retry metrics to Micrometer.
     *
     * @param retryRegistry the retry registry
     * @param meterRegistry the Micrometer meter registry
     * @return the tagged retry metrics
     */
    @Bean
    @ConditionalOnMissingBean(TaggedRetryMetrics.class)
    public TaggedRetryMetrics taggedRetryMetrics(
            final RetryRegistry retryRegistry,
            final MeterRegistry meterRegistry) {
        final TaggedRetryMetrics metrics = TaggedRetryMetrics.ofRetryRegistry(retryRegistry);
        metrics.bindTo(meterRegistry);
        logger.debug("Bound retry metrics to Micrometer");
        return metrics;
    }

    /**
     * Maps the framework's SlidingWindowType to Resilience4j's SlidingWindowType.
     */
    private static CircuitBreakerConfig.SlidingWindowType mapSlidingWindowType(
            final ResilienceProperties.SlidingWindowType type) {
        return switch (type) {
            case COUNT_BASED -> CircuitBreakerConfig.SlidingWindowType.COUNT_BASED;
            case TIME_BASED -> CircuitBreakerConfig.SlidingWindowType.TIME_BASED;
        };
    }
}
