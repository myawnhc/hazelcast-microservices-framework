package com.theyawns.framework.resilience;

import io.github.resilience4j.circuitbreaker.CallNotPermittedException;
import io.github.resilience4j.circuitbreaker.CircuitBreaker;
import io.github.resilience4j.circuitbreaker.CircuitBreakerRegistry;
import io.github.resilience4j.retry.Retry;
import io.github.resilience4j.retry.RetryRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.concurrent.CompletableFuture;
import java.util.function.Supplier;

/**
 * General-purpose invoker that decorates operations with Resilience4j circuit breaker and retry.
 *
 * <p>Wraps {@link Supplier}, {@link Runnable}, and {@link CompletableFuture}-returning operations
 * with configurable resilience patterns. This is designed for Hazelcast ITopic pub/sub-based
 * service communication rather than HTTP calls.
 *
 * <p>When resilience is disabled ({@code framework.resilience.enabled=false}), all methods
 * delegate directly to the underlying operation without any decoration.
 *
 * <p>Usage example:
 * <pre>{@code
 * // Synchronous call with circuit breaker + retry
 * String result = invoker.execute("orderSaga", () -> {
 *     return processOrderEvent(event);
 * });
 *
 * // Void operation
 * invoker.executeRunnable("paymentListener", () -> {
 *     publishToTopic(event);
 * });
 *
 * // Async operation
 * CompletableFuture<OrderResult> future = invoker.executeAsync("orderAsync", () -> {
 *     return orderService.processAsync(order);
 * });
 * }</pre>
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see ResilienceAutoConfiguration
 * @see ResilienceProperties
 */
public class ResilientServiceInvoker implements ResilientOperations {

    private static final Logger logger = LoggerFactory.getLogger(ResilientServiceInvoker.class);

    /**
     * Registry for circuit breaker instances.
     */
    private final CircuitBreakerRegistry circuitBreakerRegistry;

    /**
     * Registry for retry instances.
     */
    private final RetryRegistry retryRegistry;

    /**
     * Resilience configuration properties.
     */
    private final ResilienceProperties properties;

    /**
     * Creates a new ResilientServiceInvoker.
     *
     * @param circuitBreakerRegistry the circuit breaker registry
     * @param retryRegistry the retry registry
     * @param properties the resilience configuration properties
     */
    public ResilientServiceInvoker(
            final CircuitBreakerRegistry circuitBreakerRegistry,
            final RetryRegistry retryRegistry,
            final ResilienceProperties properties) {
        this.circuitBreakerRegistry = circuitBreakerRegistry;
        this.retryRegistry = retryRegistry;
        this.properties = properties;
    }

    /**
     * Executes a synchronous operation with circuit breaker and retry protection.
     *
     * <p>The operation is first decorated with retry, then with circuit breaker.
     * This means the circuit breaker evaluates the final outcome (after retries are exhausted).
     *
     * @param name the name of the operation (used for circuit breaker and retry instance lookup)
     * @param operation the operation to execute
     * @param <T> the return type
     * @return the result of the operation
     * @throws ResilienceException if the operation fails after retries or circuit breaker rejects the call
     */
    public <T> T execute(final String name, final Supplier<T> operation) {
        if (!properties.isEnabled()) {
            return operation.get();
        }

        final CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(name);
        final Retry retry = retryRegistry.retry(name);

        final Supplier<T> decoratedSupplier = CircuitBreaker.decorateSupplier(circuitBreaker,
                Retry.decorateSupplier(retry, operation));

        try {
            return decoratedSupplier.get();
        } catch (CallNotPermittedException e) {
            logger.warn("Circuit breaker '{}' is OPEN — rejecting call", name);
            throw new ResilienceException(
                    "Circuit breaker '" + name + "' is open, call rejected", name, e);
        } catch (Exception e) {
            logger.error("Operation '{}' failed after retries: {}", name, e.getMessage());
            throw new ResilienceException(
                    "Operation '" + name + "' failed after retries", name, e);
        }
    }

    /**
     * Executes a void operation with circuit breaker and retry protection.
     *
     * @param name the name of the operation
     * @param operation the void operation to execute
     * @throws ResilienceException if the operation fails after retries or circuit breaker rejects the call
     */
    public void executeRunnable(final String name, final Runnable operation) {
        if (!properties.isEnabled()) {
            operation.run();
            return;
        }

        final CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(name);
        final Retry retry = retryRegistry.retry(name);

        final Runnable decoratedRunnable = CircuitBreaker.decorateRunnable(circuitBreaker,
                Retry.decorateRunnable(retry, operation));

        try {
            decoratedRunnable.run();
        } catch (CallNotPermittedException e) {
            logger.warn("Circuit breaker '{}' is OPEN — rejecting call", name);
            throw new ResilienceException(
                    "Circuit breaker '" + name + "' is open, call rejected", name, e);
        } catch (Exception e) {
            logger.error("Operation '{}' failed after retries: {}", name, e.getMessage());
            throw new ResilienceException(
                    "Operation '" + name + "' failed after retries", name, e);
        }
    }

    /**
     * Executes an asynchronous operation with circuit breaker and retry protection.
     *
     * <p>The supplier must return a {@link CompletableFuture}. The circuit breaker and retry
     * are applied to the supplier invocation (i.e., the future creation), not to the
     * future's completion.
     *
     * @param name the name of the operation
     * @param operation the async operation supplier
     * @param <T> the return type
     * @return a CompletableFuture with the operation result
     */
    public <T> CompletableFuture<T> executeAsync(
            final String name, final Supplier<CompletableFuture<T>> operation) {
        if (!properties.isEnabled()) {
            return operation.get();
        }

        final CircuitBreaker circuitBreaker = circuitBreakerRegistry.circuitBreaker(name);
        final Retry retry = retryRegistry.retry(name);

        final Supplier<CompletableFuture<T>> decoratedSupplier =
                CircuitBreaker.decorateSupplier(circuitBreaker,
                        Retry.decorateSupplier(retry, operation));

        try {
            return decoratedSupplier.get();
        } catch (CallNotPermittedException e) {
            logger.warn("Circuit breaker '{}' is OPEN — rejecting async call", name);
            return CompletableFuture.failedFuture(new ResilienceException(
                    "Circuit breaker '" + name + "' is open, call rejected", name, e));
        } catch (Exception e) {
            logger.error("Async operation '{}' failed after retries: {}", name, e.getMessage());
            return CompletableFuture.failedFuture(new ResilienceException(
                    "Operation '" + name + "' failed after retries", name, e));
        }
    }

    /**
     * Returns the circuit breaker instance for the given name.
     *
     * <p>Useful for monitoring and testing circuit breaker state.
     *
     * @param name the circuit breaker instance name
     * @return the circuit breaker instance
     */
    public CircuitBreaker getCircuitBreaker(final String name) {
        return circuitBreakerRegistry.circuitBreaker(name);
    }

    /**
     * Returns the retry instance for the given name.
     *
     * <p>Useful for monitoring and testing retry metrics.
     *
     * @param name the retry instance name
     * @return the retry instance
     */
    public Retry getRetry(final String name) {
        return retryRegistry.retry(name);
    }

    /**
     * Returns whether resilience features are enabled.
     *
     * @return true if enabled
     */
    public boolean isEnabled() {
        return properties.isEnabled();
    }
}
