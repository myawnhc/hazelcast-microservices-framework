package com.theyawns.framework.view;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.framework.domain.DomainObject;
import com.theyawns.framework.event.DomainEvent;
import com.theyawns.framework.store.EventStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Objects;
import java.util.Optional;

/**
 * Abstract base class for updating materialized views from domain events.
 * Provides the orchestration logic for applying events to views while allowing
 * subclasses to customize the event application behavior.
 *
 * <p>Key responsibilities:
 * <ul>
 *   <li>Coordinate between events and view updates</li>
 *   <li>Extract keys from event records</li>
 *   <li>Apply events to produce updated view state</li>
 *   <li>Support both single updates and bulk rebuilds</li>
 * </ul>
 *
 * <p>Subclasses must implement:
 * <ul>
 *   <li>{@link #extractKey(GenericRecord)} - Extract the domain object key from an event</li>
 *   <li>{@link #applyEvent(GenericRecord, GenericRecord)} - Apply event to current state</li>
 * </ul>
 *
 * <p>Example subclass implementation:
 * <pre>{@code
 * public class CustomerViewUpdater extends ViewUpdater<String> {
 *
 *     public CustomerViewUpdater(HazelcastViewStore<String> viewStore) {
 *         super(viewStore);
 *     }
 *
 *     @Override
 *     protected String extractKey(GenericRecord eventRecord) {
 *         return eventRecord.getString("customerId");
 *     }
 *
 *     @Override
 *     protected GenericRecord applyEvent(GenericRecord eventRecord, GenericRecord currentState) {
 *         String eventType = eventRecord.getString("eventType");
 *         return switch (eventType) {
 *             case "CustomerCreated" -> createCustomer(eventRecord);
 *             case "CustomerUpdated" -> updateCustomer(eventRecord, currentState);
 *             case "CustomerDeleted" -> null; // Delete
 *             default -> currentState;
 *         };
 *     }
 * }
 * }</pre>
 *
 * @param <K> The key type for the view entries
 * @author Generated by Claude Code
 * @since 1.0
 */
public abstract class ViewUpdater<K> {

    private static final Logger logger = LoggerFactory.getLogger(ViewUpdater.class);

    /**
     * The view store to update.
     */
    protected final HazelcastViewStore<K> viewStore;

    /**
     * Creates a ViewUpdater for the given view store.
     *
     * @param viewStore the view store to update
     * @throws NullPointerException if viewStore is null
     */
    protected ViewUpdater(HazelcastViewStore<K> viewStore) {
        this.viewStore = Objects.requireNonNull(viewStore, "viewStore cannot be null");
    }

    /**
     * Extracts the domain object key from an event record.
     * This key is used to locate the view entry to update.
     *
     * @param eventRecord the event record
     * @return the extracted key
     */
    protected abstract K extractKey(GenericRecord eventRecord);

    /**
     * Applies an event to the current view state to produce updated state.
     *
     * <p>Implementation guidelines:
     * <ul>
     *   <li>Check the event type to determine the appropriate action</li>
     *   <li>For creation events, currentState will be null</li>
     *   <li>Return null to delete the view entry</li>
     *   <li>Return currentState unchanged to skip the update</li>
     * </ul>
     *
     * @param eventRecord the event to apply
     * @param currentState the current view state (may be null for creation events)
     * @return the updated state, or null to delete the entry
     */
    protected abstract GenericRecord applyEvent(GenericRecord eventRecord, GenericRecord currentState);

    /**
     * Updates the view for a single event using an entry processor for atomicity.
     * This is the primary method for real-time view updates from the event pipeline.
     *
     * @param eventRecord the event to process
     * @return the updated view state
     */
    public GenericRecord update(GenericRecord eventRecord) {
        Objects.requireNonNull(eventRecord, "eventRecord cannot be null");

        K key = extractKey(eventRecord);
        if (key == null) {
            logger.warn("Could not extract key from event: {}", eventRecord);
            return null;
        }

        logger.debug("Updating view for key {} from event type: {}",
                key, getEventType(eventRecord));

        // Use entry processor for atomic update
        UpdateViewEntryProcessor<K> processor = new UpdateViewEntryProcessor<>(
                currentState -> applyEvent(eventRecord, currentState),
                eventRecord
        );

        return viewStore.executeOnKey(key, processor);
    }

    /**
     * Updates the view directly without using an entry processor.
     * This is useful when atomicity is already guaranteed (e.g., during rebuild).
     *
     * @param eventRecord the event to process
     * @return the updated view state
     */
    public GenericRecord updateDirect(GenericRecord eventRecord) {
        Objects.requireNonNull(eventRecord, "eventRecord cannot be null");

        K key = extractKey(eventRecord);
        if (key == null) {
            logger.warn("Could not extract key from event: {}", eventRecord);
            return null;
        }

        GenericRecord currentState = viewStore.get(key).orElse(null);
        GenericRecord updatedState = applyEvent(eventRecord, currentState);

        if (updatedState != null) {
            viewStore.put(key, updatedState);
        } else if (currentState != null) {
            viewStore.remove(key);
        }

        return updatedState;
    }

    /**
     * Rebuilds the entire view from the event store.
     * Clears the existing view and replays all events in sequence order.
     *
     * @param <D> the domain object type
     * @param <E> the event type
     * @param eventStore the event store to replay events from
     * @return the number of events processed
     */
    public <D extends DomainObject<K>, E extends DomainEvent<D, K>> long rebuild(
            EventStore<D, K, E> eventStore) {
        Objects.requireNonNull(eventStore, "eventStore cannot be null");

        logger.info("Starting view rebuild for {} from {}",
                viewStore.getViewName(), eventStore.getStoreName());

        return viewStore.rebuild(eventStore, this::updateDirect);
    }

    /**
     * Rebuilds the view entry for a single key from the event store.
     *
     * @param <D> the domain object type
     * @param <E> the event type
     * @param key the key to rebuild
     * @param eventStore the event store to replay events from
     * @return the final view state, or empty if no events exist for the key
     */
    public <D extends DomainObject<K>, E extends DomainEvent<D, K>> Optional<GenericRecord> rebuildForKey(
            K key,
            EventStore<D, K, E> eventStore) {
        Objects.requireNonNull(key, "key cannot be null");
        Objects.requireNonNull(eventStore, "eventStore cannot be null");

        logger.debug("Rebuilding view entry for key: {}", key);

        // Remove existing entry
        viewStore.remove(key);

        // Track current state through event replay
        final GenericRecord[] state = {null};

        // Replay events for this key
        eventStore.replayByKey(key, eventRecord -> {
            state[0] = applyEvent(eventRecord, state[0]);
        });

        // Store final state
        if (state[0] != null) {
            viewStore.put(key, state[0]);
            return Optional.of(state[0]);
        }

        return Optional.empty();
    }

    /**
     * Returns the view store associated with this updater.
     *
     * @return the view store
     */
    public HazelcastViewStore<K> getViewStore() {
        return viewStore;
    }

    /**
     * Helper method to safely extract the event type from an event record.
     *
     * @param eventRecord the event record
     * @return the event type, or "unknown" if not available
     */
    protected String getEventType(GenericRecord eventRecord) {
        try {
            return eventRecord.getString("eventType");
        } catch (Exception e) {
            return "unknown";
        }
    }

    /**
     * Helper method to safely extract a string field from an event record.
     *
     * @param eventRecord the event record
     * @param fieldName the field name
     * @return the field value, or null if not available
     */
    protected String getStringField(GenericRecord eventRecord, String fieldName) {
        try {
            return eventRecord.getString(fieldName);
        } catch (Exception e) {
            return null;
        }
    }

    /**
     * Helper method to safely extract a long field from an event record.
     *
     * @param eventRecord the event record
     * @param fieldName the field name
     * @return the field value, or 0 if not available
     */
    protected long getLongField(GenericRecord eventRecord, String fieldName) {
        try {
            return eventRecord.getInt64(fieldName);
        } catch (Exception e) {
            return 0L;
        }
    }

    /**
     * Helper method to safely extract an int field from an event record.
     *
     * @param eventRecord the event record
     * @param fieldName the field name
     * @return the field value, or 0 if not available
     */
    protected int getIntField(GenericRecord eventRecord, String fieldName) {
        try {
            return eventRecord.getInt32(fieldName);
        } catch (Exception e) {
            return 0;
        }
    }
}
