package com.theyawns.framework.view;

import com.hazelcast.map.EntryProcessor;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;

import java.io.Serializable;
import java.util.Map;
import java.util.Objects;
import java.util.function.UnaryOperator;

/**
 * Hazelcast EntryProcessor for atomic view updates.
 * Applies an event to the current view state to produce the updated state.
 *
 * <p>This processor ensures atomic updates by executing within the partition thread
 * of the target key, eliminating race conditions between concurrent updates.
 *
 * <p>Key characteristics:
 * <ul>
 *   <li>Atomic execution within partition thread</li>
 *   <li>Supports both creation (null current state) and update scenarios</li>
 *   <li>Uses functional interface for event application logic</li>
 *   <li>Returns the updated state for confirmation</li>
 * </ul>
 *
 * <p>Example usage with HazelcastViewStore:
 * <pre>{@code
 * // Create processor with event application logic
 * UpdateViewEntryProcessor<String> processor = new UpdateViewEntryProcessor<>(
 *     currentState -> event.apply(currentState)
 * );
 *
 * // Execute atomically on the view
 * GenericRecord result = viewStore.executeOnKey(customerId, processor);
 * }</pre>
 *
 * <p>Example usage with DomainEvent:
 * <pre>{@code
 * // Apply a CustomerCreatedEvent
 * CustomerCreatedEvent event = new CustomerCreatedEvent("cust-123", "john@example.com");
 * UpdateViewEntryProcessor<String> processor = new UpdateViewEntryProcessor<>(event::apply);
 * viewStore.executeOnKey("cust-123", processor);
 * }</pre>
 *
 * @param <K> The key type of the view entries
 * @author Generated by Claude Code
 * @since 1.0
 */
public class UpdateViewEntryProcessor<K> implements EntryProcessor<K, GenericRecord, GenericRecord>, Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * The function that applies an event to produce updated state.
     * Takes the current state (may be null for creation) and returns the new state.
     */
    private final UnaryOperator<GenericRecord> eventApplier;

    /**
     * Optional: The event record being applied (for logging/debugging).
     */
    private final GenericRecord eventRecord;

    /**
     * Creates an UpdateViewEntryProcessor with the given event application logic.
     *
     * @param eventApplier function that takes current state and returns updated state
     * @throws NullPointerException if eventApplier is null
     */
    public UpdateViewEntryProcessor(UnaryOperator<GenericRecord> eventApplier) {
        this(eventApplier, null);
    }

    /**
     * Creates an UpdateViewEntryProcessor with the given event application logic
     * and event record for debugging/logging purposes.
     *
     * @param eventApplier function that takes current state and returns updated state
     * @param eventRecord the event record being applied (optional, for debugging)
     * @throws NullPointerException if eventApplier is null
     */
    public UpdateViewEntryProcessor(UnaryOperator<GenericRecord> eventApplier, GenericRecord eventRecord) {
        this.eventApplier = Objects.requireNonNull(eventApplier, "eventApplier cannot be null");
        this.eventRecord = eventRecord;
    }

    /**
     * Processes the map entry by applying the event to produce updated state.
     *
     * <p>This method is executed atomically within the partition thread,
     * ensuring no concurrent modifications can occur during processing.
     *
     * @param entry the map entry to process
     * @return the updated GenericRecord state
     */
    @Override
    public GenericRecord process(Map.Entry<K, GenericRecord> entry) {
        GenericRecord currentState = entry.getValue();
        GenericRecord updatedState = eventApplier.apply(currentState);

        if (updatedState != null) {
            entry.setValue(updatedState);
        } else if (currentState != null) {
            // If the applier returns null, it means delete the entry
            // This supports deletion events
            ((com.hazelcast.map.ExtendedMapEntry<K, GenericRecord>) entry).setValue(null);
        }

        return updatedState;
    }

    /**
     * Returns the event record associated with this processor, if any.
     *
     * @return the event record, or null if not set
     */
    public GenericRecord getEventRecord() {
        return eventRecord;
    }

    /**
     * Creates an UpdateViewEntryProcessor from a DomainEvent.
     * This is a convenience factory method for common use cases.
     *
     * @param <K> the key type
     * @param event the domain event to apply
     * @return a new UpdateViewEntryProcessor that applies the event
     * @throws NullPointerException if event is null
     */
    public static <K> UpdateViewEntryProcessor<K> fromEvent(
            com.theyawns.framework.event.DomainEvent<?, K> event) {
        Objects.requireNonNull(event, "event cannot be null");
        return new UpdateViewEntryProcessor<>(event::apply, event.toGenericRecord());
    }

    /**
     * Creates an UpdateViewEntryProcessor that always sets a specific value.
     * Useful for initial creation or full replacement scenarios.
     *
     * @param <K> the key type
     * @param value the value to set
     * @return a new UpdateViewEntryProcessor that sets the value
     * @throws NullPointerException if value is null
     */
    public static <K> UpdateViewEntryProcessor<K> setValue(GenericRecord value) {
        Objects.requireNonNull(value, "value cannot be null");
        return new UpdateViewEntryProcessor<>(current -> value);
    }

    /**
     * Creates an UpdateViewEntryProcessor that deletes the entry.
     * The processor will return null and remove the entry from the map.
     *
     * @param <K> the key type
     * @return a new UpdateViewEntryProcessor that deletes the entry
     */
    public static <K> UpdateViewEntryProcessor<K> delete() {
        return new UpdateViewEntryProcessor<>(current -> null);
    }
}
