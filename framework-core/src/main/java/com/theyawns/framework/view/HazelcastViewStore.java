package com.theyawns.framework.view;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.framework.domain.DomainObject;
import com.theyawns.framework.event.DomainEvent;
import com.theyawns.framework.store.EventStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collection;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Predicate;
import java.util.function.UnaryOperator;
import java.util.stream.Collectors;

/**
 * Hazelcast IMap-based implementation of the MaterializedViewStore.
 * Provides fast read access to denormalized domain object state derived from events.
 *
 * <p>Key characteristics:
 * <ul>
 *   <li>Stores domain object state as GenericRecord for schema flexibility</li>
 *   <li>Supports view rebuilding from EventStore</li>
 *   <li>Thread-safe for concurrent access</li>
 *   <li>Optimized for read performance with optional near-cache support</li>
 * </ul>
 *
 * <p>Map naming convention: {@code {domainName}_VIEW}
 *
 * <p>Example usage:
 * <pre>{@code
 * // Create view store
 * HazelcastViewStore<String> viewStore = new HazelcastViewStore<>(hazelcast, "Customer");
 *
 * // Read from view
 * Optional<GenericRecord> customer = viewStore.get("cust-123");
 *
 * // Update view (typically via UpdateViewEntryProcessor)
 * viewStore.put("cust-123", customerRecord);
 *
 * // Rebuild view from events
 * viewStore.rebuild(eventStore, event -> event.apply(viewStore.get(key).orElse(null)));
 * }</pre>
 *
 * @param <K> The key type for view entries
 * @author Generated by Claude Code
 * @since 1.0
 */
public class HazelcastViewStore<K> implements MaterializedViewStore<K> {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastViewStore.class);

    private final HazelcastInstance hazelcast;
    private final String viewName;
    private final IMap<K, GenericRecord> viewMap;

    /**
     * Creates a new HazelcastViewStore.
     *
     * @param hazelcast the Hazelcast instance
     * @param domainName the domain name (used for map naming)
     * @throws NullPointerException if hazelcast or domainName is null
     */
    public HazelcastViewStore(HazelcastInstance hazelcast, String domainName) {
        this.hazelcast = Objects.requireNonNull(hazelcast, "hazelcast cannot be null");
        Objects.requireNonNull(domainName, "domainName cannot be null");
        this.viewName = domainName + "_VIEW";
        this.viewMap = hazelcast.getMap(viewName);
        logger.info("Initialized ViewStore: {}", viewName);
    }

    @Override
    public Optional<GenericRecord> get(K key) {
        Objects.requireNonNull(key, "key cannot be null");
        return Optional.ofNullable(viewMap.get(key));
    }

    @Override
    public void put(K key, GenericRecord value) {
        Objects.requireNonNull(key, "key cannot be null");
        Objects.requireNonNull(value, "value cannot be null");
        viewMap.set(key, value);
        logger.debug("Updated view entry for key: {}", key);
    }

    @Override
    public GenericRecord remove(K key) {
        Objects.requireNonNull(key, "key cannot be null");
        GenericRecord removed = viewMap.remove(key);
        if (removed != null) {
            logger.debug("Removed view entry for key: {}", key);
        }
        return removed;
    }

    @Override
    public boolean containsKey(K key) {
        Objects.requireNonNull(key, "key cannot be null");
        return viewMap.containsKey(key);
    }

    @Override
    public Collection<K> keys() {
        return viewMap.keySet();
    }

    @Override
    public Collection<GenericRecord> values() {
        return viewMap.values();
    }

    @Override
    public Collection<GenericRecord> query(Predicate<GenericRecord> predicate) {
        Objects.requireNonNull(predicate, "predicate cannot be null");
        return viewMap.values().stream()
                .filter(predicate)
                .collect(Collectors.toList());
    }

    @Override
    public int size() {
        return viewMap.size();
    }

    @Override
    public void clear() {
        viewMap.clear();
        logger.info("Cleared view: {}", viewName);
    }

    @Override
    public String getViewName() {
        return viewName;
    }

    /**
     * Executes an entry processor atomically on a specific key.
     * This is the preferred way to update views as it ensures consistency.
     *
     * @param key the key to update
     * @param entryProcessor the entry processor to execute
     * @param <R> the return type of the entry processor
     * @return the result of the entry processor
     */
    public <R> R executeOnKey(K key, com.hazelcast.map.EntryProcessor<K, GenericRecord, R> entryProcessor) {
        Objects.requireNonNull(key, "key cannot be null");
        Objects.requireNonNull(entryProcessor, "entryProcessor cannot be null");
        return viewMap.executeOnKey(key, entryProcessor);
    }

    /**
     * Rebuilds the view from scratch by replaying all events from the EventStore.
     * This clears the existing view first and then applies each event in sequence order.
     *
     * <p>The eventApplier function should:
     * <ol>
     *   <li>Extract the key from the event record</li>
     *   <li>Get the current state (if any) from this view</li>
     *   <li>Apply the event to produce new state</li>
     *   <li>Store the new state back in this view</li>
     * </ol>
     *
     * <p>Example:
     * <pre>{@code
     * viewStore.rebuild(eventStore, eventRecord -> {
     *     String key = eventRecord.getString("key");
     *     GenericRecord currentState = viewStore.get(key).orElse(null);
     *     DomainEvent event = hydrationFactory.hydrateEvent(eventRecord);
     *     GenericRecord newState = event.apply(currentState);
     *     viewStore.put(key, newState);
     * });
     * }</pre>
     *
     * @param <D> the domain object type
     * @param <E> the event type
     * @param eventStore the event store to replay events from
     * @param eventApplier function that applies each event to update the view
     * @return the number of events processed
     */
    public <D extends DomainObject<K>, E extends DomainEvent<D, K>> long rebuild(
            EventStore<D, K, E> eventStore,
            java.util.function.Consumer<GenericRecord> eventApplier) {
        Objects.requireNonNull(eventStore, "eventStore cannot be null");
        Objects.requireNonNull(eventApplier, "eventApplier cannot be null");

        logger.info("Starting view rebuild for {} from {}", viewName, eventStore.getStoreName());
        long startTime = System.currentTimeMillis();

        // Clear existing view
        clear();

        // Track events processed
        final long[] count = {0};

        // Replay all events
        eventStore.replayAll(eventRecord -> {
            eventApplier.accept(eventRecord);
            count[0]++;
        });

        long duration = System.currentTimeMillis() - startTime;
        logger.info("Completed view rebuild for {}: {} events processed in {}ms",
                viewName, count[0], duration);

        return count[0];
    }

    /**
     * Rebuilds the view for a single domain object by replaying its events.
     * This updates or creates the view entry for the specified key without affecting other entries.
     *
     * @param <D> the domain object type
     * @param <E> the event type
     * @param key the domain object key to rebuild
     * @param eventStore the event store to replay events from
     * @param eventApplier function that applies each event and returns the new state
     * @return the final state after replaying all events, or empty if no events exist
     */
    public <D extends DomainObject<K>, E extends DomainEvent<D, K>> Optional<GenericRecord> rebuildForKey(
            K key,
            EventStore<D, K, E> eventStore,
            UnaryOperator<GenericRecord> eventApplier) {
        Objects.requireNonNull(key, "key cannot be null");
        Objects.requireNonNull(eventStore, "eventStore cannot be null");
        Objects.requireNonNull(eventApplier, "eventApplier cannot be null");

        logger.debug("Rebuilding view entry for key: {}", key);

        // Remove existing entry
        remove(key);

        // Replay events for this key
        final GenericRecord[] currentState = {null};
        eventStore.replayByKey(key, eventRecord -> {
            currentState[0] = eventApplier.apply(currentState[0]);
        });

        // Store final state if we have one
        if (currentState[0] != null) {
            put(key, currentState[0]);
            return Optional.of(currentState[0]);
        }

        return Optional.empty();
    }

    /**
     * Returns the underlying Hazelcast map for advanced operations.
     * Use with caution - prefer the interface methods and executeOnKey for updates.
     *
     * @return the underlying IMap
     */
    public IMap<K, GenericRecord> getUnderlyingMap() {
        return viewMap;
    }

    /**
     * Returns the Hazelcast instance associated with this view store.
     *
     * @return the Hazelcast instance
     */
    public HazelcastInstance getHazelcast() {
        return hazelcast;
    }
}
