package com.theyawns.framework.persistence;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * In-memory implementation of {@link ViewStorePersistence} for testing and development.
 *
 * <p>Backed by {@link ConcurrentHashMap} for thread safety. Uses upsert semantics —
 * a second write to the same key replaces the previous entry.
 *
 * <p>This implementation is NOT a Spring {@code @Component} — it is registered as a
 * fallback bean by {@link PersistenceAutoConfiguration} when no other provider
 * (e.g., PostgreSQL) is on the classpath.
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see ViewStorePersistence
 * @see PersistenceAutoConfiguration
 */
public class InMemoryViewStorePersistence implements ViewStorePersistence {

    private final ConcurrentMap<String, ConcurrentMap<String, PersistableView>> store =
            new ConcurrentHashMap<>();

    @Override
    public void persist(final String viewName, final PersistableView view) {
        store.computeIfAbsent(viewName, k -> new ConcurrentHashMap<>())
                .put(view.viewKey(), view);
    }

    @Override
    public void persistBatch(final String viewName, final List<PersistableView> views) {
        ConcurrentMap<String, PersistableView> viewStore =
                store.computeIfAbsent(viewName, k -> new ConcurrentHashMap<>());
        for (PersistableView view : views) {
            viewStore.put(view.viewKey(), view);
        }
    }

    @Override
    public Optional<PersistableView> loadView(final String viewName, final String viewKey) {
        ConcurrentMap<String, PersistableView> viewStore = store.get(viewName);
        if (viewStore == null) {
            return Optional.empty();
        }
        return Optional.ofNullable(viewStore.get(viewKey));
    }

    @Override
    public Iterable<String> loadAllKeys(final String viewName) {
        ConcurrentMap<String, PersistableView> viewStore = store.get(viewName);
        if (viewStore == null) {
            return List.of();
        }
        return new ArrayList<>(viewStore.keySet());
    }

    @Override
    public void delete(final String viewName, final String viewKey) {
        ConcurrentMap<String, PersistableView> viewStore = store.get(viewName);
        if (viewStore != null) {
            viewStore.remove(viewKey);
        }
    }

    @Override
    public void deleteAll(final String viewName) {
        ConcurrentMap<String, PersistableView> viewStore = store.get(viewName);
        if (viewStore != null) {
            viewStore.clear();
        }
    }

    @Override
    public boolean isAvailable() {
        return true;
    }
}
