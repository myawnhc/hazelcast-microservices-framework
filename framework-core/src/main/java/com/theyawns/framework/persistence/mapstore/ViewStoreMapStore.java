package com.theyawns.framework.persistence.mapstore;

import com.hazelcast.map.MapLoaderLifecycleSupport;
import com.hazelcast.map.MapStore;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.framework.persistence.PersistableView;
import com.theyawns.framework.persistence.ViewStorePersistence;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;

/**
 * Hazelcast MapStore adapter that bridges a materialized view IMap to a
 * {@link ViewStorePersistence} provider.
 *
 * <p>This adapter is configured on the {@code {DomainName}_VIEW} IMap using
 * write-behind mode with coalescing enabled (only the latest state for each
 * key is persisted). On cold start, {@link #loadAllKeys()} returns all keys
 * so Hazelcast can rebuild the view from the database.
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see ViewStorePersistence
 */
public class ViewStoreMapStore
        implements MapStore<String, GenericRecord>,
                   MapLoaderLifecycleSupport {

    private static final Logger logger = LoggerFactory.getLogger(ViewStoreMapStore.class);

    private final ViewStorePersistence persistence;
    private String mapName;

    /**
     * Creates a new ViewStoreMapStore.
     *
     * @param persistence the persistence provider
     */
    public ViewStoreMapStore(ViewStorePersistence persistence) {
        if (persistence == null) {
            throw new IllegalArgumentException("persistence cannot be null");
        }
        this.persistence = persistence;
    }

    @Override
    public void init(com.hazelcast.core.HazelcastInstance hazelcastInstance,
                     Properties properties, String mapName) {
        this.mapName = mapName;
        logger.info("ViewStoreMapStore initialized for map: {}", mapName);
    }

    @Override
    public void destroy() {
        logger.info("ViewStoreMapStore destroyed for map: {}", mapName);
    }

    // ========================================================================
    // MapStore (write) operations
    // ========================================================================

    @Override
    public void store(String key, GenericRecord value) {
        PersistableView view = toPersistableView(key, value);
        persistence.persist(mapName, view);
    }

    @Override
    public void storeAll(Map<String, GenericRecord> map) {
        if (map.isEmpty()) {
            return;
        }
        List<PersistableView> views = new ArrayList<>(map.size());
        for (Map.Entry<String, GenericRecord> entry : map.entrySet()) {
            views.add(toPersistableView(entry.getKey(), entry.getValue()));
        }
        persistence.persistBatch(mapName, views);
        logger.debug("Persisted batch of {} view entries for map {}", map.size(), mapName);
    }

    @Override
    public void delete(String key) {
        persistence.delete(mapName, key);
    }

    @Override
    public void deleteAll(Collection<String> keys) {
        for (String key : keys) {
            persistence.delete(mapName, key);
        }
    }

    // ========================================================================
    // MapLoader (read) operations
    // ========================================================================

    @Override
    public GenericRecord load(String key) {
        return persistence.loadView(mapName, key)
                .map(pv -> GenericRecordJsonConverter.fromJson(pv.viewData()))
                .orElse(null);
    }

    @Override
    public Map<String, GenericRecord> loadAll(Collection<String> keys) {
        Map<String, GenericRecord> result = new HashMap<>(keys.size());
        for (String key : keys) {
            GenericRecord record = load(key);
            if (record != null) {
                result.put(key, record);
            }
        }
        return result;
    }

    @Override
    public Iterable<String> loadAllKeys() {
        // View stores use EAGER initial load â€” return all keys so
        // Hazelcast can rebuild materialized views from the database.
        return persistence.loadAllKeys(mapName);
    }

    // ========================================================================
    // Conversion helpers
    // ========================================================================

    private PersistableView toPersistableView(String key, GenericRecord value) {
        String viewData = GenericRecordJsonConverter.toJson(value);
        return new PersistableView(key, viewData, System.currentTimeMillis());
    }
}
