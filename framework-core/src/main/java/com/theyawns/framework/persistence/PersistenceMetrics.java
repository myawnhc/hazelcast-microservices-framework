package com.theyawns.framework.persistence;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;

import java.time.Duration;
import java.time.Instant;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

/**
 * Micrometer metrics for the persistence layer (MapStore operations).
 *
 * <p>Follows the same {@link ConcurrentHashMap} caching pattern as
 * {@link com.theyawns.framework.pipeline.PipelineMetrics} and
 * {@link com.theyawns.framework.saga.SagaMetrics}.
 *
 * <p>Counters:
 * <ul>
 *   <li>{@code persistence.store.count} — single writes (tags: mapName, storeType)</li>
 *   <li>{@code persistence.store.batch.count} — batch write operations</li>
 *   <li>{@code persistence.store.batch.entries} — total entries across batches</li>
 *   <li>{@code persistence.load.count} — load operations</li>
 *   <li>{@code persistence.load.miss} — load misses (not found)</li>
 *   <li>{@code persistence.delete.count} — delete operations</li>
 *   <li>{@code persistence.errors} — errors by operation (tags: mapName, operation)</li>
 * </ul>
 *
 * <p>Timers (with p50/p95/p99 percentiles):
 * <ul>
 *   <li>{@code persistence.store.duration} — single write duration</li>
 *   <li>{@code persistence.store.batch.duration} — batch write duration</li>
 *   <li>{@code persistence.load.duration} — load duration</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see com.theyawns.framework.pipeline.PipelineMetrics
 */
public class PersistenceMetrics {

    private final MeterRegistry meterRegistry;
    private final ConcurrentMap<String, Counter> counterCache = new ConcurrentHashMap<>();
    private final ConcurrentMap<String, Timer> timerCache = new ConcurrentHashMap<>();

    /**
     * Creates a new PersistenceMetrics instance.
     *
     * @param meterRegistry the Micrometer registry
     * @throws NullPointerException if meterRegistry is null
     */
    public PersistenceMetrics(final MeterRegistry meterRegistry) {
        this.meterRegistry = Objects.requireNonNull(meterRegistry, "meterRegistry cannot be null");
    }

    // ========================================================================
    // Store (write) metrics
    // ========================================================================

    /**
     * Records a single store operation.
     *
     * @param mapName the map name
     * @param storeType "event" or "view"
     * @param startTime when the operation started
     */
    public void recordStore(final String mapName, final String storeType, final Instant startTime) {
        getCounter("persistence.store.count", mapName, storeType).increment();
        recordDuration("persistence.store.duration", mapName, storeType, startTime);
    }

    /**
     * Records a batch store operation.
     *
     * @param mapName the map name
     * @param storeType "event" or "view"
     * @param batchSize number of entries in the batch
     * @param startTime when the operation started
     */
    public void recordBatchStore(final String mapName, final String storeType,
                                  final int batchSize, final Instant startTime) {
        getCounter("persistence.store.batch.count", mapName, storeType).increment();
        String entriesKey = "persistence.store.batch.entries:" + mapName + ":" + storeType;
        counterCache.computeIfAbsent(entriesKey, k ->
                Counter.builder("persistence.store.batch.entries")
                        .tag("mapName", safe(mapName))
                        .tag("storeType", storeType)
                        .register(meterRegistry)
        ).increment(batchSize);
        recordDuration("persistence.store.batch.duration", mapName, storeType, startTime);
    }

    // ========================================================================
    // Load (read) metrics
    // ========================================================================

    /**
     * Records a load operation (hit).
     *
     * @param mapName the map name
     * @param startTime when the operation started
     */
    public void recordLoad(final String mapName, final Instant startTime) {
        String key = "persistence.load.count:" + mapName;
        counterCache.computeIfAbsent(key, k ->
                Counter.builder("persistence.load.count")
                        .tag("mapName", safe(mapName))
                        .register(meterRegistry)
        ).increment();
        recordLoadDuration(mapName, startTime);
    }

    /**
     * Records a load miss (not found).
     *
     * @param mapName the map name
     */
    public void recordLoadMiss(final String mapName) {
        String key = "persistence.load.miss:" + mapName;
        counterCache.computeIfAbsent(key, k ->
                Counter.builder("persistence.load.miss")
                        .tag("mapName", safe(mapName))
                        .register(meterRegistry)
        ).increment();
    }

    // ========================================================================
    // Delete metrics
    // ========================================================================

    /**
     * Records a delete operation.
     *
     * @param mapName the map name
     */
    public void recordDelete(final String mapName) {
        String key = "persistence.delete.count:" + mapName;
        counterCache.computeIfAbsent(key, k ->
                Counter.builder("persistence.delete.count")
                        .tag("mapName", safe(mapName))
                        .register(meterRegistry)
        ).increment();
    }

    // ========================================================================
    // Error metrics
    // ========================================================================

    /**
     * Records a persistence error.
     *
     * @param mapName the map name
     * @param operation the operation that failed (e.g., "store", "load", "delete")
     */
    public void recordError(final String mapName, final String operation) {
        String key = "persistence.errors:" + mapName + ":" + operation;
        counterCache.computeIfAbsent(key, k ->
                Counter.builder("persistence.errors")
                        .tag("mapName", safe(mapName))
                        .tag("operation", operation)
                        .register(meterRegistry)
        ).increment();
    }

    // ========================================================================
    // Internal helpers
    // ========================================================================

    private Counter getCounter(final String name, final String mapName, final String storeType) {
        String key = name + ":" + mapName + ":" + storeType;
        return counterCache.computeIfAbsent(key, k ->
                Counter.builder(name)
                        .tag("mapName", safe(mapName))
                        .tag("storeType", storeType)
                        .register(meterRegistry)
        );
    }

    private void recordDuration(final String name, final String mapName,
                                 final String storeType, final Instant startTime) {
        String key = name + ":" + mapName + ":" + storeType;
        Timer timer = timerCache.computeIfAbsent(key, k ->
                Timer.builder(name)
                        .tag("mapName", safe(mapName))
                        .tag("storeType", storeType)
                        .publishPercentiles(0.5, 0.95, 0.99)
                        .register(meterRegistry)
        );
        Duration duration = Duration.between(startTime, Instant.now());
        timer.record(duration.toNanos(), TimeUnit.NANOSECONDS);
    }

    private void recordLoadDuration(final String mapName, final Instant startTime) {
        String key = "persistence.load.duration:" + mapName;
        Timer timer = timerCache.computeIfAbsent(key, k ->
                Timer.builder("persistence.load.duration")
                        .tag("mapName", safe(mapName))
                        .publishPercentiles(0.5, 0.95, 0.99)
                        .register(meterRegistry)
        );
        Duration duration = Duration.between(startTime, Instant.now());
        timer.record(duration.toNanos(), TimeUnit.NANOSECONDS);
    }

    private static String safe(final String value) {
        return value != null ? value : "unknown";
    }
}
