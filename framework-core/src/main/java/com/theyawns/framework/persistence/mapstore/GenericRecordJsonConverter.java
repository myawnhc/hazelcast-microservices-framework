package com.theyawns.framework.persistence.mapstore;

import com.hazelcast.nio.serialization.FieldKind;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;

import java.util.ArrayList;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.Set;

/**
 * Converts Hazelcast {@link GenericRecord} to/from JSON-compatible string representation
 * for database persistence.
 *
 * <p>The JSON format stores the Compact schema type name, field kind metadata, and all
 * field values, enabling full round-trip conversion. This is used by the MapStore adapters
 * to serialize GenericRecord entries into the {@code JSONB} columns of PostgreSQL.
 *
 * <p>Because {@link GenericRecord#getFieldNames()} and {@link GenericRecord#getFieldKind(String)}
 * are the only introspection methods available in the public API (schema type name is not
 * directly exposed), the caller must supply the schema type name for serialization.
 * If the record contains an {@code "eventType"} field, it is used as a fallback.
 *
 * <p>Supported field kinds:
 * <ul>
 *   <li>STRING, INT32, INT64, FLOAT32, FLOAT64, BOOLEAN</li>
 *   <li>NULLABLE_INT32, NULLABLE_INT64, NULLABLE_FLOAT32, NULLABLE_FLOAT64, NULLABLE_BOOLEAN</li>
 *   <li>COMPACT (nested GenericRecord â€” recursive)</li>
 *   <li>ARRAY_OF_COMPACT (array of nested records)</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
public final class GenericRecordJsonConverter {

    /** JSON key for the Compact schema type name. */
    static final String SCHEMA_TYPE_KEY = "_schemaType";

    /** JSON key for the fields map. */
    static final String FIELDS_KEY = "_fields";

    /** JSON key for the field kind metadata. */
    static final String FIELD_KINDS_KEY = "_fieldKinds";

    /** Default schema type name when not provided. */
    static final String DEFAULT_SCHEMA_TYPE = "GenericRecord";

    private GenericRecordJsonConverter() {
        // Utility class
    }

    /**
     * Converts a GenericRecord to a JSON-compatible string.
     *
     * <p>Uses the {@code "eventType"} field of the record as the schema type name
     * if present, otherwise falls back to {@value #DEFAULT_SCHEMA_TYPE}.
     *
     * @param record the GenericRecord to convert
     * @return JSON string representation
     * @throws IllegalArgumentException if record is null
     */
    public static String toJson(GenericRecord record) {
        if (record == null) {
            throw new IllegalArgumentException("record cannot be null");
        }
        String schemaType = inferSchemaType(record);
        return toJson(record, schemaType);
    }

    /**
     * Converts a GenericRecord to a JSON-compatible string with an explicit schema type.
     *
     * @param record the GenericRecord to convert
     * @param schemaType the Compact schema type name to store
     * @return JSON string representation
     * @throws IllegalArgumentException if record or schemaType is null
     */
    public static String toJson(GenericRecord record, String schemaType) {
        if (record == null) {
            throw new IllegalArgumentException("record cannot be null");
        }
        if (schemaType == null) {
            throw new IllegalArgumentException("schemaType cannot be null");
        }

        Map<String, Object> root = toMap(record, schemaType);
        return mapToJson(root);
    }

    /**
     * Converts a JSON string back to a GenericRecord.
     *
     * @param json the JSON string (as produced by {@link #toJson(GenericRecord)})
     * @return the reconstructed GenericRecord
     * @throws IllegalArgumentException if json is null or malformed
     */
    public static GenericRecord fromJson(String json) {
        if (json == null) {
            throw new IllegalArgumentException("json cannot be null");
        }

        Map<String, Object> root = jsonToMap(json);
        return fromMap(root);
    }

    /**
     * Converts a GenericRecord to a structured map with schema metadata.
     *
     * @param record the GenericRecord
     * @param schemaType the schema type name
     * @return map with _schemaType, _fieldKinds, and _fields
     */
    static Map<String, Object> toMap(GenericRecord record, String schemaType) {
        Set<String> fieldNames = record.getFieldNames();
        Map<String, Object> fields = new LinkedHashMap<>(fieldNames.size());
        Map<String, String> fieldKinds = new LinkedHashMap<>(fieldNames.size());

        for (String fieldName : fieldNames) {
            FieldKind kind = record.getFieldKind(fieldName);
            fieldKinds.put(fieldName, kind.name());
            fields.put(fieldName, readField(record, fieldName, kind));
        }

        Map<String, Object> root = new LinkedHashMap<>(3);
        root.put(SCHEMA_TYPE_KEY, schemaType);
        root.put(FIELD_KINDS_KEY, fieldKinds);
        root.put(FIELDS_KEY, fields);
        return root;
    }

    /**
     * Reconstructs a GenericRecord from a structured map.
     *
     * @param root the map with _schemaType, _fieldKinds, and _fields
     * @return the reconstructed GenericRecord
     */
    @SuppressWarnings("unchecked")
    static GenericRecord fromMap(Map<String, Object> root) {
        String schemaType = (String) root.get(SCHEMA_TYPE_KEY);
        Map<String, String> fieldKinds = (Map<String, String>) root.get(FIELD_KINDS_KEY);
        Map<String, Object> fields = (Map<String, Object>) root.get(FIELDS_KEY);

        if (schemaType == null || fieldKinds == null || fields == null) {
            throw new IllegalArgumentException("JSON must contain _schemaType, _fieldKinds, and _fields");
        }

        GenericRecordBuilder builder = GenericRecordBuilder.compact(schemaType);

        for (Map.Entry<String, String> entry : fieldKinds.entrySet()) {
            String fieldName = entry.getKey();
            FieldKind kind = FieldKind.valueOf(entry.getValue());
            Object value = fields.get(fieldName);
            writeField(builder, fieldName, kind, value);
        }

        return builder.build();
    }

    /**
     * Infers the schema type from a GenericRecord.
     * Uses the "eventType" field if present, otherwise defaults.
     */
    private static String inferSchemaType(GenericRecord record) {
        try {
            Set<String> fields = record.getFieldNames();
            if (fields.contains("eventType")) {
                String eventType = record.getString("eventType");
                if (eventType != null && !eventType.isEmpty()) {
                    return eventType;
                }
            }
        } catch (Exception e) {
            // Fall through to default
        }
        return DEFAULT_SCHEMA_TYPE;
    }

    private static Object readField(GenericRecord record, String fieldName, FieldKind kind) {
        switch (kind) {
            case STRING:
                return record.getString(fieldName);
            case INT32:
                return record.getInt32(fieldName);
            case INT64:
                return record.getInt64(fieldName);
            case FLOAT32:
                return record.getFloat32(fieldName);
            case FLOAT64:
                return record.getFloat64(fieldName);
            case BOOLEAN:
                return record.getBoolean(fieldName);
            case NULLABLE_INT32:
                return record.getNullableInt32(fieldName);
            case NULLABLE_INT64:
                return record.getNullableInt64(fieldName);
            case NULLABLE_FLOAT32:
                return record.getNullableFloat32(fieldName);
            case NULLABLE_FLOAT64:
                return record.getNullableFloat64(fieldName);
            case NULLABLE_BOOLEAN:
                return record.getNullableBoolean(fieldName);
            case COMPACT:
                GenericRecord nested = record.getGenericRecord(fieldName);
                if (nested != null) {
                    String nestedType = inferSchemaType(nested);
                    return toMap(nested, nestedType);
                }
                return null;
            case ARRAY_OF_COMPACT:
                GenericRecord[] array = record.getArrayOfGenericRecord(fieldName);
                if (array == null) {
                    return null;
                }
                List<Map<String, Object>> list = new ArrayList<>(array.length);
                for (GenericRecord item : array) {
                    if (item != null) {
                        String itemType = inferSchemaType(item);
                        list.add(toMap(item, itemType));
                    } else {
                        list.add(null);
                    }
                }
                return list;
            default:
                return null;
        }
    }

    @SuppressWarnings("unchecked")
    private static void writeField(GenericRecordBuilder builder, String fieldName,
                                   FieldKind kind, Object value) {
        switch (kind) {
            case STRING:
                builder.setString(fieldName, (String) value);
                break;
            case INT32:
                builder.setInt32(fieldName, toInt(value));
                break;
            case INT64:
                builder.setInt64(fieldName, toLong(value));
                break;
            case FLOAT32:
                builder.setFloat32(fieldName, toFloat(value));
                break;
            case FLOAT64:
                builder.setFloat64(fieldName, toDouble(value));
                break;
            case BOOLEAN:
                builder.setBoolean(fieldName, (Boolean) value);
                break;
            case NULLABLE_INT32:
                builder.setNullableInt32(fieldName, value != null ? toInt(value) : null);
                break;
            case NULLABLE_INT64:
                builder.setNullableInt64(fieldName, value != null ? toLong(value) : null);
                break;
            case NULLABLE_FLOAT32:
                builder.setNullableFloat32(fieldName, value != null ? toFloat(value) : null);
                break;
            case NULLABLE_FLOAT64:
                builder.setNullableFloat64(fieldName, value != null ? toDouble(value) : null);
                break;
            case NULLABLE_BOOLEAN:
                builder.setNullableBoolean(fieldName, value != null ? (Boolean) value : null);
                break;
            case COMPACT:
                if (value != null) {
                    builder.setGenericRecord(fieldName, fromMap((Map<String, Object>) value));
                } else {
                    builder.setGenericRecord(fieldName, null);
                }
                break;
            case ARRAY_OF_COMPACT:
                if (value != null) {
                    List<Map<String, Object>> items = (List<Map<String, Object>>) value;
                    GenericRecord[] records = new GenericRecord[items.size()];
                    for (int i = 0; i < items.size(); i++) {
                        records[i] = items.get(i) != null ? fromMap(items.get(i)) : null;
                    }
                    builder.setArrayOfGenericRecord(fieldName, records);
                } else {
                    builder.setArrayOfGenericRecord(fieldName, null);
                }
                break;
            default:
                // Unsupported types are silently skipped during reconstruction
                break;
        }
    }

    // ========================================================================
    // Minimal JSON serializer/deserializer (avoids Jackson dependency in core)
    // ========================================================================

    /**
     * Converts a map to a JSON string without external dependencies.
     */
    @SuppressWarnings("unchecked")
    static String mapToJson(Map<String, Object> map) {
        StringBuilder sb = new StringBuilder();
        appendJsonValue(sb, map);
        return sb.toString();
    }

    /**
     * Parses a JSON string into a map without external dependencies.
     */
    @SuppressWarnings("unchecked")
    static Map<String, Object> jsonToMap(String json) {
        JsonParser parser = new JsonParser(json.trim());
        Object result = parser.parseValue();
        if (result instanceof Map) {
            return (Map<String, Object>) result;
        }
        throw new IllegalArgumentException("Expected JSON object, got: " + result.getClass().getSimpleName());
    }

    @SuppressWarnings("unchecked")
    private static void appendJsonValue(StringBuilder sb, Object value) {
        if (value == null) {
            sb.append("null");
        } else if (value instanceof String) {
            sb.append('"');
            escapeJson(sb, (String) value);
            sb.append('"');
        } else if (value instanceof Number || value instanceof Boolean) {
            sb.append(value);
        } else if (value instanceof Map) {
            Map<String, Object> map = (Map<String, Object>) value;
            sb.append('{');
            boolean first = true;
            for (Map.Entry<String, Object> entry : map.entrySet()) {
                if (!first) {
                    sb.append(',');
                }
                sb.append('"');
                escapeJson(sb, entry.getKey());
                sb.append("\":");
                appendJsonValue(sb, entry.getValue());
                first = false;
            }
            sb.append('}');
        } else if (value instanceof List) {
            List<Object> list = (List<Object>) value;
            sb.append('[');
            for (int i = 0; i < list.size(); i++) {
                if (i > 0) {
                    sb.append(',');
                }
                appendJsonValue(sb, list.get(i));
            }
            sb.append(']');
        } else {
            sb.append('"');
            escapeJson(sb, value.toString());
            sb.append('"');
        }
    }

    private static void escapeJson(StringBuilder sb, String str) {
        for (int i = 0; i < str.length(); i++) {
            char c = str.charAt(i);
            switch (c) {
                case '"':
                    sb.append("\\\"");
                    break;
                case '\\':
                    sb.append("\\\\");
                    break;
                case '\n':
                    sb.append("\\n");
                    break;
                case '\r':
                    sb.append("\\r");
                    break;
                case '\t':
                    sb.append("\\t");
                    break;
                default:
                    if (c < 0x20) {
                        sb.append(String.format("\\u%04x", (int) c));
                    } else {
                        sb.append(c);
                    }
            }
        }
    }

    // Numeric type coercion helpers (JSON numbers may parse as different types)
    private static int toInt(Object value) {
        return ((Number) value).intValue();
    }

    private static long toLong(Object value) {
        return ((Number) value).longValue();
    }

    private static float toFloat(Object value) {
        return ((Number) value).floatValue();
    }

    private static double toDouble(Object value) {
        return ((Number) value).doubleValue();
    }

    /**
     * Minimal recursive-descent JSON parser.
     * Supports: objects, arrays, strings, numbers, booleans, null.
     */
    static final class JsonParser {
        private final String json;
        private int pos;

        JsonParser(String json) {
            this.json = json;
            this.pos = 0;
        }

        Object parseValue() {
            skipWhitespace();
            if (pos >= json.length()) {
                throw new IllegalArgumentException("Unexpected end of JSON");
            }
            char c = json.charAt(pos);
            if (c == '{') {
                return parseObject();
            } else if (c == '[') {
                return parseArray();
            } else if (c == '"') {
                return parseString();
            } else if (c == 't' || c == 'f') {
                return parseBoolean();
            } else if (c == 'n') {
                return parseNull();
            } else {
                return parseNumber();
            }
        }

        private Map<String, Object> parseObject() {
            expect('{');
            Map<String, Object> map = new LinkedHashMap<>();
            skipWhitespace();
            if (pos < json.length() && json.charAt(pos) == '}') {
                pos++;
                return map;
            }
            while (true) {
                skipWhitespace();
                String key = parseString();
                skipWhitespace();
                expect(':');
                Object value = parseValue();
                map.put(key, value);
                skipWhitespace();
                if (pos < json.length() && json.charAt(pos) == ',') {
                    pos++;
                } else {
                    break;
                }
            }
            expect('}');
            return map;
        }

        private List<Object> parseArray() {
            expect('[');
            List<Object> list = new ArrayList<>();
            skipWhitespace();
            if (pos < json.length() && json.charAt(pos) == ']') {
                pos++;
                return list;
            }
            while (true) {
                list.add(parseValue());
                skipWhitespace();
                if (pos < json.length() && json.charAt(pos) == ',') {
                    pos++;
                } else {
                    break;
                }
            }
            expect(']');
            return list;
        }

        private String parseString() {
            expect('"');
            StringBuilder sb = new StringBuilder();
            while (pos < json.length()) {
                char c = json.charAt(pos);
                if (c == '"') {
                    pos++;
                    return sb.toString();
                } else if (c == '\\') {
                    pos++;
                    if (pos >= json.length()) {
                        throw new IllegalArgumentException("Unexpected end of string escape");
                    }
                    char escaped = json.charAt(pos);
                    switch (escaped) {
                        case '"': sb.append('"'); break;
                        case '\\': sb.append('\\'); break;
                        case '/': sb.append('/'); break;
                        case 'n': sb.append('\n'); break;
                        case 'r': sb.append('\r'); break;
                        case 't': sb.append('\t'); break;
                        case 'u':
                            if (pos + 4 >= json.length()) {
                                throw new IllegalArgumentException("Invalid unicode escape");
                            }
                            String hex = json.substring(pos + 1, pos + 5);
                            sb.append((char) Integer.parseInt(hex, 16));
                            pos += 4;
                            break;
                        default:
                            sb.append(escaped);
                    }
                } else {
                    sb.append(c);
                }
                pos++;
            }
            throw new IllegalArgumentException("Unterminated string");
        }

        private Number parseNumber() {
            int start = pos;
            boolean isFloat = false;
            if (pos < json.length() && json.charAt(pos) == '-') {
                pos++;
            }
            while (pos < json.length() && Character.isDigit(json.charAt(pos))) {
                pos++;
            }
            if (pos < json.length() && json.charAt(pos) == '.') {
                isFloat = true;
                pos++;
                while (pos < json.length() && Character.isDigit(json.charAt(pos))) {
                    pos++;
                }
            }
            if (pos < json.length() && (json.charAt(pos) == 'e' || json.charAt(pos) == 'E')) {
                isFloat = true;
                pos++;
                if (pos < json.length() && (json.charAt(pos) == '+' || json.charAt(pos) == '-')) {
                    pos++;
                }
                while (pos < json.length() && Character.isDigit(json.charAt(pos))) {
                    pos++;
                }
            }
            String numStr = json.substring(start, pos);
            if (isFloat) {
                return Double.parseDouble(numStr);
            }
            long val = Long.parseLong(numStr);
            if (val >= Integer.MIN_VALUE && val <= Integer.MAX_VALUE) {
                return (int) val;
            }
            return val;
        }

        private Boolean parseBoolean() {
            if (json.startsWith("true", pos)) {
                pos += 4;
                return Boolean.TRUE;
            } else if (json.startsWith("false", pos)) {
                pos += 5;
                return Boolean.FALSE;
            }
            throw new IllegalArgumentException("Expected boolean at position " + pos);
        }

        private Object parseNull() {
            if (json.startsWith("null", pos)) {
                pos += 4;
                return null;
            }
            throw new IllegalArgumentException("Expected null at position " + pos);
        }

        private void expect(char expected) {
            skipWhitespace();
            if (pos >= json.length() || json.charAt(pos) != expected) {
                throw new IllegalArgumentException(
                        "Expected '" + expected + "' at position " + pos +
                                (pos < json.length() ? ", got '" + json.charAt(pos) + "'" : ", got EOF"));
            }
            pos++;
        }

        private void skipWhitespace() {
            while (pos < json.length() && Character.isWhitespace(json.charAt(pos))) {
                pos++;
            }
        }
    }
}
