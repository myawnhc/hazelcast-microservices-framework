package com.theyawns.framework.persistence;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * In-memory implementation of {@link EventStorePersistence} for testing and development.
 *
 * <p>Backed by {@link ConcurrentHashMap} for thread safety. Suitable for unit tests,
 * integration tests without a database, and local development without PostgreSQL.
 *
 * <p>This implementation is NOT a Spring {@code @Component} â€” it is registered as a
 * fallback bean by {@link PersistenceAutoConfiguration} when no other provider
 * (e.g., PostgreSQL) is on the classpath.
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see EventStorePersistence
 * @see PersistenceAutoConfiguration
 */
public class InMemoryEventStorePersistence implements EventStorePersistence {

    private final ConcurrentMap<String, ConcurrentMap<String, PersistableEvent>> store =
            new ConcurrentHashMap<>();

    @Override
    public void persist(final String mapName, final PersistableEvent event) {
        store.computeIfAbsent(mapName, k -> new ConcurrentHashMap<>())
                .put(event.mapKey(), event);
    }

    @Override
    public void persistBatch(final String mapName, final List<PersistableEvent> events) {
        ConcurrentMap<String, PersistableEvent> mapStore =
                store.computeIfAbsent(mapName, k -> new ConcurrentHashMap<>());
        for (PersistableEvent event : events) {
            mapStore.put(event.mapKey(), event);
        }
    }

    @Override
    public Optional<PersistableEvent> loadEvent(final String mapName, final String mapKey) {
        ConcurrentMap<String, PersistableEvent> mapStore = store.get(mapName);
        if (mapStore == null) {
            return Optional.empty();
        }
        return Optional.ofNullable(mapStore.get(mapKey));
    }

    @Override
    public Iterable<String> loadAllKeys(final String mapName) {
        ConcurrentMap<String, PersistableEvent> mapStore = store.get(mapName);
        if (mapStore == null) {
            return List.of();
        }
        return new ArrayList<>(mapStore.keySet());
    }

    @Override
    public void delete(final String mapName, final String mapKey) {
        ConcurrentMap<String, PersistableEvent> mapStore = store.get(mapName);
        if (mapStore != null) {
            mapStore.remove(mapKey);
        }
    }

    @Override
    public boolean isAvailable() {
        return true;
    }
}
