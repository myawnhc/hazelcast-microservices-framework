package com.theyawns.framework.persistence.mapstore;

import com.hazelcast.map.MapLoaderLifecycleSupport;
import com.hazelcast.map.MapStore;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.framework.persistence.EventStorePersistence;
import com.theyawns.framework.persistence.PersistableEvent;
import com.theyawns.framework.persistence.PersistenceMetrics;
import com.theyawns.framework.store.PartitionedSequenceKey;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.Collection;
import java.util.Collections;
import java.util.Map;
import java.util.Properties;

/**
 * Hazelcast MapStore adapter that bridges the event store IMap to a
 * {@link EventStorePersistence} provider.
 *
 * <p>This adapter is configured on the {@code {DomainName}_ES} IMap using
 * write-behind mode. When Hazelcast puts an event into the map, the
 * write-behind mechanism batches the event and calls {@link #storeAll(Map)}
 * on a background thread. On cold start, {@link #loadAllKeys()} is called
 * to discover existing keys.
 *
 * <p>Key serialization format: {@code "seq:{sequence}|key:{partitionKey}"}
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see EventStorePersistence
 */
public class EventStoreMapStore
        implements MapStore<PartitionedSequenceKey<String>, GenericRecord>,
                   MapLoaderLifecycleSupport {

    private static final Logger logger = LoggerFactory.getLogger(EventStoreMapStore.class);

    /** Separator between sequence and partition key in the serialized form. */
    static final String KEY_SEPARATOR = "|";
    static final String SEQ_PREFIX = "seq:";
    static final String KEY_PREFIX = "key:";

    private final EventStorePersistence persistence;
    private final PersistenceMetrics metrics;
    private String mapName;

    /**
     * Creates a new EventStoreMapStore without metrics.
     *
     * @param persistence the persistence provider
     */
    public EventStoreMapStore(EventStorePersistence persistence) {
        this(persistence, null);
    }

    /**
     * Creates a new EventStoreMapStore with optional metrics.
     *
     * @param persistence the persistence provider
     * @param metrics the metrics collector (may be null)
     */
    public EventStoreMapStore(EventStorePersistence persistence, PersistenceMetrics metrics) {
        if (persistence == null) {
            throw new IllegalArgumentException("persistence cannot be null");
        }
        this.persistence = persistence;
        this.metrics = metrics;
    }

    @Override
    public void init(com.hazelcast.core.HazelcastInstance hazelcastInstance,
                     Properties properties, String mapName) {
        this.mapName = mapName;
        logger.info("EventStoreMapStore initialized for map: {}", mapName);
    }

    @Override
    public void destroy() {
        logger.info("EventStoreMapStore destroyed for map: {}", mapName);
    }

    // ========================================================================
    // MapStore (write) operations
    // ========================================================================

    @Override
    public void store(PartitionedSequenceKey<String> key, GenericRecord value) {
        Instant start = metrics != null ? Instant.now() : null;
        PersistableEvent event = toPersistableEvent(key, value);
        persistence.persist(mapName, event);
        if (metrics != null) {
            metrics.recordStore(mapName, "event", start);
        }
    }

    @Override
    public void storeAll(Map<PartitionedSequenceKey<String>, GenericRecord> map) {
        if (map.isEmpty()) {
            return;
        }
        Instant start = metrics != null ? Instant.now() : null;
        persistence.persistBatch(mapName,
                map.entrySet().stream()
                        .map(e -> toPersistableEvent(e.getKey(), e.getValue()))
                        .toList());
        if (metrics != null) {
            metrics.recordBatchStore(mapName, "event", map.size(), start);
        }
        logger.debug("Persisted batch of {} events for map {}", map.size(), mapName);
    }

    @Override
    public void delete(PartitionedSequenceKey<String> key) {
        persistence.delete(mapName, serializeKey(key));
        if (metrics != null) {
            metrics.recordDelete(mapName);
        }
    }

    @Override
    public void deleteAll(Collection<PartitionedSequenceKey<String>> keys) {
        for (PartitionedSequenceKey<String> key : keys) {
            persistence.delete(mapName, serializeKey(key));
        }
    }

    // ========================================================================
    // MapLoader (read) operations
    // ========================================================================

    @Override
    public GenericRecord load(PartitionedSequenceKey<String> key) {
        Instant start = metrics != null ? Instant.now() : null;
        GenericRecord result = persistence.loadEvent(mapName, serializeKey(key))
                .map(pe -> GenericRecordJsonConverter.fromJson(pe.eventData()))
                .orElse(null);
        if (metrics != null) {
            metrics.recordLoad(mapName, start);
            if (result == null) {
                metrics.recordLoadMiss(mapName);
            }
        }
        return result;
    }

    @Override
    public Map<PartitionedSequenceKey<String>, GenericRecord> loadAll(
            Collection<PartitionedSequenceKey<String>> keys) {
        Map<PartitionedSequenceKey<String>, GenericRecord> result =
                new java.util.HashMap<>(keys.size());
        for (PartitionedSequenceKey<String> key : keys) {
            GenericRecord record = load(key);
            if (record != null) {
                result.put(key, record);
            }
        }
        return result;
    }

    @Override
    public Iterable<PartitionedSequenceKey<String>> loadAllKeys() {
        // Event stores use LAZY initial load â€” return empty.
        // Events are append-only and loaded on-demand.
        return Collections.emptyList();
    }

    // ========================================================================
    // Conversion helpers
    // ========================================================================

    /**
     * Serializes a PartitionedSequenceKey to a string for database storage.
     *
     * @param key the key to serialize
     * @return serialized form: "seq:{sequence}|key:{partitionKey}"
     */
    static String serializeKey(PartitionedSequenceKey<String> key) {
        return SEQ_PREFIX + key.getSequence() + KEY_SEPARATOR + KEY_PREFIX + key.getKey();
    }

    /**
     * Deserializes a string back to a PartitionedSequenceKey.
     *
     * @param serialized the serialized form
     * @return the reconstructed key
     * @throws IllegalArgumentException if the format is invalid
     */
    static PartitionedSequenceKey<String> deserializeKey(String serialized) {
        int sepIdx = serialized.indexOf(KEY_SEPARATOR);
        if (sepIdx < 0) {
            throw new IllegalArgumentException("Invalid serialized key (missing separator): " + serialized);
        }
        String seqPart = serialized.substring(0, sepIdx);
        String keyPart = serialized.substring(sepIdx + 1);

        if (!seqPart.startsWith(SEQ_PREFIX)) {
            throw new IllegalArgumentException("Invalid serialized key (missing seq prefix): " + serialized);
        }
        if (!keyPart.startsWith(KEY_PREFIX)) {
            throw new IllegalArgumentException("Invalid serialized key (missing key prefix): " + serialized);
        }

        long sequence = Long.parseLong(seqPart.substring(SEQ_PREFIX.length()));
        String partitionKey = keyPart.substring(KEY_PREFIX.length());
        return new PartitionedSequenceKey<>(sequence, partitionKey);
    }

    private PersistableEvent toPersistableEvent(PartitionedSequenceKey<String> key,
                                                 GenericRecord value) {
        // Extract eventType from the record's "eventType" field if present
        String eventType = "unknown";
        try {
            if (value.getFieldNames().contains("eventType")) {
                String et = value.getString("eventType");
                if (et != null && !et.isEmpty()) {
                    eventType = et;
                }
            }
        } catch (Exception e) {
            // Use default
        }

        String eventData = GenericRecordJsonConverter.toJson(value, eventType);

        // Extract timestamp and correlationId if present in the record
        long timestampMillis = System.currentTimeMillis();
        String correlationId = null;
        try {
            if (value.getFieldNames().contains("timestampMillis")) {
                timestampMillis = value.getInt64("timestampMillis");
            }
        } catch (Exception e) {
            // Use current time as fallback
        }
        try {
            if (value.getFieldNames().contains("correlationId")) {
                correlationId = value.getString("correlationId");
            }
        } catch (Exception e) {
            // Leave null
        }

        return new PersistableEvent(
                serializeKey(key),
                key.getKey(),
                key.getSequence(),
                eventType,
                eventData,
                timestampMillis,
                correlationId
        );
    }
}
