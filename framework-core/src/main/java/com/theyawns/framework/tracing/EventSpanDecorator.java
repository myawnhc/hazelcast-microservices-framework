package com.theyawns.framework.tracing;

import com.theyawns.framework.event.DomainEvent;
import io.micrometer.tracing.Span;
import io.micrometer.tracing.Tracer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Decorates event processing with distributed tracing spans.
 *
 * <p>Creates spans for:
 * <ul>
 *   <li>Event submission via handleEvent()</li>
 *   <li>Pipeline stage processing</li>
 *   <li>Saga step execution</li>
 * </ul>
 *
 * <p>Span attributes include event.id, event.type, correlation.id,
 * saga.id, and saga.type to enable filtering and grouping in Jaeger UI.
 *
 * <p>When tracing is disabled, all methods return noop spans that
 * do not record or export any data.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
public class EventSpanDecorator {

    private static final Logger logger = LoggerFactory.getLogger(EventSpanDecorator.class);

    private final Tracer tracer;

    /**
     * Creates a new EventSpanDecorator.
     *
     * @param tracer the Micrometer tracer for span creation
     */
    public EventSpanDecorator(Tracer tracer) {
        this.tracer = tracer;
    }

    /**
     * Starts a span for event processing in the controller.
     *
     * <p>The span is named "handle-event" and includes attributes for
     * the event type, event ID, correlation ID, and saga metadata if present.
     *
     * @param event the domain event being processed
     * @return the started span (caller must call end())
     */
    public Span startEventSpan(DomainEvent<?, ?> event) {
        Span.Builder builder = tracer.spanBuilder()
                .name("handle-event")
                .tag("event.id", nullSafe(event.getEventId()))
                .tag("event.type", nullSafe(event.getEventType()))
                .tag("event.source", nullSafe(event.getSource()));

        if (event.getCorrelationId() != null) {
            builder.tag("correlation.id", event.getCorrelationId());
        }

        if (event.getSagaId() != null) {
            builder.tag("saga.id", event.getSagaId());
            builder.tag("saga.type", nullSafe(event.getSagaType()));
            if (event.getStepNumber() != null) {
                builder.tag("saga.step", String.valueOf(event.getStepNumber()));
            }
            if (Boolean.TRUE.equals(event.getIsCompensating())) {
                builder.tag("saga.compensating", "true");
            }
        }

        Span span = builder.start();
        logger.trace("Started event span: {} (type: {})", event.getEventId(), event.getEventType());
        return span;
    }

    /**
     * Starts a span for a pipeline processing stage.
     *
     * @param stageName the pipeline stage name (e.g., "persist", "update-view")
     * @param eventType the type of event being processed
     * @param eventId the ID of the event being processed
     * @return the started span (caller must call end())
     */
    public Span startPipelineSpan(String stageName, String eventType, String eventId) {
        return tracer.spanBuilder()
                .name("pipeline-" + stageName)
                .tag("pipeline.stage", stageName)
                .tag("event.type", nullSafe(eventType))
                .tag("event.id", nullSafe(eventId))
                .start();
    }

    /**
     * Starts a span for a saga step execution.
     *
     * <p>Used by saga listeners when processing saga events received
     * via Hazelcast topics.
     *
     * @param eventType the saga event type (e.g., "StockReserved")
     * @param sagaId the saga instance identifier
     * @param sagaType the saga type (e.g., "OrderFulfillment")
     * @param stepNumber the current step number in the saga
     * @return the started span (caller must call end())
     */
    public Span startSagaSpan(String eventType, String sagaId, String sagaType, int stepNumber) {
        return tracer.spanBuilder()
                .name("saga-" + nullSafe(eventType))
                .tag("saga.id", nullSafe(sagaId))
                .tag("saga.type", nullSafe(sagaType))
                .tag("saga.step", String.valueOf(stepNumber))
                .tag("event.type", nullSafe(eventType))
                .start();
    }

    /**
     * Records an error on the given span.
     *
     * @param span the span to record the error on
     * @param error the exception that occurred
     */
    public void recordError(Span span, Throwable error) {
        if (span != null) {
            span.error(error);
        }
    }

    /**
     * Ends the given span.
     *
     * @param span the span to end (null-safe)
     */
    public void endSpan(Span span) {
        if (span != null) {
            span.end();
        }
    }

    /**
     * Returns the underlying tracer.
     *
     * @return the Micrometer tracer
     */
    public Tracer getTracer() {
        return tracer;
    }

    private static String nullSafe(String value) {
        return value != null ? value : "unknown";
    }
}
