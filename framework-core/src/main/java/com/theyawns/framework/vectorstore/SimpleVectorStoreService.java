package com.theyawns.framework.vectorstore;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.theyawns.framework.edition.ConditionalOnEnterpriseFeature;
import com.theyawns.framework.edition.EditionDetector.EnterpriseFeature;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;

/**
 * Enterprise vector store implementation using {@code IMap<String, float[]>} with
 * brute-force cosine similarity search.
 *
 * <p>This implementation stores embeddings in two Hazelcast IMaps:
 * <ul>
 *   <li>{@code {collectionName}} — maps item ID to embedding vector</li>
 *   <li>{@code {collectionName}-metadata} — maps item ID to metadata</li>
 * </ul>
 *
 * <p><strong>Production note:</strong> In a production Hazelcast Enterprise deployment,
 * this would be replaced with {@code VectorCollection} using HNSW indexing for
 * O(log n) approximate nearest-neighbor search. The brute-force approach here is
 * O(n) per query and is suitable for demos and small datasets only.
 *
 * @author Generated by Claude Code
 * @since 2.0
 * @see VectorStoreService
 * @see NoOpVectorStoreService
 */
@Service
@ConditionalOnEnterpriseFeature(EnterpriseFeature.VECTOR_STORE)
public class SimpleVectorStoreService implements VectorStoreService {

    private static final Logger logger = LoggerFactory.getLogger(SimpleVectorStoreService.class);

    private final IMap<String, float[]> embeddingMap;
    private final IMap<String, Map<String, Object>> metadataMap;

    /**
     * Creates a new SimpleVectorStoreService.
     *
     * @param hazelcast the Hazelcast instance
     * @param properties the vector store configuration properties
     */
    public SimpleVectorStoreService(HazelcastInstance hazelcast, VectorStoreProperties properties) {
        this.embeddingMap = hazelcast.getMap(properties.getCollectionName());
        this.metadataMap = hazelcast.getMap(properties.getCollectionName() + "-metadata");
        logger.info("SimpleVectorStoreService initialized with collection '{}', dimension={}",
                properties.getCollectionName(), properties.getDimension());
    }

    @Override
    public void storeEmbedding(final String id, final float[] embedding, final Map<String, Object> metadata) {
        embeddingMap.put(id, embedding);
        if (metadata != null && !metadata.isEmpty()) {
            metadataMap.put(id, metadata);
        }
        logger.debug("Stored embedding for id={} (dimension={})", id, embedding.length);
    }

    @Override
    public List<SimilarityResult> findSimilar(final float[] queryVector, final int limit) {
        final Map<String, float[]> allEmbeddings = embeddingMap.getAll(embeddingMap.keySet());

        if (allEmbeddings.isEmpty()) {
            return List.of();
        }

        final List<SimilarityResult> results = new ArrayList<>(allEmbeddings.size());

        for (final Map.Entry<String, float[]> entry : allEmbeddings.entrySet()) {
            final float score = cosineSimilarity(queryVector, entry.getValue());
            final Map<String, Object> metadata = metadataMap.get(entry.getKey());
            results.add(new SimilarityResult(
                    entry.getKey(),
                    score,
                    metadata != null ? metadata : Map.of()
            ));
        }

        results.sort(Comparator.comparingDouble(SimilarityResult::score).reversed());

        return results.subList(0, Math.min(limit, results.size()));
    }

    @Override
    public List<SimilarityResult> findSimilarById(final String id, final int limit) {
        final float[] queryVector = embeddingMap.get(id);
        if (queryVector == null) {
            logger.debug("No embedding found for id={}", id);
            return List.of();
        }

        // Find limit+1 to account for excluding the query item itself
        final List<SimilarityResult> candidates = findSimilar(queryVector, limit + 1);

        return candidates.stream()
                .filter(r -> !r.id().equals(id))
                .limit(limit)
                .toList();
    }

    @Override
    public boolean isAvailable() {
        return true;
    }

    @Override
    public String getImplementationType() {
        return "IMap-Based Cosine Similarity (Enterprise)";
    }

    /**
     * Computes the cosine similarity between two vectors.
     *
     * <p>Returns a value between -1.0 and 1.0, where 1.0 means identical direction.
     * For normalized vectors, this is equivalent to the dot product.
     *
     * @param a the first vector
     * @param b the second vector
     * @return cosine similarity score
     */
    static float cosineSimilarity(final float[] a, final float[] b) {
        final int len = Math.min(a.length, b.length);
        float dot = 0.0f;
        float normA = 0.0f;
        float normB = 0.0f;

        for (int i = 0; i < len; i++) {
            dot += a[i] * b[i];
            normA += a[i] * a[i];
            normB += b[i] * b[i];
        }

        if (normA == 0.0f || normB == 0.0f) {
            return 0.0f;
        }

        return dot / (float) (Math.sqrt(normA) * Math.sqrt(normB));
    }
}
