package com.theyawns.framework.vectorstore;

import java.nio.charset.StandardCharsets;
import java.security.MessageDigest;
import java.security.NoSuchAlgorithmException;

/**
 * Deterministic text-to-embedding generator for demo and testing purposes.
 *
 * <p>Generates fixed-dimension float vectors from text using hash-based tokenization.
 * The output is deterministic: the same input text always produces the same vector.
 * Vectors are L2-normalized so cosine similarity can be computed as a dot product.
 *
 * <p><strong>Not intended for production ML workloads.</strong> In production, use a
 * proper embedding model (e.g., OpenAI, Sentence-Transformers). This utility exists
 * to exercise the vector store plumbing without ML dependencies.
 *
 * <p>This is a static utility class â€” not a Spring bean.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
public final class TextEmbeddingGenerator {

    private TextEmbeddingGenerator() {
        // Static utility class
    }

    /**
     * Generates a deterministic embedding vector from text.
     *
     * <p>Algorithm:
     * <ol>
     *   <li>Lowercase and tokenize the text by whitespace</li>
     *   <li>For each token, compute a SHA-256 hash</li>
     *   <li>Distribute hash bytes across the output dimensions</li>
     *   <li>L2-normalize the resulting vector</li>
     * </ol>
     *
     * @param text the input text
     * @param dimension the desired vector dimension (must be positive)
     * @return a normalized float array of the specified dimension
     * @throws IllegalArgumentException if dimension is not positive or text is null
     */
    public static float[] generateEmbedding(final String text, final int dimension) {
        if (text == null) {
            throw new IllegalArgumentException("text cannot be null");
        }
        if (dimension <= 0) {
            throw new IllegalArgumentException("dimension must be positive, got: " + dimension);
        }

        final float[] vector = new float[dimension];
        final String normalized = text.toLowerCase().trim();

        if (normalized.isEmpty()) {
            // Return zero vector for empty text (will remain zero after normalization attempt)
            return vector;
        }

        final String[] tokens = normalized.split("\\s+");

        for (final String token : tokens) {
            final byte[] hash = sha256(token);
            for (int i = 0; i < dimension; i++) {
                // Use hash bytes cyclically; convert to float in [-1, 1]
                final int byteIndex = i % hash.length;
                vector[i] += (hash[byteIndex] & 0xFF) / 127.5f - 1.0f;
            }
        }

        normalize(vector);
        return vector;
    }

    /**
     * L2-normalizes the vector in place.
     *
     * @param vector the vector to normalize
     */
    static void normalize(final float[] vector) {
        float sumSquares = 0.0f;
        for (final float v : vector) {
            sumSquares += v * v;
        }
        if (sumSquares == 0.0f) {
            return;
        }
        final float magnitude = (float) Math.sqrt(sumSquares);
        for (int i = 0; i < vector.length; i++) {
            vector[i] /= magnitude;
        }
    }

    private static byte[] sha256(final String input) {
        try {
            final MessageDigest digest = MessageDigest.getInstance("SHA-256");
            return digest.digest(input.getBytes(StandardCharsets.UTF_8));
        } catch (NoSuchAlgorithmException e) {
            // SHA-256 is required by the Java specification
            throw new IllegalStateException("SHA-256 not available", e);
        }
    }
}
