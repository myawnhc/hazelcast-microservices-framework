package com.theyawns.framework.store;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.hazelcast.partition.PartitionAware;

import java.io.Serializable;
import java.util.Objects;

/**
 * Composite key for partitioned event storage that ensures events for the same
 * domain object are stored on the same Hazelcast partition.
 *
 * <p>Key characteristics:
 * <ul>
 *   <li>Combines a globally unique sequence number with the domain object's partition key</li>
 *   <li>Implements {@link PartitionAware} to ensure partition co-location</li>
 *   <li>Sequence provides global ordering; partition key enables efficient queries</li>
 *   <li>Serializable to GenericRecord for Hazelcast storage</li>
 * </ul>
 *
 * <p>Example usage:
 * <pre>{@code
 * // Create a key for customer "cust-123" with sequence 1000
 * PartitionedSequenceKey<String> key = new PartitionedSequenceKey<>(1000L, "cust-123");
 *
 * // Use with Hazelcast IMap - events for same customer go to same partition
 * eventStoreMap.put(key, eventRecord);
 * }</pre>
 *
 * @param <K> The type of the partition key (typically the domain object's key type)
 * @author Generated by Claude Code
 * @since 1.0
 */
public class PartitionedSequenceKey<K> implements PartitionAware<K>, Comparable<PartitionedSequenceKey<K>>, Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * Schema name for GenericRecord serialization.
     */
    public static final String SCHEMA_NAME = "PartitionedSequenceKey";

    /**
     * Globally unique sequence number assigned by FlakeIdGenerator.
     */
    private final long sequence;

    /**
     * The partition key - typically the domain object's identifier.
     */
    private final K partitionKey;

    /**
     * Creates a new partitioned sequence key.
     *
     * @param sequence the globally unique sequence number
     * @param partitionKey the partition key for co-location
     * @throws IllegalArgumentException if partitionKey is null
     */
    public PartitionedSequenceKey(long sequence, K partitionKey) {
        if (partitionKey == null) {
            throw new IllegalArgumentException("partitionKey cannot be null");
        }
        this.sequence = sequence;
        this.partitionKey = partitionKey;
    }

    /**
     * Returns the globally unique sequence number.
     *
     * @return the sequence number
     */
    public long getSequence() {
        return sequence;
    }

    /**
     * Returns the partition key used for co-location.
     * This is also returned by {@link #getPartitionKey()} for Hazelcast.
     *
     * @return the partition key
     */
    public K getKey() {
        return partitionKey;
    }

    /**
     * Returns the partition key for Hazelcast partition awareness.
     * Events with the same partition key are stored on the same node.
     *
     * @return the partition key
     */
    @Override
    public K getPartitionKey() {
        return partitionKey;
    }

    /**
     * Serializes this key to a GenericRecord for Hazelcast storage.
     *
     * @return GenericRecord representation of this key
     */
    public GenericRecord toGenericRecord() {
        return GenericRecordBuilder.compact(SCHEMA_NAME)
                .setInt64("sequence", sequence)
                .setString("partitionKey", partitionKey.toString())
                .build();
    }

    /**
     * Creates a PartitionedSequenceKey from a GenericRecord.
     *
     * @param record the GenericRecord to deserialize
     * @param <K> the partition key type
     * @return a new PartitionedSequenceKey instance
     */
    @SuppressWarnings("unchecked")
    public static <K> PartitionedSequenceKey<K> fromGenericRecord(GenericRecord record) {
        long sequence = record.getInt64("sequence");
        String partitionKeyStr = record.getString("partitionKey");
        return new PartitionedSequenceKey<>(sequence, (K) partitionKeyStr);
    }

    /**
     * Compares keys by sequence number for ordering.
     * Keys are ordered by their sequence number regardless of partition key.
     *
     * @param other the other key to compare to
     * @return negative, zero, or positive based on sequence comparison
     */
    @Override
    public int compareTo(PartitionedSequenceKey<K> other) {
        return Long.compare(this.sequence, other.sequence);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        PartitionedSequenceKey<?> that = (PartitionedSequenceKey<?>) o;
        return sequence == that.sequence && Objects.equals(partitionKey, that.partitionKey);
    }

    @Override
    public int hashCode() {
        return Objects.hash(sequence, partitionKey);
    }

    @Override
    public String toString() {
        return "PartitionedSequenceKey{" +
                "sequence=" + sequence +
                ", partitionKey=" + partitionKey +
                '}';
    }
}
