package com.theyawns.framework.store;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.query.Predicate;
import com.hazelcast.query.Predicates;
import com.theyawns.framework.domain.DomainObject;
import com.theyawns.framework.event.DomainEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.function.Consumer;
import java.util.stream.Collectors;

/**
 * Hazelcast IMap-based implementation of the EventStore.
 * Stores events as GenericRecords in a distributed map.
 *
 * <p>Key characteristics:
 * <ul>
 *   <li>Uses PartitionedSequenceKey for partition-aware storage</li>
 *   <li>Events are stored as GenericRecord for schema flexibility</li>
 *   <li>Supports queries using Hazelcast predicates</li>
 *   <li>Thread-safe for concurrent access</li>
 * </ul>
 *
 * <p>Map naming convention: {@code {domainName}_ES}
 *
 * @param <D> The domain object type
 * @param <K> The domain object key type
 * @param <E> The event type
 * @author Generated by Claude Code
 * @since 1.0
 */
public class HazelcastEventStore<D extends DomainObject<K>, K, E extends DomainEvent<D, K>>
        implements EventStore<D, K, E>, java.io.Serializable {

    private static final long serialVersionUID = 1L;
    private static final Logger logger = LoggerFactory.getLogger(HazelcastEventStore.class);

    private final transient HazelcastInstance hazelcast;
    private final String storeName;
    private transient IMap<PartitionedSequenceKey<K>, GenericRecord> eventMap;

    /**
     * Creates a new HazelcastEventStore.
     *
     * @param hazelcast the Hazelcast instance
     * @param domainName the domain name (used for map naming)
     */
    public HazelcastEventStore(HazelcastInstance hazelcast, String domainName) {
        this.hazelcast = Objects.requireNonNull(hazelcast, "hazelcast cannot be null");
        Objects.requireNonNull(domainName, "domainName cannot be null");
        this.storeName = domainName + "_ES";
        this.eventMap = hazelcast.getMap(storeName);
        logger.info("Initialized EventStore: {}", storeName);
    }

    @Override
    public void append(PartitionedSequenceKey<K> key, E event) {
        Objects.requireNonNull(key, "key cannot be null");
        Objects.requireNonNull(event, "event cannot be null");
        GenericRecord record = event.toGenericRecord();
        append(key, record);
    }

    @Override
    public void append(PartitionedSequenceKey<K> key, GenericRecord eventRecord) {
        Objects.requireNonNull(key, "key cannot be null");
        Objects.requireNonNull(eventRecord, "eventRecord cannot be null");
        eventMap.set(key, eventRecord);
        logger.debug("Appended event with sequence {} for key {}", key.getSequence(), key.getKey());
    }

    @Override
    public Optional<GenericRecord> get(PartitionedSequenceKey<K> key) {
        Objects.requireNonNull(key, "key cannot be null");
        return Optional.ofNullable(eventMap.get(key));
    }

    @Override
    public List<GenericRecord> getEventsByKey(K domainObjectKey) {
        Objects.requireNonNull(domainObjectKey, "domainObjectKey cannot be null");
        return getEventsByKeyFromSequence(domainObjectKey, -1);
    }

    @Override
    public List<GenericRecord> getEventsByKeyFromSequence(K domainObjectKey, long fromSequence) {
        Objects.requireNonNull(domainObjectKey, "domainObjectKey cannot be null");

        // Filter entries by partition key and sequence
        List<Map.Entry<PartitionedSequenceKey<K>, GenericRecord>> entries = eventMap.entrySet().stream()
                .filter(e -> e.getKey().getKey().equals(domainObjectKey))
                .filter(e -> e.getKey().getSequence() > fromSequence)
                .sorted(Comparator.comparingLong(e -> e.getKey().getSequence()))
                .collect(Collectors.toList());

        return entries.stream()
                .map(Map.Entry::getValue)
                .collect(Collectors.toList());
    }

    @Override
    public List<GenericRecord> getEventsByType(String eventType) {
        Objects.requireNonNull(eventType, "eventType cannot be null");

        @SuppressWarnings("rawtypes")
        Predicate predicate = Predicates.equal("eventType", eventType);

        @SuppressWarnings("unchecked")
        Collection<GenericRecord> results = eventMap.values(predicate);
        return new ArrayList<>(results);
    }

    @Override
    public List<GenericRecord> getEventsByTimeRange(Instant from, Instant to) {
        Objects.requireNonNull(from, "from cannot be null");
        Objects.requireNonNull(to, "to cannot be null");

        long fromMillis = from.toEpochMilli();
        long toMillis = to.toEpochMilli();

        @SuppressWarnings("rawtypes")
        Predicate predicate = Predicates.and(
                Predicates.greaterEqual("timestamp", fromMillis),
                Predicates.lessThan("timestamp", toMillis)
        );

        @SuppressWarnings("unchecked")
        Collection<GenericRecord> results = eventMap.values(predicate);
        return new ArrayList<>(results);
    }

    @Override
    public List<GenericRecord> getEventsByTypeAndTimeRange(String eventType, Instant from, Instant to) {
        Objects.requireNonNull(eventType, "eventType cannot be null");
        Objects.requireNonNull(from, "from cannot be null");
        Objects.requireNonNull(to, "to cannot be null");

        long fromMillis = from.toEpochMilli();
        long toMillis = to.toEpochMilli();

        @SuppressWarnings("rawtypes")
        Predicate predicate = Predicates.and(
                Predicates.equal("eventType", eventType),
                Predicates.greaterEqual("timestamp", fromMillis),
                Predicates.lessThan("timestamp", toMillis)
        );

        @SuppressWarnings("unchecked")
        Collection<GenericRecord> results = eventMap.values(predicate);
        return new ArrayList<>(results);
    }

    @Override
    public long count() {
        return eventMap.size();
    }

    @Override
    public long countByKey(K domainObjectKey) {
        Objects.requireNonNull(domainObjectKey, "domainObjectKey cannot be null");
        return eventMap.keySet().stream()
                .filter(k -> k.getKey().equals(domainObjectKey))
                .count();
    }

    @Override
    public void replayAll(Consumer<GenericRecord> consumer) {
        Objects.requireNonNull(consumer, "consumer cannot be null");

        // Get all entries sorted by sequence
        eventMap.entrySet().stream()
                .sorted(Comparator.comparingLong(e -> e.getKey().getSequence()))
                .map(Map.Entry::getValue)
                .forEach(consumer);

        logger.info("Replayed {} events from {}", eventMap.size(), storeName);
    }

    @Override
    public void replayByKey(K domainObjectKey, Consumer<GenericRecord> consumer) {
        Objects.requireNonNull(domainObjectKey, "domainObjectKey cannot be null");
        Objects.requireNonNull(consumer, "consumer cannot be null");

        List<GenericRecord> events = getEventsByKey(domainObjectKey);
        events.forEach(consumer);

        logger.debug("Replayed {} events for key {} from {}", events.size(), domainObjectKey, storeName);
    }

    @Override
    public String getStoreName() {
        return storeName;
    }

    @Override
    public long getLatestSequence() {
        return eventMap.keySet().stream()
                .mapToLong(PartitionedSequenceKey::getSequence)
                .max()
                .orElse(-1L);
    }

    @Override
    public long getLatestSequenceByKey(K domainObjectKey) {
        Objects.requireNonNull(domainObjectKey, "domainObjectKey cannot be null");
        return eventMap.keySet().stream()
                .filter(k -> k.getKey().equals(domainObjectKey))
                .mapToLong(PartitionedSequenceKey::getSequence)
                .max()
                .orElse(-1L);
    }

    /**
     * Returns the underlying Hazelcast map for advanced operations.
     * Use with caution - prefer the interface methods.
     *
     * @return the underlying IMap
     */
    public IMap<PartitionedSequenceKey<K>, GenericRecord> getUnderlyingMap() {
        return eventMap;
    }
}
