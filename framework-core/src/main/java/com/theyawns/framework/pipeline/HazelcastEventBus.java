package com.theyawns.framework.pipeline;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.Message;
import com.hazelcast.topic.MessageListener;
import com.theyawns.framework.domain.DomainObject;
import com.theyawns.framework.event.DomainEvent;
import com.theyawns.framework.event.EventPublisher;
import com.theyawns.framework.event.EventSubscriber;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Map;
import java.util.Objects;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.function.Consumer;

/**
 * Hazelcast-based implementation of the event bus for pub/sub messaging.
 * Uses Hazelcast ITopic for reliable event delivery across the cluster.
 *
 * <p>Key features:
 * <ul>
 *   <li>Cluster-wide event distribution</li>
 *   <li>Type-based event filtering</li>
 *   <li>Subscription management with auto-generated IDs</li>
 *   <li>Both sync and async publishing</li>
 * </ul>
 *
 * <p>The event bus creates a topic per domain, following the naming convention:
 * {@code {domainName}_EVENTS}
 *
 * <p>Example usage:
 * <pre>{@code
 * HazelcastEventBus<Customer, String> eventBus =
 *     new HazelcastEventBus<>(hazelcast, "Customer");
 *
 * // Subscribe to all events
 * String subId = eventBus.subscribe(event ->
 *     System.out.println("Received: " + event.getEventType()));
 *
 * // Subscribe to specific event type
 * eventBus.subscribe("CustomerCreated", event ->
 *     System.out.println("Customer created: " + event.getKey()));
 *
 * // Publish event
 * eventBus.publish(customerCreatedEvent);
 *
 * // Unsubscribe
 * eventBus.unsubscribe(subId);
 * }</pre>
 *
 * @param <D> The domain object type
 * @param <K> The key type of the domain object
 * @author Generated by Claude Code
 * @since 1.0
 */
public class HazelcastEventBus<D extends DomainObject<K>, K>
        implements EventPublisher<D, K>, EventSubscriber<D, K> {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastEventBus.class);
    private static final String TOPIC_SUFFIX = "_EVENTS";

    private final HazelcastInstance hazelcast;
    private final String topicName;
    private final ITopic<DomainEvent<D, K>> topic;

    /**
     * Maps subscription IDs to their registration IDs for unsubscription.
     */
    private final Map<String, UUID> subscriptionMap;

    /**
     * Maps subscription IDs to type filters for filtered subscriptions.
     */
    private final Map<String, String> typeFilters;

    /**
     * Creates a HazelcastEventBus for the given domain.
     *
     * @param hazelcast the Hazelcast instance
     * @param domainName the domain name used to derive the topic name
     * @throws NullPointerException if hazelcast or domainName is null
     */
    public HazelcastEventBus(HazelcastInstance hazelcast, String domainName) {
        this.hazelcast = Objects.requireNonNull(hazelcast, "hazelcast cannot be null");
        Objects.requireNonNull(domainName, "domainName cannot be null");

        this.topicName = domainName + TOPIC_SUFFIX;
        this.topic = hazelcast.getTopic(topicName);
        this.subscriptionMap = new ConcurrentHashMap<>();
        this.typeFilters = new ConcurrentHashMap<>();

        logger.info("HazelcastEventBus created for topic: {}", topicName);
    }

    /**
     * Creates a HazelcastEventBus with an explicit topic name.
     *
     * @param hazelcast the Hazelcast instance
     * @param topicName the explicit topic name to use
     * @param ignored flag to distinguish from domain name constructor
     * @throws NullPointerException if hazelcast or topicName is null
     */
    public HazelcastEventBus(HazelcastInstance hazelcast, String topicName, boolean ignored) {
        this.hazelcast = Objects.requireNonNull(hazelcast, "hazelcast cannot be null");
        this.topicName = Objects.requireNonNull(topicName, "topicName cannot be null");

        this.topic = hazelcast.getTopic(topicName);
        this.subscriptionMap = new ConcurrentHashMap<>();
        this.typeFilters = new ConcurrentHashMap<>();

        logger.info("HazelcastEventBus created for explicit topic: {}", topicName);
    }

    // ==================== EventPublisher Implementation ====================

    /**
     * {@inheritDoc}
     */
    @Override
    public CompletableFuture<Void> publish(DomainEvent<D, K> event) {
        Objects.requireNonNull(event, "event cannot be null");

        return CompletableFuture.runAsync(() -> {
            try {
                topic.publish(event);
                logger.debug("Published event {} to topic {}",
                        event.getEventType(), topicName);
            } catch (Exception e) {
                logger.error("Failed to publish event {} to topic {}",
                        event.getEventType(), topicName, e);
                throw new RuntimeException("Failed to publish event", e);
            }
        });
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void publishSync(DomainEvent<D, K> event) {
        Objects.requireNonNull(event, "event cannot be null");

        try {
            topic.publish(event);
            logger.debug("Published event {} synchronously to topic {}",
                    event.getEventType(), topicName);
        } catch (Exception e) {
            logger.error("Failed to publish event {} synchronously to topic {}",
                    event.getEventType(), topicName, e);
            throw new RuntimeException("Failed to publish event", e);
        }
    }

    // ==================== EventSubscriber Implementation ====================

    /**
     * {@inheritDoc}
     */
    @Override
    public String subscribe(Consumer<DomainEvent<D, K>> handler) {
        Objects.requireNonNull(handler, "handler cannot be null");

        String subscriptionId = generateSubscriptionId();

        MessageListener<DomainEvent<D, K>> listener = new EventMessageListener(handler, null);
        UUID registrationId = topic.addMessageListener(listener);

        subscriptionMap.put(subscriptionId, registrationId);
        logger.debug("Subscribed to all events on topic {}, subscriptionId: {}",
                topicName, subscriptionId);

        return subscriptionId;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public String subscribe(String eventType, Consumer<DomainEvent<D, K>> handler) {
        Objects.requireNonNull(eventType, "eventType cannot be null");
        Objects.requireNonNull(handler, "handler cannot be null");

        String subscriptionId = generateSubscriptionId();

        MessageListener<DomainEvent<D, K>> listener = new EventMessageListener(handler, eventType);
        UUID registrationId = topic.addMessageListener(listener);

        subscriptionMap.put(subscriptionId, registrationId);
        typeFilters.put(subscriptionId, eventType);
        logger.debug("Subscribed to {} events on topic {}, subscriptionId: {}",
                eventType, topicName, subscriptionId);

        return subscriptionId;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public boolean unsubscribe(String subscriptionId) {
        if (subscriptionId == null) {
            return false;
        }

        UUID registrationId = subscriptionMap.remove(subscriptionId);
        typeFilters.remove(subscriptionId);

        if (registrationId != null) {
            boolean removed = topic.removeMessageListener(registrationId);
            logger.debug("Unsubscribed from topic {}, subscriptionId: {}, success: {}",
                    topicName, subscriptionId, removed);
            return removed;
        }

        return false;
    }

    // ==================== Common Methods ====================

    /**
     * {@inheritDoc}
     */
    @Override
    public String getTopicName() {
        return topicName;
    }

    /**
     * Returns the number of active subscriptions.
     *
     * @return the subscription count
     */
    public int getSubscriptionCount() {
        return subscriptionMap.size();
    }

    /**
     * Returns the underlying Hazelcast topic.
     * Use with caution; prefer the high-level API.
     *
     * @return the ITopic instance
     */
    public ITopic<DomainEvent<D, K>> getTopic() {
        return topic;
    }

    /**
     * Removes all subscriptions for this event bus.
     * Useful for cleanup during shutdown.
     */
    public void removeAllSubscriptions() {
        for (String subscriptionId : subscriptionMap.keySet()) {
            unsubscribe(subscriptionId);
        }
        logger.info("Removed all subscriptions from topic {}", topicName);
    }

    // ==================== Private Helpers ====================

    private String generateSubscriptionId() {
        return "sub-" + UUID.randomUUID().toString().substring(0, 8);
    }

    /**
     * Internal message listener that handles type filtering.
     */
    private class EventMessageListener implements MessageListener<DomainEvent<D, K>> {

        private final Consumer<DomainEvent<D, K>> handler;
        private final String eventTypeFilter;

        EventMessageListener(Consumer<DomainEvent<D, K>> handler, String eventTypeFilter) {
            this.handler = handler;
            this.eventTypeFilter = eventTypeFilter;
        }

        @Override
        public void onMessage(Message<DomainEvent<D, K>> message) {
            DomainEvent<D, K> event = message.getMessageObject();

            // Apply type filter if set
            if (eventTypeFilter != null && !eventTypeFilter.equals(event.getEventType())) {
                logger.trace("Filtered out event {} (expected {})",
                        event.getEventType(), eventTypeFilter);
                return;
            }

            try {
                handler.accept(event);
                logger.trace("Processed event {} from topic {}",
                        event.getEventType(), topicName);
            } catch (Exception e) {
                logger.error("Error processing event {} from topic {}",
                        event.getEventType(), topicName, e);
                // Don't rethrow - allow other listeners to process
            }
        }
    }
}
