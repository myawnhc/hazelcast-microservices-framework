package com.theyawns.framework.pipeline;

import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;

import java.io.Serializable;
import java.time.Duration;
import java.time.Instant;
import java.util.Objects;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.TimeUnit;

/**
 * Metrics collection for the event sourcing pipeline.
 * Provides instrumentation for each pipeline stage using Micrometer.
 *
 * <p>Key metrics collected:
 * <ul>
 *   <li>Event counts per stage (success/failure)</li>
 *   <li>Processing time per stage</li>
 *   <li>End-to-end latency</li>
 *   <li>Events in flight</li>
 * </ul>
 *
 * <p>All metrics are tagged with domain name and event type for
 * fine-grained monitoring.
 *
 * <p>Example usage:
 * <pre>{@code
 * PipelineMetrics metrics = new PipelineMetrics(meterRegistry, "Customer");
 *
 * // Record stage timing
 * Instant start = Instant.now();
 * processEvent(event);
 * metrics.recordStageTiming(PipelineStage.PERSIST, start);
 *
 * // Record completion
 * metrics.recordEventProcessed("CustomerCreated");
 * }</pre>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
public class PipelineMetrics implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * Enumeration of pipeline stages for metrics tracking.
     */
    public enum PipelineStage {
        /** Source stage: Reading from pending events */
        SOURCE("source"),
        /** Enrich stage: Adding metadata and timestamps */
        ENRICH("enrich"),
        /** Persist stage: Storing in event store */
        PERSIST("persist"),
        /** Update stage: Updating materialized views */
        UPDATE_VIEW("update_view"),
        /** Publish stage: Publishing to subscribers */
        PUBLISH("publish"),
        /** Complete stage: Signaling completion */
        COMPLETE("complete");

        private final String stageName;

        PipelineStage(String stageName) {
            this.stageName = stageName;
        }

        public String getStageName() {
            return stageName;
        }
    }

    private final transient MeterRegistry meterRegistry;
    private final String domainName;
    private final String metricsPrefix;

    // Cached counters and timers for performance
    private final transient ConcurrentMap<String, Counter> counterCache;
    private final transient ConcurrentMap<String, Timer> timerCache;

    /**
     * Creates a PipelineMetrics instance for the given domain.
     *
     * @param meterRegistry the Micrometer registry for metrics
     * @param domainName the domain name for tagging metrics
     * @throws NullPointerException if meterRegistry or domainName is null
     */
    public PipelineMetrics(MeterRegistry meterRegistry, String domainName) {
        this.meterRegistry = Objects.requireNonNull(meterRegistry, "meterRegistry cannot be null");
        this.domainName = Objects.requireNonNull(domainName, "domainName cannot be null");
        this.metricsPrefix = "eventsourcing.pipeline";
        this.counterCache = new ConcurrentHashMap<>();
        this.timerCache = new ConcurrentHashMap<>();
    }

    /**
     * Records that an event was successfully processed through the pipeline.
     *
     * @param eventType the type of event processed
     */
    public void recordEventProcessed(String eventType) {
        getCounter("events.processed", eventType).increment();
    }

    /**
     * Records that an event failed processing.
     *
     * @param eventType the type of event that failed
     * @param stage the stage where failure occurred
     */
    public void recordEventFailed(String eventType, PipelineStage stage) {
        getCounter("events.failed", eventType, stage.getStageName()).increment();
    }

    /**
     * Records timing for a specific pipeline stage.
     *
     * @param stage the pipeline stage
     * @param startTime when the stage started
     */
    public void recordStageTiming(PipelineStage stage, Instant startTime) {
        Duration duration = Duration.between(startTime, Instant.now());
        getTimer("stage.duration", stage.getStageName())
                .record(duration.toNanos(), TimeUnit.NANOSECONDS);
    }

    /**
     * Records timing for a specific pipeline stage with event type.
     *
     * @param stage the pipeline stage
     * @param eventType the type of event being processed
     * @param startTime when the stage started
     */
    public void recordStageTiming(PipelineStage stage, String eventType, Instant startTime) {
        Duration duration = Duration.between(startTime, Instant.now());
        getTimer("stage.duration", stage.getStageName(), eventType)
                .record(duration.toNanos(), TimeUnit.NANOSECONDS);
    }

    /**
     * Records timing for a specific pipeline stage with a pre-computed duration.
     *
     * @param stage the pipeline stage
     * @param eventType the type of event being processed
     * @param duration the pre-computed duration for this stage
     */
    public void recordStageTiming(PipelineStage stage, String eventType, Duration duration) {
        if (duration != null && !duration.isNegative()) {
            getTimer("stage.duration", stage.getStageName(), eventType)
                    .record(duration.toNanos(), TimeUnit.NANOSECONDS);
        }
    }

    /**
     * Records end-to-end latency from event submission to completion.
     *
     * @param eventType the type of event
     * @param submittedAt when the event was submitted
     */
    public void recordEndToEndLatency(String eventType, Instant submittedAt) {
        if (submittedAt != null) {
            Duration duration = Duration.between(submittedAt, Instant.now());
            getTimerByEventType("latency.end_to_end", eventType)
                    .record(duration.toNanos(), TimeUnit.NANOSECONDS);
        }
    }

    /**
     * Records end-to-end latency with a pre-computed duration.
     *
     * @param eventType the type of event
     * @param duration the pre-computed end-to-end duration
     */
    public void recordEndToEndLatency(String eventType, Duration duration) {
        if (duration != null && !duration.isNegative()) {
            getTimerByEventType("latency.end_to_end", eventType)
                    .record(duration.toNanos(), TimeUnit.NANOSECONDS);
        }
    }

    /**
     * Records the time spent waiting in the pending queue.
     *
     * @param eventType the type of event
     * @param submittedAt when the event was submitted
     * @param pipelineEntryTime when the event entered the pipeline
     */
    public void recordQueueWaitTime(String eventType, Instant submittedAt, Instant pipelineEntryTime) {
        if (submittedAt != null && pipelineEntryTime != null) {
            Duration duration = Duration.between(submittedAt, pipelineEntryTime);
            getTimerByEventType("latency.queue_wait", eventType)
                    .record(duration.toNanos(), TimeUnit.NANOSECONDS);
        }
    }

    /**
     * Records queue wait time with a pre-computed duration.
     *
     * @param eventType the type of event
     * @param duration the pre-computed queue wait duration
     */
    public void recordQueueWaitTime(String eventType, Duration duration) {
        if (duration != null && !duration.isNegative()) {
            getTimerByEventType("latency.queue_wait", eventType)
                    .record(duration.toNanos(), TimeUnit.NANOSECONDS);
        }
    }

    /**
     * Records that an event entered the pipeline.
     *
     * @param eventType the type of event
     */
    public void recordEventReceived(String eventType) {
        getCounter("events.received", eventType).increment();
    }

    /**
     * Records that a view was updated.
     *
     * @param eventType the type of event that caused the update
     */
    public void recordViewUpdated(String eventType) {
        getCounter("views.updated", eventType).increment();
    }

    /**
     * Records that an event was published to subscribers.
     *
     * @param eventType the type of event published
     */
    public void recordEventPublished(String eventType) {
        getCounter("events.published", eventType).increment();
    }

    /**
     * Returns the domain name for these metrics.
     *
     * @return the domain name
     */
    public String getDomainName() {
        return domainName;
    }

    /**
     * Returns the metrics prefix.
     *
     * @return the metrics prefix
     */
    public String getMetricsPrefix() {
        return metricsPrefix;
    }

    // Internal helper methods

    private Counter getCounter(String name, String eventType) {
        String key = name + ":" + eventType;
        return counterCache.computeIfAbsent(key, k ->
                Counter.builder(metricsPrefix + "." + name)
                        .tag("domain", domainName)
                        .tag("eventType", eventType)
                        .register(meterRegistry)
        );
    }

    private Counter getCounter(String name, String eventType, String stage) {
        String key = name + ":" + eventType + ":" + stage;
        return counterCache.computeIfAbsent(key, k ->
                Counter.builder(metricsPrefix + "." + name)
                        .tag("domain", domainName)
                        .tag("eventType", eventType)
                        .tag("stage", stage)
                        .register(meterRegistry)
        );
    }

    private Timer getTimer(String name, String stage) {
        String key = name + ":" + stage;
        return timerCache.computeIfAbsent(key, k ->
                Timer.builder(metricsPrefix + "." + name)
                        .tag("domain", domainName)
                        .tag("stage", stage)
                        .publishPercentiles(0.5, 0.95, 0.99)
                        .publishPercentileHistogram(true)
                        .register(meterRegistry)
        );
    }

    private Timer getTimer(String name, String stage, String eventType) {
        String key = name + ":" + stage + ":" + eventType;
        return timerCache.computeIfAbsent(key, k ->
                Timer.builder(metricsPrefix + "." + name)
                        .tag("domain", domainName)
                        .tag("stage", stage)
                        .tag("eventType", eventType)
                        .publishPercentiles(0.5, 0.95, 0.99)
                        .publishPercentileHistogram(true)
                        .register(meterRegistry)
        );
    }

    private Timer getTimerByEventType(String name, String eventType) {
        String key = name + ":eventType:" + eventType;
        return timerCache.computeIfAbsent(key, k ->
                Timer.builder(metricsPrefix + "." + name)
                        .tag("domain", domainName)
                        .tag("eventType", eventType)
                        .publishPercentiles(0.5, 0.95, 0.99)
                        .publishPercentileHistogram(true)
                        .register(meterRegistry)
        );
    }
}
