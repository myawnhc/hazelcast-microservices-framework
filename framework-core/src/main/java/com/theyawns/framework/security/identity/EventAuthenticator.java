package com.theyawns.framework.security.identity;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.Objects;
import java.util.Set;

/**
 * Wraps and unwraps domain events in authenticated envelopes for secure
 * cross-service ITopic communication.
 *
 * <p>When publishing events to the shared Hazelcast cluster, the authenticator
 * wraps each event {@link GenericRecord} in an {@code AuthenticatedEventEnvelope}
 * that includes:
 * <ul>
 *   <li>{@code sourceService} — the publishing service name</li>
 *   <li>{@code eventSignature} — HMAC-SHA256 of key event fields</li>
 *   <li>{@code signedAt} — timestamp of signing (epoch ms)</li>
 *   <li>{@code eventType} — the event type name</li>
 *   <li>{@code payload} — the original event as a nested GenericRecord</li>
 * </ul>
 *
 * <p>Consumers use {@link #unwrapAndVerify(GenericRecord)} to extract the
 * original event and validate the signature. Unknown/unsigned records are
 * passed through unchanged for backward compatibility.
 *
 * <p>This class is thread-safe.
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see ServiceIdentity
 */
public class EventAuthenticator {

    private static final Logger logger = LoggerFactory.getLogger(EventAuthenticator.class);

    /** Schema name for the authenticated event envelope. */
    static final String ENVELOPE_SCHEMA = "AuthenticatedEventEnvelope";

    /** Field names in the envelope schema. */
    static final String FIELD_SOURCE_SERVICE = "sourceService";
    static final String FIELD_EVENT_SIGNATURE = "eventSignature";
    static final String FIELD_SIGNED_AT = "signedAt";
    static final String FIELD_EVENT_TYPE = "eventType";
    static final String FIELD_PAYLOAD = "payload";

    private final ServiceIdentity serviceIdentity;

    /**
     * Creates a new EventAuthenticator.
     *
     * @param serviceIdentity the service identity used for signing/verification
     * @throws NullPointerException if serviceIdentity is null
     */
    public EventAuthenticator(final ServiceIdentity serviceIdentity) {
        this.serviceIdentity = Objects.requireNonNull(serviceIdentity, "serviceIdentity cannot be null");
    }

    /**
     * Wraps a domain event in an authenticated envelope.
     *
     * <p>The envelope contains the original event as a nested {@code payload}
     * GenericRecord, along with the signing service name, HMAC signature, and
     * signing timestamp.
     *
     * @param event     the domain event GenericRecord to wrap
     * @param eventType the event type name (e.g., "OrderCreated")
     * @return the authenticated envelope GenericRecord
     * @throws NullPointerException if any parameter is null
     */
    public GenericRecord wrapWithAuthentication(final GenericRecord event, final String eventType) {
        Objects.requireNonNull(event, "event cannot be null");
        Objects.requireNonNull(eventType, "eventType cannot be null");

        final String signingData = buildSigningData(event, eventType);
        final String signature = serviceIdentity.sign(signingData);

        return GenericRecordBuilder.compact(ENVELOPE_SCHEMA)
                .setString(FIELD_SOURCE_SERVICE, serviceIdentity.getServiceName())
                .setString(FIELD_EVENT_SIGNATURE, signature)
                .setInt64(FIELD_SIGNED_AT, Instant.now().toEpochMilli())
                .setString(FIELD_EVENT_TYPE, eventType)
                .setGenericRecord(FIELD_PAYLOAD, event)
                .build();
    }

    /**
     * Unwraps an authenticated envelope and verifies its signature.
     *
     * <p>If the record is not an envelope (e.g., a raw event from a service
     * that doesn't have service identity configured), it is returned as-is
     * for backward compatibility.
     *
     * <p>If the signature is invalid, a warning is logged but the event is
     * still returned (warn-only mode). Future versions may support strict
     * rejection via configuration.
     *
     * @param record the GenericRecord that may be an envelope or a raw event
     * @return the unwrapped event GenericRecord (or the original if not an envelope)
     */
    public GenericRecord unwrapAndVerify(final GenericRecord record) {
        Objects.requireNonNull(record, "record cannot be null");

        if (!isEnvelope(record)) {
            return record;
        }

        final GenericRecord payload = record.getGenericRecord(FIELD_PAYLOAD);
        final String eventType = record.getString(FIELD_EVENT_TYPE);
        final String sourceService = record.getString(FIELD_SOURCE_SERVICE);
        final String signature = record.getString(FIELD_EVENT_SIGNATURE);

        if (payload == null) {
            logger.warn("Authenticated envelope from {} has null payload — returning raw record", sourceService);
            return record;
        }

        final String signingData = buildSigningData(payload, eventType);
        if (!serviceIdentity.verify(signingData, signature)) {
            logger.warn("Invalid event signature from service '{}' for event type '{}' — "
                    + "event will be processed (warn-only mode) but may not be trustworthy",
                    sourceService, eventType);
        } else if (logger.isDebugEnabled()) {
            logger.debug("Verified event signature from service '{}' for event type '{}'",
                    sourceService, eventType);
        }

        return payload;
    }

    /**
     * Checks whether a GenericRecord is an authenticated event envelope.
     *
     * <p>Detection is based on the presence of the {@code payload} and
     * {@code eventSignature} fields, which are unique to the envelope schema.
     *
     * @param record the GenericRecord to check
     * @return true if the record is an authenticated envelope
     */
    public static boolean isEnvelope(final GenericRecord record) {
        if (record == null) {
            return false;
        }
        final Set<String> fieldNames = record.getFieldNames();
        return fieldNames.contains(FIELD_PAYLOAD)
                && fieldNames.contains(FIELD_EVENT_SIGNATURE)
                && fieldNames.contains(FIELD_SOURCE_SERVICE);
    }

    /**
     * Builds the canonical string used for HMAC signing.
     *
     * <p>The signing data includes the eventId, eventType, and source fields
     * from the event, concatenated with a delimiter. This ensures the signature
     * covers the event's identity without depending on the full payload structure
     * (which varies by event type).
     *
     * @param event     the event GenericRecord
     * @param eventType the event type name
     * @return the canonical signing string
     */
    private String buildSigningData(final GenericRecord event, final String eventType) {
        final String eventId = event.getString("eventId");
        final String source = event.getString("source");
        return eventId + "|" + eventType + "|" + source;
    }
}
