package com.theyawns.framework.security.identity;

import javax.crypto.Mac;
import javax.crypto.spec.SecretKeySpec;
import java.nio.charset.StandardCharsets;
import java.security.InvalidKeyException;
import java.security.NoSuchAlgorithmException;
import java.util.Base64;
import java.util.Objects;

/**
 * Represents the identity of a microservice within the framework cluster.
 *
 * <p>Each service has a unique name and a shared HMAC-SHA256 key used to sign
 * events published to ITopic. Consumers verify the signature to authenticate
 * that events originated from a trusted service.
 *
 * <p>The signing process:
 * <ol>
 *   <li>Concatenate key event fields into a canonical string</li>
 *   <li>Compute HMAC-SHA256 using the shared secret</li>
 *   <li>Base64-encode the result</li>
 * </ol>
 *
 * <p>This class is thread-safe.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
public class ServiceIdentity {

    private static final String HMAC_ALGORITHM = "HmacSHA256";

    private final String serviceName;
    private final byte[] secretKeyBytes;

    /**
     * Creates a new ServiceIdentity.
     *
     * @param serviceName  the unique name of this service
     * @param sharedSecret the shared secret key for HMAC signing
     * @throws NullPointerException if any parameter is null
     */
    public ServiceIdentity(final String serviceName, final String sharedSecret) {
        this.serviceName = Objects.requireNonNull(serviceName, "serviceName cannot be null");
        Objects.requireNonNull(sharedSecret, "sharedSecret cannot be null");
        this.secretKeyBytes = sharedSecret.getBytes(StandardCharsets.UTF_8);
    }

    /**
     * Returns the service name.
     *
     * @return the unique service name
     */
    public String getServiceName() {
        return serviceName;
    }

    /**
     * Computes an HMAC-SHA256 signature for the given data.
     *
     * @param data the data to sign
     * @return Base64-encoded HMAC-SHA256 signature
     * @throws NullPointerException if data is null
     */
    public String sign(final String data) {
        Objects.requireNonNull(data, "data cannot be null");
        try {
            final Mac mac = Mac.getInstance(HMAC_ALGORITHM);
            mac.init(new SecretKeySpec(secretKeyBytes, HMAC_ALGORITHM));
            final byte[] rawHmac = mac.doFinal(data.getBytes(StandardCharsets.UTF_8));
            return Base64.getEncoder().encodeToString(rawHmac);
        } catch (NoSuchAlgorithmException | InvalidKeyException e) {
            throw new IllegalStateException("Failed to compute HMAC-SHA256 signature", e);
        }
    }

    /**
     * Verifies an HMAC-SHA256 signature against the given data.
     *
     * @param data      the original data that was signed
     * @param signature the Base64-encoded signature to verify
     * @return true if the signature is valid
     * @throws NullPointerException if any parameter is null
     */
    public boolean verify(final String data, final String signature) {
        Objects.requireNonNull(data, "data cannot be null");
        Objects.requireNonNull(signature, "signature cannot be null");
        final String expected = sign(data);
        return expected.equals(signature);
    }

    @Override
    public String toString() {
        return "ServiceIdentity{serviceName='" + serviceName + "'}";
    }
}
