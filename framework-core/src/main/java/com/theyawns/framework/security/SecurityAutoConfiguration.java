package com.theyawns.framework.security;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.AutoConfigureBefore;
import org.springframework.boot.autoconfigure.condition.ConditionalOnClass;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.autoconfigure.condition.ConditionalOnWebApplication;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.oauth2.jwt.JwtDecoder;
import org.springframework.security.web.SecurityFilterChain;

import java.util.Arrays;

/**
 * Auto-configuration for JWT-secured servlet endpoints.
 *
 * <p>This configuration activates only when:
 * <ul>
 *   <li>{@code framework.security.enabled=true}</li>
 *   <li>Spring Security and OAuth2 Resource Server are on the classpath</li>
 *   <li>The application is a servlet web application</li>
 * </ul>
 *
 * <p>When active, creates a {@link SecurityFilterChain} that:
 * <ul>
 *   <li>Permits access to paths listed in {@link SecurityProperties#getPublicPaths()}</li>
 *   <li>Requires JWT Bearer token authentication for all other requests</li>
 *   <li>Disables CSRF (appropriate for stateless REST APIs)</li>
 * </ul>
 *
 * <p>JWT decoder configuration is delegated to Spring Boot's native properties:
 * {@code spring.security.oauth2.resourceserver.jwt.issuer-uri} or
 * {@code spring.security.oauth2.resourceserver.jwt.jwk-set-uri}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see SecurityProperties
 * @see PermitAllSecurityAutoConfiguration
 */
@Configuration("frameworkSecurityAutoConfiguration")
@ConditionalOnClass({SecurityFilterChain.class, JwtDecoder.class})
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnProperty(name = "framework.security.enabled", havingValue = "true")
@EnableConfigurationProperties(SecurityProperties.class)
@AutoConfigureBefore(name = "org.springframework.boot.autoconfigure.security.servlet.SecurityAutoConfiguration")
public class SecurityAutoConfiguration {

    private static final Logger logger = LoggerFactory.getLogger(SecurityAutoConfiguration.class);

    /**
     * Creates a JWT-secured {@link SecurityFilterChain} for servlet applications.
     *
     * <p>Public paths from {@link SecurityProperties} are permitted without authentication.
     * All other requests require a valid JWT Bearer token.
     *
     * @param http the {@link HttpSecurity} builder
     * @param properties the security configuration properties
     * @return the configured security filter chain
     * @throws Exception if configuration fails
     */
    @Bean
    @ConditionalOnMissingBean
    public SecurityFilterChain securityFilterChain(final HttpSecurity http,
                                                    final SecurityProperties properties) throws Exception {
        logger.info("Configuring JWT-secured SecurityFilterChain with public paths: {}",
                Arrays.toString(properties.getPublicPaths()));

        http
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> {
                    for (final String path : properties.getPublicPaths()) {
                        auth.requestMatchers(path).permitAll();
                    }
                    auth.anyRequest().authenticated();
                })
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));

        return http.build();
    }
}
