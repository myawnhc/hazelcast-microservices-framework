package com.theyawns.framework.controller;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.flakeidgen.FlakeIdGenerator;
import com.hazelcast.jet.Job;
import com.hazelcast.map.IMap;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.framework.domain.DomainObject;
import com.theyawns.framework.event.DomainEvent;
import com.theyawns.framework.pipeline.EventSourcingPipeline;
import com.theyawns.framework.pipeline.HazelcastEventBus;
import com.theyawns.framework.store.EventStore;
import com.theyawns.framework.store.PartitionedSequenceKey;
import com.theyawns.framework.view.HazelcastViewStore;
import com.theyawns.framework.view.ViewUpdater;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.Objects;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;

/**
 * Main controller for the event sourcing framework.
 * Provides the central handleEvent() method that all services use to process events.
 *
 * <p>Responsibilities:
 * <ul>
 *   <li>Accept events via handleEvent()</li>
 *   <li>Assign sequence numbers using FlakeIdGenerator</li>
 *   <li>Write to PendingEvents (triggers pipeline)</li>
 *   <li>Track completion via CompletionInfo</li>
 *   <li>Return CompletableFuture for async responses</li>
 * </ul>
 *
 * <p>Example usage:
 * <pre>{@code
 * EventSourcingController<Customer, String, CustomerEvent> controller =
 *     EventSourcingController.<Customer, String, CustomerEvent>builder()
 *         .hazelcast(hazelcastInstance)
 *         .domainName("Customer")
 *         .eventStore(customerEventStore)
 *         .viewUpdater(customerViewUpdater)
 *         .meterRegistry(meterRegistry)
 *         .build();
 *
 * // Start the pipeline
 * controller.start();
 *
 * // Handle an event
 * CompletableFuture<CompletionInfo<String>> future =
 *     controller.handleEvent(customerCreatedEvent);
 *
 * // Get completion info
 * CompletionInfo<String> info = future.get();
 * }</pre>
 *
 * @param <D> Domain object type
 * @param <K> Domain object key type (must be Comparable)
 * @param <E> Base event type for this domain
 * @author Generated by Claude Code
 * @since 1.0
 */
public class EventSourcingController<D extends DomainObject<K>,
        K extends Comparable<K>,
        E extends DomainEvent<D, K>> {

    private static final Logger logger = LoggerFactory.getLogger(EventSourcingController.class);

    private static final String PENDING_SUFFIX = "_PENDING";
    private static final String VIEW_SUFFIX = "_VIEW";
    private static final String SEQUENCE_GEN_SUFFIX = "_SEQ";

    private final HazelcastInstance hazelcast;
    private final String domainName;
    private final FlakeIdGenerator sequenceGenerator;
    private final EventStore<D, K, E> eventStore;
    private final ViewUpdater<K> viewUpdater;
    private final IMap<PartitionedSequenceKey<K>, GenericRecord> pendingEventsMap;
    private final MeterRegistry meterRegistry;
    private final EventSourcingPipeline<D, K, E> pipeline;

    /**
     * Tracks pending completions for async notification.
     */
    private final ConcurrentMap<PartitionedSequenceKey<K>, CompletableFuture<CompletionInfo<K>>> pendingCompletions;

    /**
     * Private constructor - use builder.
     */
    private EventSourcingController(Builder<D, K, E> builder) {
        this.hazelcast = builder.hazelcast;
        this.domainName = builder.domainName;
        this.eventStore = builder.eventStore;
        this.viewUpdater = builder.viewUpdater;
        this.meterRegistry = builder.meterRegistry;

        // Initialize Hazelcast structures
        this.sequenceGenerator = hazelcast.getFlakeIdGenerator(domainName + SEQUENCE_GEN_SUFFIX);
        this.pendingEventsMap = hazelcast.getMap(domainName + PENDING_SUFFIX);
        this.pendingCompletions = new ConcurrentHashMap<>();

        // Build the pipeline
        EventSourcingPipeline.Builder<D, K, E> pipelineBuilder =
                EventSourcingPipeline.<D, K, E>builder()
                        .hazelcast(hazelcast)
                        .domainName(domainName)
                        .eventStore(eventStore)
                        .viewUpdater(viewUpdater)
                        .meterRegistry(meterRegistry);

        if (builder.eventBus != null) {
            pipelineBuilder.eventBus(builder.eventBus);
        }

        this.pipeline = pipelineBuilder.build();

        logger.info("EventSourcingController initialized for domain: {}", domainName);
    }

    /**
     * Starts the event sourcing pipeline.
     * Must be called before handling events.
     *
     * @return the running Jet job
     */
    public Job start() {
        Job job = pipeline.start();
        logger.info("EventSourcingController started for domain: {}", domainName);
        return job;
    }

    /**
     * Stops the event sourcing pipeline.
     */
    public void stop() {
        pipeline.stop();
        logger.info("EventSourcingController stopped for domain: {}", domainName);
    }

    /**
     * Returns whether the pipeline is running.
     *
     * @return true if running
     */
    public boolean isRunning() {
        return pipeline.isRunning();
    }

    /**
     * Central event handling method with full parameters.
     *
     * <p>Process:
     * <ol>
     *   <li>Set event metadata (correlation ID, timestamp, source)</li>
     *   <li>Assign sequence number via FlakeIdGenerator</li>
     *   <li>Write to PendingEvents map (triggers pipeline)</li>
     *   <li>Return future that completes when processing finishes</li>
     * </ol>
     *
     * @param event the domain event to process
     * @param correlationId UUID linking related events across services
     * @param sagaMetadata optional saga information (null if not part of saga)
     * @return CompletableFuture that completes when event is processed
     */
    public CompletableFuture<CompletionInfo<K>> handleEvent(
            E event,
            UUID correlationId,
            SagaMetadata sagaMetadata) {

        Objects.requireNonNull(event, "event cannot be null");
        Objects.requireNonNull(correlationId, "correlationId cannot be null");

        try {
            // Set metadata
            event.setCorrelationId(correlationId.toString());
            event.setSource(domainName);
            event.setSubmittedAt(Instant.now());

            // Saga support
            if (sagaMetadata != null) {
                event.setSagaId(sagaMetadata.getSagaId());
                event.setSagaType(sagaMetadata.getSagaType());
                event.setStepNumber(sagaMetadata.getStepNumber());
                event.setIsCompensating(sagaMetadata.getIsCompensating());
            }

            // Assign sequence number
            long sequence = sequenceGenerator.newId();
            PartitionedSequenceKey<K> psk = new PartitionedSequenceKey<>(sequence, event.getKey());

            // Create completion tracker
            CompletionInfo<K> completionInfo = new CompletionInfo<>(
                    psk, correlationId, event.getEventType(), event.getEventId());

            CompletableFuture<CompletionInfo<K>> future = new CompletableFuture<>();
            pendingCompletions.put(psk, future);

            // Write to pending events map (TRIGGERS PIPELINE)
            GenericRecord eventRecord = event.toGenericRecord();
            pendingEventsMap.set(psk, eventRecord);

            // Record metrics
            meterRegistry.counter("eventsourcing.events.submitted",
                    "eventType", event.getEventType(),
                    "domain", domainName
            ).increment();

            logger.debug("Event submitted: {} (key: {}, correlation: {}, sequence: {})",
                    event.getEventType(), event.getKey(), correlationId, sequence);

            // For now, complete immediately (pipeline completion tracking to be enhanced)
            // In a full implementation, the pipeline would call back to complete the future
            completionInfo.markCompleted();
            future.complete(completionInfo);
            pendingCompletions.remove(psk);

            return future;

        } catch (Exception e) {
            logger.error("Failed to handle event: {} for key: {}",
                    event.getEventType(), event.getKey(), e);

            meterRegistry.counter("eventsourcing.events.failed",
                    "eventType", event.getEventType(),
                    "domain", domainName
            ).increment();

            CompletableFuture<CompletionInfo<K>> failedFuture = new CompletableFuture<>();
            failedFuture.completeExceptionally(e);
            return failedFuture;
        }
    }

    /**
     * Handles an event with correlation ID but no saga metadata.
     *
     * @param event the domain event to process
     * @param correlationId UUID linking related events
     * @return CompletableFuture that completes when event is processed
     */
    public CompletableFuture<CompletionInfo<K>> handleEvent(E event, UUID correlationId) {
        return handleEvent(event, correlationId, null);
    }

    /**
     * Handles an event with auto-generated correlation ID.
     *
     * @param event the domain event to process
     * @return CompletableFuture that completes when event is processed
     */
    public CompletableFuture<CompletionInfo<K>> handleEvent(E event) {
        return handleEvent(event, UUID.randomUUID(), null);
    }

    /**
     * Retrieves the current state of a domain object from the materialized view.
     *
     * @param key the domain object key
     * @return the current state, or empty if not found
     */
    public Optional<GenericRecord> getViewState(K key) {
        return viewUpdater.getViewStore().get(key);
    }

    /**
     * Rebuilds the entire view from the event store.
     * Use with caution - this can be expensive for large event stores.
     *
     * @return the number of events replayed
     */
    public long rebuildView() {
        logger.info("Rebuilding view for domain: {}", domainName);
        return viewUpdater.rebuild(eventStore);
    }

    /**
     * Rebuilds the view for a single domain object.
     *
     * @param key the domain object key
     * @return the final view state, or empty if no events
     */
    public Optional<GenericRecord> rebuildViewForKey(K key) {
        logger.info("Rebuilding view for key: {} in domain: {}", key, domainName);
        return viewUpdater.rebuildForKey(key, eventStore);
    }

    // Getters

    /**
     * Returns the domain name.
     *
     * @return the domain name
     */
    public String getDomainName() {
        return domainName;
    }

    /**
     * Returns the event store.
     *
     * @return the event store
     */
    public EventStore<D, K, E> getEventStore() {
        return eventStore;
    }

    /**
     * Returns the view store.
     *
     * @return the view store
     */
    public HazelcastViewStore<K> getViewStore() {
        return viewUpdater.getViewStore();
    }

    /**
     * Returns the event bus.
     *
     * @return the event bus
     */
    public HazelcastEventBus<D, K> getEventBus() {
        return pipeline.getEventBus();
    }

    /**
     * Returns the Hazelcast instance.
     *
     * @return the Hazelcast instance
     */
    public HazelcastInstance getHazelcast() {
        return hazelcast;
    }

    /**
     * Returns the pipeline.
     *
     * @return the event sourcing pipeline
     */
    public EventSourcingPipeline<D, K, E> getPipeline() {
        return pipeline;
    }

    // Builder

    /**
     * Creates a new builder for EventSourcingController.
     *
     * @param <D> Domain object type
     * @param <K> Domain object key type
     * @param <E> Event type
     * @return a new builder
     */
    public static <D extends DomainObject<K>, K extends Comparable<K>,
            E extends DomainEvent<D, K>> Builder<D, K, E> builder() {
        return new Builder<>();
    }

    /**
     * Builder for EventSourcingController.
     *
     * @param <D> Domain object type
     * @param <K> Domain object key type
     * @param <E> Event type
     */
    public static class Builder<D extends DomainObject<K>, K extends Comparable<K>,
            E extends DomainEvent<D, K>> {

        private HazelcastInstance hazelcast;
        private String domainName;
        private EventStore<D, K, E> eventStore;
        private ViewUpdater<K> viewUpdater;
        private HazelcastEventBus<D, K> eventBus;
        private MeterRegistry meterRegistry;

        /**
         * Sets the Hazelcast instance.
         *
         * @param hazelcast the Hazelcast instance
         * @return this builder
         */
        public Builder<D, K, E> hazelcast(HazelcastInstance hazelcast) {
            this.hazelcast = hazelcast;
            return this;
        }

        /**
         * Sets the domain name.
         *
         * @param domainName the domain name (e.g., "Customer", "Order")
         * @return this builder
         */
        public Builder<D, K, E> domainName(String domainName) {
            this.domainName = domainName;
            return this;
        }

        /**
         * Sets the event store.
         *
         * @param eventStore the event store
         * @return this builder
         */
        public Builder<D, K, E> eventStore(EventStore<D, K, E> eventStore) {
            this.eventStore = eventStore;
            return this;
        }

        /**
         * Sets the view updater.
         *
         * @param viewUpdater the view updater
         * @return this builder
         */
        public Builder<D, K, E> viewUpdater(ViewUpdater<K> viewUpdater) {
            this.viewUpdater = viewUpdater;
            return this;
        }

        /**
         * Sets the event bus (optional - will be created if not provided).
         *
         * @param eventBus the event bus
         * @return this builder
         */
        public Builder<D, K, E> eventBus(HazelcastEventBus<D, K> eventBus) {
            this.eventBus = eventBus;
            return this;
        }

        /**
         * Sets the meter registry for metrics.
         *
         * @param meterRegistry the meter registry
         * @return this builder
         */
        public Builder<D, K, E> meterRegistry(MeterRegistry meterRegistry) {
            this.meterRegistry = meterRegistry;
            return this;
        }

        /**
         * Builds the EventSourcingController.
         *
         * @return the configured controller
         * @throws NullPointerException if required parameters are missing
         */
        public EventSourcingController<D, K, E> build() {
            Objects.requireNonNull(hazelcast, "hazelcast is required");
            Objects.requireNonNull(domainName, "domainName is required");
            Objects.requireNonNull(eventStore, "eventStore is required");
            Objects.requireNonNull(viewUpdater, "viewUpdater is required");
            Objects.requireNonNull(meterRegistry, "meterRegistry is required");

            return new EventSourcingController<>(this);
        }
    }
}
