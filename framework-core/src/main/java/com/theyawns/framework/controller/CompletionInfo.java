package com.theyawns.framework.controller;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.framework.store.PartitionedSequenceKey;

import java.io.Serializable;
import java.time.Instant;
import java.util.Objects;
import java.util.UUID;

/**
 * Tracks the completion status of an event as it flows through the pipeline.
 * Used for async completion notification and debugging.
 *
 * <p>CompletionInfo captures:
 * <ul>
 *   <li>The event's key and sequence number</li>
 *   <li>Correlation ID for tracing</li>
 *   <li>Submission and completion timestamps</li>
 *   <li>Success/failure status</li>
 *   <li>Error information if failed</li>
 * </ul>
 *
 * <p>Example usage:
 * <pre>{@code
 * CompletionInfo info = CompletionInfo.builder()
 *     .eventKey(partitionedKey)
 *     .correlationId(correlationId)
 *     .eventType("CustomerCreated")
 *     .build();
 *
 * // Later, when processing completes
 * info.markCompleted();
 *
 * // Or if it fails
 * info.markFailed("Validation error: email already exists");
 * }</pre>
 *
 * @param <K> The domain object key type
 * @author Generated by Claude Code
 * @since 1.0
 */
public class CompletionInfo<K> implements Serializable {

    private static final long serialVersionUID = 1L;
    private static final String SCHEMA_NAME = "CompletionInfo";

    /**
     * Completion status enumeration.
     */
    public enum Status {
        /** Event has been submitted but not yet processed */
        PENDING,
        /** Event is currently being processed */
        PROCESSING,
        /** Event was successfully processed */
        COMPLETED,
        /** Event processing failed */
        FAILED
    }

    private final PartitionedSequenceKey<K> eventKey;
    private final UUID correlationId;
    private final String eventType;
    private final String eventId;
    private final Instant submittedAt;

    private Status status;
    private Instant completedAt;
    private String errorMessage;
    private String errorCode;

    /**
     * Creates a new CompletionInfo for an event.
     *
     * @param eventKey the partitioned sequence key for the event
     * @param correlationId the correlation ID linking related events
     * @param eventType the type of event
     * @param eventId the unique event ID
     */
    public CompletionInfo(PartitionedSequenceKey<K> eventKey, UUID correlationId,
                          String eventType, String eventId) {
        this.eventKey = Objects.requireNonNull(eventKey, "eventKey cannot be null");
        this.correlationId = Objects.requireNonNull(correlationId, "correlationId cannot be null");
        this.eventType = Objects.requireNonNull(eventType, "eventType cannot be null");
        this.eventId = Objects.requireNonNull(eventId, "eventId cannot be null");
        this.submittedAt = Instant.now();
        this.status = Status.PENDING;
    }

    /**
     * Creates a CompletionInfo from an event's GenericRecord.
     *
     * @param eventKey the partitioned sequence key
     * @param eventRecord the event as a GenericRecord
     * @param correlationId the correlation ID
     */
    public CompletionInfo(PartitionedSequenceKey<K> eventKey, GenericRecord eventRecord,
                          UUID correlationId) {
        this(eventKey, correlationId,
                extractString(eventRecord, "eventType", "unknown"),
                extractString(eventRecord, "eventId", "unknown"));
    }

    /**
     * Marks the event as currently being processed.
     */
    public void markProcessing() {
        this.status = Status.PROCESSING;
    }

    /**
     * Marks the event as successfully completed.
     */
    public void markCompleted() {
        this.status = Status.COMPLETED;
        this.completedAt = Instant.now();
    }

    /**
     * Marks the event as failed with an error message.
     *
     * @param errorMessage description of the failure
     */
    public void markFailed(String errorMessage) {
        markFailed(errorMessage, null);
    }

    /**
     * Marks the event as failed with an error message and code.
     *
     * @param errorMessage description of the failure
     * @param errorCode optional error code for programmatic handling
     */
    public void markFailed(String errorMessage, String errorCode) {
        this.status = Status.FAILED;
        this.completedAt = Instant.now();
        this.errorMessage = errorMessage;
        this.errorCode = errorCode;
    }

    /**
     * Returns whether processing is complete (successfully or with failure).
     *
     * @return true if completed or failed
     */
    public boolean isDone() {
        return status == Status.COMPLETED || status == Status.FAILED;
    }

    /**
     * Returns whether processing completed successfully.
     *
     * @return true if completed successfully
     */
    public boolean isSuccess() {
        return status == Status.COMPLETED;
    }

    /**
     * Returns whether processing failed.
     *
     * @return true if failed
     */
    public boolean isFailed() {
        return status == Status.FAILED;
    }

    /**
     * Returns the processing duration in milliseconds.
     * Returns -1 if not yet completed.
     *
     * @return processing duration in milliseconds, or -1
     */
    public long getProcessingTimeMs() {
        if (completedAt == null) {
            return -1;
        }
        return completedAt.toEpochMilli() - submittedAt.toEpochMilli();
    }

    // Getters

    public PartitionedSequenceKey<K> getEventKey() {
        return eventKey;
    }

    public UUID getCorrelationId() {
        return correlationId;
    }

    public String getEventType() {
        return eventType;
    }

    public String getEventId() {
        return eventId;
    }

    public Instant getSubmittedAt() {
        return submittedAt;
    }

    public Status getStatus() {
        return status;
    }

    public Instant getCompletedAt() {
        return completedAt;
    }

    public String getErrorMessage() {
        return errorMessage;
    }

    public String getErrorCode() {
        return errorCode;
    }

    /**
     * Serializes this completion info to a GenericRecord.
     *
     * @return the GenericRecord representation
     */
    public GenericRecord toGenericRecord() {
        GenericRecordBuilder builder = GenericRecordBuilder.compact(SCHEMA_NAME)
                .setInt64("sequence", eventKey.getSequence())
                .setString("correlationId", correlationId.toString())
                .setString("eventType", eventType)
                .setString("eventId", eventId)
                .setInt64("submittedAt", submittedAt.toEpochMilli())
                .setString("status", status.name());

        if (completedAt != null) {
            builder.setInt64("completedAt", completedAt.toEpochMilli());
        }
        if (errorMessage != null) {
            builder.setString("errorMessage", errorMessage);
        }
        if (errorCode != null) {
            builder.setString("errorCode", errorCode);
        }

        return builder.build();
    }

    @Override
    public String toString() {
        return "CompletionInfo{" +
                "eventKey=" + eventKey +
                ", correlationId=" + correlationId +
                ", eventType='" + eventType + '\'' +
                ", status=" + status +
                ", processingTimeMs=" + getProcessingTimeMs() +
                (errorMessage != null ? ", error='" + errorMessage + '\'' : "") +
                '}';
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        CompletionInfo<?> that = (CompletionInfo<?>) o;
        return Objects.equals(eventKey, that.eventKey) &&
                Objects.equals(correlationId, that.correlationId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(eventKey, correlationId);
    }

    // Helper method

    private static String extractString(GenericRecord record, String field, String defaultValue) {
        try {
            String value = record.getString(field);
            return value != null ? value : defaultValue;
        } catch (Exception e) {
            return defaultValue;
        }
    }
}
