package com.theyawns.framework.saga;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.query.Predicates;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tags;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.stream.Collectors;

/**
 * Hazelcast-based implementation of {@link SagaStateStore}.
 *
 * <p>Stores saga state in a distributed IMap, enabling saga tracking
 * across multiple service instances. Uses GenericRecord serialization
 * for flexibility and cluster independence.
 *
 * <p>Metrics are collected via {@link SagaMetrics} when a {@link MeterRegistry}
 * is provided. Active/compensating saga gauges are registered directly against
 * the registry for live query support.
 *
 * <p>Map configuration recommendations:
 * <pre>{@code
 * hazelcast:
 *   map:
 *     saga-state:
 *       backup-count: 1
 *       indexes:
 *         - type: HASH
 *           attributes:
 *             - "status"
 *         - type: HASH
 *           attributes:
 *             - "correlationId"
 *         - type: HASH
 *           attributes:
 *             - "sagaType"
 *         - type: SORTED
 *           attributes:
 *             - "deadline"
 * }</pre>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
public class HazelcastSagaStateStore implements SagaStateStore {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastSagaStateStore.class);

    public static final String DEFAULT_MAP_NAME = "saga-state";

    private final HazelcastInstance hazelcast;
    private final IMap<String, GenericRecord> sagaMap;
    private final SagaMetrics sagaMetrics;
    private final MeterRegistry meterRegistry;
    private final String mapName;

    /**
     * Creates a new HazelcastSagaStateStore with default map name.
     *
     * @param hazelcast the Hazelcast instance
     * @param meterRegistry the metrics registry (may be null)
     */
    public HazelcastSagaStateStore(HazelcastInstance hazelcast, MeterRegistry meterRegistry) {
        this(hazelcast, meterRegistry, DEFAULT_MAP_NAME);
    }

    /**
     * Creates a new HazelcastSagaStateStore with custom map name.
     *
     * @param hazelcast the Hazelcast instance
     * @param meterRegistry the metrics registry (may be null)
     * @param mapName the name of the IMap to use
     */
    public HazelcastSagaStateStore(HazelcastInstance hazelcast, MeterRegistry meterRegistry,
                                    String mapName) {
        this.hazelcast = hazelcast;
        this.meterRegistry = meterRegistry;
        this.sagaMetrics = meterRegistry != null ? new SagaMetrics(meterRegistry) : null;
        this.mapName = mapName;
        this.sagaMap = hazelcast.getMap(mapName);

        registerLiveGauges();
        logger.info("Initialized HazelcastSagaStateStore with map: {}", mapName);
    }

    /**
     * Creates a new HazelcastSagaStateStore with an existing SagaMetrics instance.
     *
     * @param hazelcast the Hazelcast instance
     * @param sagaMetrics the saga metrics collector (may be null)
     * @param mapName the name of the IMap to use
     */
    public HazelcastSagaStateStore(HazelcastInstance hazelcast, SagaMetrics sagaMetrics,
                                    String mapName) {
        this.hazelcast = hazelcast;
        this.sagaMetrics = sagaMetrics;
        this.meterRegistry = sagaMetrics != null ? sagaMetrics.getMeterRegistry() : null;
        this.mapName = mapName;
        this.sagaMap = hazelcast.getMap(mapName);

        registerLiveGauges();
        logger.info("Initialized HazelcastSagaStateStore with map: {}", mapName);
    }

    private void registerLiveGauges() {
        if (meterRegistry == null) {
            return;
        }

        // Live gauges that query the map directly for current counts
        meterRegistry.gauge("sagas.active.count", Tags.empty(), this,
                store -> store.countByStatus(SagaStatus.IN_PROGRESS) +
                         store.countByStatus(SagaStatus.STARTED));

        meterRegistry.gauge("sagas.compensating.count", Tags.empty(), this,
                store -> store.countByStatus(SagaStatus.COMPENSATING));
    }

    // ========== Saga Lifecycle ==========

    @Override
    public SagaState startSaga(String sagaId, String sagaType, String correlationId,
                               int totalSteps, Duration timeout) {
        logger.debug("Starting saga: {} type: {} steps: {}", sagaId, sagaType, totalSteps);

        SagaState state = SagaState.start(sagaId, sagaType, correlationId, totalSteps, timeout);
        sagaMap.set(sagaId, state.toGenericRecord());

        if (sagaMetrics != null) {
            sagaMetrics.recordSagaStarted(sagaType);
        }

        logger.info("Saga started: {} type: {}", sagaId, sagaType);
        return state;
    }

    @Override
    public SagaState completeSaga(String sagaId, SagaStatus outcome) {
        logger.debug("Completing saga: {} with outcome: {}", sagaId, outcome);

        SagaState state = getRequiredSaga(sagaId);

        // Skip if already in a terminal state (idempotent for concurrent timeout detectors)
        if (state.getStatus().isTerminal()) {
            logger.debug("Saga {} already in terminal state: {}, skipping", sagaId, state.getStatus());
            return state;
        }

        SagaState completed = state.complete(outcome);
        sagaMap.set(sagaId, completed.toGenericRecord());

        // Update metrics
        if (sagaMetrics != null) {
            switch (outcome) {
                case COMPLETED -> sagaMetrics.recordSagaCompleted(state.getSagaType());
                case COMPENSATED -> sagaMetrics.recordSagaCompensated(state.getSagaType());
                case TIMED_OUT -> sagaMetrics.recordSagaTimedOut(state.getSagaType());
                case FAILED -> sagaMetrics.recordSagaFailed(state.getSagaType());
                default -> { }
            }
            sagaMetrics.recordSagaDuration(state.getSagaType(), completed.getDuration());
        }

        logger.info("Saga completed: {} outcome: {} duration: {}ms",
                sagaId, outcome, completed.getDuration().toMillis());
        return completed;
    }

    // ========== Step Tracking ==========

    @Override
    public SagaState recordStepCompleted(String sagaId, int stepNumber, String eventType,
                                          String service, String eventId) {
        logger.debug("Recording step completed: saga={} step={} event={}",
                sagaId, stepNumber, eventType);

        SagaState state = getRequiredSaga(sagaId);
        SagaState updated = state.recordStepCompleted(stepNumber, eventType, service, eventId);
        sagaMap.set(sagaId, updated.toGenericRecord());

        if (sagaMetrics != null) {
            sagaMetrics.recordStepCompleted(state.getSagaType());

            // Check if saga is now complete
            if (updated.getStatus() == SagaStatus.COMPLETED) {
                sagaMetrics.recordSagaCompleted(state.getSagaType());
                sagaMetrics.recordSagaDuration(state.getSagaType(), updated.getDuration());
                logger.info("Saga completed via final step: {}", sagaId);
            }
        } else if (updated.getStatus() == SagaStatus.COMPLETED) {
            logger.info("Saga completed via final step: {}", sagaId);
        }

        return updated;
    }

    @Override
    public SagaState recordStepFailed(String sagaId, int stepNumber, String eventType,
                                       String service, String reason) {
        logger.warn("Recording step failed: saga={} step={} reason={}",
                sagaId, stepNumber, reason);

        SagaState state = getRequiredSaga(sagaId);
        SagaState updated = state.recordStepFailed(stepNumber, eventType, service, reason);
        sagaMap.set(sagaId, updated.toGenericRecord());

        if (sagaMetrics != null) {
            sagaMetrics.recordStepFailed(state.getSagaType());
        }

        logger.info("Saga step failed, compensation started: saga={} step={}", sagaId, stepNumber);
        return updated;
    }

    // ========== Compensation ==========

    @Override
    public SagaState recordCompensationStarted(String sagaId) {
        logger.debug("Recording compensation started: {}", sagaId);

        SagaState state = getRequiredSaga(sagaId);
        SagaState updated = state.startCompensation();
        sagaMap.set(sagaId, updated.toGenericRecord());

        if (sagaMetrics != null) {
            sagaMetrics.recordCompensationStarted(state.getSagaType());
        }
        return updated;
    }

    @Override
    public SagaState recordCompensationStep(String sagaId, int stepNumber,
                                             String eventType, String service) {
        logger.debug("Recording compensation step: saga={} step={} event={}",
                sagaId, stepNumber, eventType);

        SagaState state = getRequiredSaga(sagaId);
        SagaState updated = state.recordCompensationStep(stepNumber, eventType, service);
        sagaMap.set(sagaId, updated.toGenericRecord());

        if (sagaMetrics != null) {
            sagaMetrics.recordCompensationStep(state.getSagaType());
        }
        return updated;
    }

    // ========== Queries ==========

    @Override
    public Optional<SagaState> getSagaState(String sagaId) {
        GenericRecord record = sagaMap.get(sagaId);
        if (record == null) {
            return Optional.empty();
        }
        return Optional.of(SagaState.fromGenericRecord(record));
    }

    @Override
    public List<SagaState> findTimedOutSagas() {
        Instant now = Instant.now();

        // Find active sagas past deadline
        Collection<GenericRecord> records = sagaMap.values(
                Predicates.and(
                        Predicates.or(
                                Predicates.equal("status", SagaStatus.STARTED.name()),
                                Predicates.equal("status", SagaStatus.IN_PROGRESS.name())
                        ),
                        Predicates.lessThan("deadline", now.toEpochMilli())
                )
        );

        return records.stream()
                .map(SagaState::fromGenericRecord)
                .filter(SagaState::isTimedOut)  // Double-check
                .collect(Collectors.toList());
    }

    @Override
    public List<SagaState> findSagasByStatus(SagaStatus status) {
        Collection<GenericRecord> records = sagaMap.values(
                Predicates.equal("status", status.name())
        );

        return records.stream()
                .map(SagaState::fromGenericRecord)
                .collect(Collectors.toList());
    }

    @Override
    public List<SagaState> findSagasByCorrelationId(String correlationId) {
        Collection<GenericRecord> records = sagaMap.values(
                Predicates.equal("correlationId", correlationId)
        );

        return records.stream()
                .map(SagaState::fromGenericRecord)
                .collect(Collectors.toList());
    }

    @Override
    public List<SagaState> findSagasByType(String sagaType) {
        Collection<GenericRecord> records = sagaMap.values(
                Predicates.equal("sagaType", sagaType)
        );

        return records.stream()
                .map(SagaState::fromGenericRecord)
                .collect(Collectors.toList());
    }

    // ========== Metrics ==========

    @Override
    public long countByStatus(SagaStatus status) {
        return sagaMap.values(Predicates.equal("status", status.name())).size();
    }

    @Override
    public long count() {
        return sagaMap.size();
    }

    @Override
    public List<SagaState> findActiveSagas() {
        Collection<GenericRecord> records = sagaMap.values(
                Predicates.or(
                        Predicates.equal("status", SagaStatus.STARTED.name()),
                        Predicates.equal("status", SagaStatus.IN_PROGRESS.name()),
                        Predicates.equal("status", SagaStatus.COMPENSATING.name())
                )
        );

        return records.stream()
                .map(SagaState::fromGenericRecord)
                .collect(Collectors.toList());
    }

    // ========== Maintenance ==========

    @Override
    public int purgeCompletedSagas(Duration olderThan) {
        Instant cutoff = Instant.now().minus(olderThan);
        long cutoffMillis = cutoff.toEpochMilli();

        // Find completed sagas older than or equal to cutoff
        Collection<String> toRemove = sagaMap.keySet(
                Predicates.and(
                        Predicates.or(
                                Predicates.equal("status", SagaStatus.COMPLETED.name()),
                                Predicates.equal("status", SagaStatus.COMPENSATED.name()),
                                Predicates.equal("status", SagaStatus.FAILED.name()),
                                Predicates.equal("status", SagaStatus.TIMED_OUT.name())
                        ),
                        Predicates.lessEqual("completedAt", cutoffMillis)
                )
        );

        int count = 0;
        for (String sagaId : toRemove) {
            sagaMap.remove(sagaId);
            count++;
        }

        if (count > 0) {
            logger.info("Purged {} completed sagas older than {}", count, cutoff);
        }
        return count;
    }

    // ========== Helper Methods ==========

    private SagaState getRequiredSaga(String sagaId) {
        return getSagaState(sagaId)
                .orElseThrow(() -> new IllegalArgumentException("Saga not found: " + sagaId));
    }

    /**
     * Returns the underlying Hazelcast map.
     * Useful for advanced queries or testing.
     *
     * @return the saga state map
     */
    public IMap<String, GenericRecord> getSagaMap() {
        return sagaMap;
    }

    /**
     * Returns the map name.
     *
     * @return the map name
     */
    public String getMapName() {
        return mapName;
    }

    /**
     * Returns the SagaMetrics instance, if available.
     *
     * @return the saga metrics, or null if no meter registry was provided
     */
    public SagaMetrics getSagaMetrics() {
        return sagaMetrics;
    }
}
