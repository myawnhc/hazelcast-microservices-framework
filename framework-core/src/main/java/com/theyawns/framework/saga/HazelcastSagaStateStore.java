package com.theyawns.framework.saga;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.query.Predicates;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Tags;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.Instant;
import java.util.Collection;
import java.util.List;
import java.util.Optional;
import java.util.concurrent.atomic.AtomicLong;
import java.util.stream.Collectors;

/**
 * Hazelcast-based implementation of {@link SagaStateStore}.
 *
 * <p>Stores saga state in a distributed IMap, enabling saga tracking
 * across multiple service instances. Uses GenericRecord serialization
 * for flexibility and cluster independence.
 *
 * <p>Map configuration recommendations:
 * <pre>{@code
 * hazelcast:
 *   map:
 *     saga-state:
 *       backup-count: 1
 *       indexes:
 *         - type: HASH
 *           attributes:
 *             - "status"
 *         - type: HASH
 *           attributes:
 *             - "correlationId"
 *         - type: HASH
 *           attributes:
 *             - "sagaType"
 *         - type: SORTED
 *           attributes:
 *             - "deadline"
 * }</pre>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
public class HazelcastSagaStateStore implements SagaStateStore {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastSagaStateStore.class);

    public static final String DEFAULT_MAP_NAME = "saga-state";

    private final HazelcastInstance hazelcast;
    private final IMap<String, GenericRecord> sagaMap;
    private final MeterRegistry meterRegistry;
    private final String mapName;

    // Metrics counters
    private final AtomicLong sagasStarted = new AtomicLong(0);
    private final AtomicLong sagasCompleted = new AtomicLong(0);
    private final AtomicLong sagasCompensated = new AtomicLong(0);
    private final AtomicLong sagasFailed = new AtomicLong(0);

    /**
     * Creates a new HazelcastSagaStateStore with default map name.
     *
     * @param hazelcast the Hazelcast instance
     * @param meterRegistry the metrics registry (may be null)
     */
    public HazelcastSagaStateStore(HazelcastInstance hazelcast, MeterRegistry meterRegistry) {
        this(hazelcast, meterRegistry, DEFAULT_MAP_NAME);
    }

    /**
     * Creates a new HazelcastSagaStateStore with custom map name.
     *
     * @param hazelcast the Hazelcast instance
     * @param meterRegistry the metrics registry (may be null)
     * @param mapName the name of the IMap to use
     */
    public HazelcastSagaStateStore(HazelcastInstance hazelcast, MeterRegistry meterRegistry,
                                    String mapName) {
        this.hazelcast = hazelcast;
        this.meterRegistry = meterRegistry;
        this.mapName = mapName;
        this.sagaMap = hazelcast.getMap(mapName);

        registerMetrics();
        logger.info("Initialized HazelcastSagaStateStore with map: {}", mapName);
    }

    private void registerMetrics() {
        if (meterRegistry == null) return;

        meterRegistry.gauge("sagas.started.total", sagasStarted);
        meterRegistry.gauge("sagas.completed.total", sagasCompleted);
        meterRegistry.gauge("sagas.compensated.total", sagasCompensated);
        meterRegistry.gauge("sagas.failed.total", sagasFailed);

        meterRegistry.gauge("sagas.active.count", Tags.empty(), this,
                store -> store.countByStatus(SagaStatus.IN_PROGRESS) +
                         store.countByStatus(SagaStatus.STARTED));

        meterRegistry.gauge("sagas.compensating.count", Tags.empty(), this,
                store -> store.countByStatus(SagaStatus.COMPENSATING));
    }

    // ========== Saga Lifecycle ==========

    @Override
    public SagaState startSaga(String sagaId, String sagaType, String correlationId,
                               int totalSteps, Duration timeout) {
        logger.debug("Starting saga: {} type: {} steps: {}", sagaId, sagaType, totalSteps);

        SagaState state = SagaState.start(sagaId, sagaType, correlationId, totalSteps, timeout);
        sagaMap.set(sagaId, state.toGenericRecord());

        sagasStarted.incrementAndGet();
        recordMetric("sagas.started", sagaType);

        logger.info("Saga started: {} type: {}", sagaId, sagaType);
        return state;
    }

    @Override
    public SagaState completeSaga(String sagaId, SagaStatus outcome) {
        logger.debug("Completing saga: {} with outcome: {}", sagaId, outcome);

        SagaState state = getRequiredSaga(sagaId);
        SagaState completed = state.complete(outcome);
        sagaMap.set(sagaId, completed.toGenericRecord());

        // Update metrics
        switch (outcome) {
            case COMPLETED -> {
                sagasCompleted.incrementAndGet();
                recordMetric("sagas.completed", state.getSagaType());
            }
            case COMPENSATED -> {
                sagasCompensated.incrementAndGet();
                recordMetric("sagas.compensated", state.getSagaType());
            }
            case FAILED, TIMED_OUT -> {
                sagasFailed.incrementAndGet();
                recordMetric("sagas.failed", state.getSagaType());
            }
            default -> { }
        }

        // Record duration
        recordDuration(state.getSagaType(), completed.getDuration());

        logger.info("Saga completed: {} outcome: {} duration: {}ms",
                sagaId, outcome, completed.getDuration().toMillis());
        return completed;
    }

    // ========== Step Tracking ==========

    @Override
    public SagaState recordStepCompleted(String sagaId, int stepNumber, String eventType,
                                          String service, String eventId) {
        logger.debug("Recording step completed: saga={} step={} event={}",
                sagaId, stepNumber, eventType);

        SagaState state = getRequiredSaga(sagaId);
        SagaState updated = state.recordStepCompleted(stepNumber, eventType, service, eventId);
        sagaMap.set(sagaId, updated.toGenericRecord());

        recordMetric("saga.steps.completed", state.getSagaType());

        // Check if saga is now complete
        if (updated.getStatus() == SagaStatus.COMPLETED) {
            sagasCompleted.incrementAndGet();
            recordMetric("sagas.completed", state.getSagaType());
            recordDuration(state.getSagaType(), updated.getDuration());
            logger.info("Saga completed via final step: {}", sagaId);
        }

        return updated;
    }

    @Override
    public SagaState recordStepFailed(String sagaId, int stepNumber, String eventType,
                                       String service, String reason) {
        logger.warn("Recording step failed: saga={} step={} reason={}",
                sagaId, stepNumber, reason);

        SagaState state = getRequiredSaga(sagaId);
        SagaState updated = state.recordStepFailed(stepNumber, eventType, service, reason);
        sagaMap.set(sagaId, updated.toGenericRecord());

        recordMetric("saga.steps.failed", state.getSagaType());

        logger.info("Saga step failed, compensation started: saga={} step={}", sagaId, stepNumber);
        return updated;
    }

    // ========== Compensation ==========

    @Override
    public SagaState recordCompensationStarted(String sagaId) {
        logger.debug("Recording compensation started: {}", sagaId);

        SagaState state = getRequiredSaga(sagaId);
        SagaState updated = state.startCompensation();
        sagaMap.set(sagaId, updated.toGenericRecord());

        recordMetric("sagas.compensation.started", state.getSagaType());
        return updated;
    }

    @Override
    public SagaState recordCompensationStep(String sagaId, int stepNumber,
                                             String eventType, String service) {
        logger.debug("Recording compensation step: saga={} step={} event={}",
                sagaId, stepNumber, eventType);

        SagaState state = getRequiredSaga(sagaId);
        SagaState updated = state.recordCompensationStep(stepNumber, eventType, service);
        sagaMap.set(sagaId, updated.toGenericRecord());

        recordMetric("saga.compensation.steps.completed", state.getSagaType());
        return updated;
    }

    // ========== Queries ==========

    @Override
    public Optional<SagaState> getSagaState(String sagaId) {
        GenericRecord record = sagaMap.get(sagaId);
        if (record == null) {
            return Optional.empty();
        }
        return Optional.of(SagaState.fromGenericRecord(record));
    }

    @Override
    public List<SagaState> findTimedOutSagas() {
        Instant now = Instant.now();

        // Find active sagas past deadline
        Collection<GenericRecord> records = sagaMap.values(
                Predicates.and(
                        Predicates.or(
                                Predicates.equal("status", SagaStatus.STARTED.name()),
                                Predicates.equal("status", SagaStatus.IN_PROGRESS.name())
                        ),
                        Predicates.lessThan("deadline", now.toEpochMilli())
                )
        );

        return records.stream()
                .map(SagaState::fromGenericRecord)
                .filter(SagaState::isTimedOut)  // Double-check
                .collect(Collectors.toList());
    }

    @Override
    public List<SagaState> findSagasByStatus(SagaStatus status) {
        Collection<GenericRecord> records = sagaMap.values(
                Predicates.equal("status", status.name())
        );

        return records.stream()
                .map(SagaState::fromGenericRecord)
                .collect(Collectors.toList());
    }

    @Override
    public List<SagaState> findSagasByCorrelationId(String correlationId) {
        Collection<GenericRecord> records = sagaMap.values(
                Predicates.equal("correlationId", correlationId)
        );

        return records.stream()
                .map(SagaState::fromGenericRecord)
                .collect(Collectors.toList());
    }

    @Override
    public List<SagaState> findSagasByType(String sagaType) {
        Collection<GenericRecord> records = sagaMap.values(
                Predicates.equal("sagaType", sagaType)
        );

        return records.stream()
                .map(SagaState::fromGenericRecord)
                .collect(Collectors.toList());
    }

    // ========== Metrics ==========

    @Override
    public long countByStatus(SagaStatus status) {
        return sagaMap.values(Predicates.equal("status", status.name())).size();
    }

    @Override
    public long count() {
        return sagaMap.size();
    }

    // ========== Maintenance ==========

    @Override
    public int purgeCompletedSagas(Duration olderThan) {
        Instant cutoff = Instant.now().minus(olderThan);
        long cutoffMillis = cutoff.toEpochMilli();

        // Find completed sagas older than or equal to cutoff
        Collection<String> toRemove = sagaMap.keySet(
                Predicates.and(
                        Predicates.or(
                                Predicates.equal("status", SagaStatus.COMPLETED.name()),
                                Predicates.equal("status", SagaStatus.COMPENSATED.name()),
                                Predicates.equal("status", SagaStatus.FAILED.name()),
                                Predicates.equal("status", SagaStatus.TIMED_OUT.name())
                        ),
                        Predicates.lessEqual("completedAt", cutoffMillis)
                )
        );

        int count = 0;
        for (String sagaId : toRemove) {
            sagaMap.remove(sagaId);
            count++;
        }

        if (count > 0) {
            logger.info("Purged {} completed sagas older than {}", count, cutoff);
        }
        return count;
    }

    // ========== Helper Methods ==========

    private SagaState getRequiredSaga(String sagaId) {
        return getSagaState(sagaId)
                .orElseThrow(() -> new IllegalArgumentException("Saga not found: " + sagaId));
    }

    private void recordMetric(String name, String sagaType) {
        if (meterRegistry != null) {
            meterRegistry.counter(name, "sagaType", sagaType).increment();
        }
    }

    private void recordDuration(String sagaType, Duration duration) {
        if (meterRegistry != null) {
            meterRegistry.timer("saga.duration", "sagaType", sagaType)
                    .record(duration);
        }
    }

    /**
     * Returns the underlying Hazelcast map.
     * Useful for advanced queries or testing.
     *
     * @return the saga state map
     */
    public IMap<String, GenericRecord> getSagaMap() {
        return sagaMap;
    }

    /**
     * Returns the map name.
     *
     * @return the map name
     */
    public String getMapName() {
        return mapName;
    }
}
