package com.theyawns.framework.saga.orchestrator;

import java.time.Duration;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;

/**
 * Immutable definition of an orchestrated saga as an ordered sequence of {@link SagaStep}s.
 *
 * <p>Use the fluent builder DSL to define a saga:
 * <pre>{@code
 * SagaDefinition saga = SagaDefinition.builder()
 *     .name("OrderFulfillment")
 *     .step("ReserveStock")
 *         .action(ctx -> inventoryService.reserve(ctx))
 *         .compensation(ctx -> inventoryService.release(ctx))
 *         .timeout(Duration.ofSeconds(10))
 *         .build()
 *     .step("ProcessPayment")
 *         .action(ctx -> paymentService.charge(ctx))
 *         .compensation(ctx -> paymentService.refund(ctx))
 *         .timeout(Duration.ofSeconds(30))
 *         .build()
 *     .step("ConfirmOrder")
 *         .action(ctx -> orderService.confirm(ctx))
 *         .noCompensation()
 *         .build()
 *     .sagaTimeout(Duration.ofMinutes(2))
 *     .build();
 * }</pre>
 *
 * <p>Pre-built {@link SagaStep} instances can also be added via {@link Builder#addStep(SagaStep)}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see SagaStep
 * @see SagaOrchestrator
 */
public final class SagaDefinition {

    /**
     * The name of this saga definition.
     */
    private final String name;

    /**
     * The ordered list of steps (unmodifiable).
     */
    private final List<SagaStep> steps;

    /**
     * Optional overall saga timeout.
     */
    private final Duration sagaTimeout;

    /**
     * Private constructor; use {@link #builder()}.
     */
    private SagaDefinition(final String name, final List<SagaStep> steps, final Duration sagaTimeout) {
        this.name = name;
        this.steps = Collections.unmodifiableList(new ArrayList<>(steps));
        this.sagaTimeout = sagaTimeout;
    }

    /**
     * Creates a new saga definition builder.
     *
     * @return a new builder
     */
    public static Builder builder() {
        return new Builder();
    }

    /**
     * Returns the saga name.
     *
     * @return the name
     */
    public String getName() {
        return name;
    }

    /**
     * Returns the ordered list of steps (unmodifiable).
     *
     * @return the steps
     */
    public List<SagaStep> getSteps() {
        return steps;
    }

    /**
     * Returns a step by index.
     *
     * @param index the zero-based step index
     * @return the step at the given index
     * @throws IndexOutOfBoundsException if index is out of range
     */
    public SagaStep getStep(final int index) {
        return steps.get(index);
    }

    /**
     * Returns a step by name.
     *
     * @param stepName the step name (must not be null)
     * @return optional containing the step, or empty if not found
     * @throws NullPointerException if stepName is null
     */
    public Optional<SagaStep> getStep(final String stepName) {
        Objects.requireNonNull(stepName, "stepName must not be null");
        return steps.stream()
                .filter(s -> s.getName().equals(stepName))
                .findFirst();
    }

    /**
     * Returns the number of steps.
     *
     * @return the step count
     */
    public int getStepCount() {
        return steps.size();
    }

    /**
     * Returns the overall saga timeout, if set.
     *
     * @return optional saga timeout
     */
    public Optional<Duration> getSagaTimeout() {
        return Optional.ofNullable(sagaTimeout);
    }

    /**
     * Computes the total timeout as the sum of all step timeouts.
     *
     * <p>This is useful as a fallback when no explicit saga-level timeout is set.
     *
     * @return the sum of all step timeouts
     */
    public Duration computeTotalStepTimeout() {
        return steps.stream()
                .map(SagaStep::getTimeout)
                .reduce(Duration.ZERO, Duration::plus);
    }

    @Override
    public String toString() {
        return "SagaDefinition{name='" + name + "', steps=" + steps.size()
                + ", sagaTimeout=" + sagaTimeout + "}";
    }

    /**
     * Builder for creating {@link SagaDefinition} instances.
     *
     * <p>Supports two modes of adding steps:
     * <ol>
     *   <li>Fluent DSL via {@link #step(String)} returning a {@link StepBuilder}</li>
     *   <li>Direct addition via {@link #addStep(SagaStep)}</li>
     * </ol>
     */
    public static final class Builder {

        private String name;
        private final List<SagaStep> steps = new ArrayList<>();
        private Duration sagaTimeout;

        private Builder() {
        }

        /**
         * Sets the saga name.
         *
         * @param name the saga name (must not be null or blank)
         * @return this builder
         * @throws NullPointerException if name is null
         * @throws IllegalArgumentException if name is blank
         */
        public Builder name(final String name) {
            Objects.requireNonNull(name, "name must not be null");
            if (name.isBlank()) {
                throw new IllegalArgumentException("name must not be blank");
            }
            this.name = name;
            return this;
        }

        /**
         * Starts building a new step with the fluent DSL.
         *
         * <p>Returns a {@link StepBuilder} that chains back to this builder when
         * its {@link StepBuilder#build()} is called.
         *
         * @param stepName the step name (must not be null or blank)
         * @return a step builder
         * @throws NullPointerException if stepName is null
         * @throws IllegalArgumentException if stepName is blank
         */
        public StepBuilder step(final String stepName) {
            Objects.requireNonNull(stepName, "stepName must not be null");
            if (stepName.isBlank()) {
                throw new IllegalArgumentException("stepName must not be blank");
            }
            return new StepBuilder(this, stepName);
        }

        /**
         * Adds a pre-built step to the saga.
         *
         * @param step the step to add (must not be null)
         * @return this builder
         * @throws NullPointerException if step is null
         */
        public Builder addStep(final SagaStep step) {
            Objects.requireNonNull(step, "step must not be null");
            this.steps.add(step);
            return this;
        }

        /**
         * Sets the overall saga timeout.
         *
         * @param sagaTimeout the timeout (must not be null, must be positive)
         * @return this builder
         * @throws NullPointerException if sagaTimeout is null
         * @throws IllegalArgumentException if sagaTimeout is zero or negative
         */
        public Builder sagaTimeout(final Duration sagaTimeout) {
            Objects.requireNonNull(sagaTimeout, "sagaTimeout must not be null");
            if (sagaTimeout.isZero() || sagaTimeout.isNegative()) {
                throw new IllegalArgumentException("sagaTimeout must be positive");
            }
            this.sagaTimeout = sagaTimeout;
            return this;
        }

        /**
         * Builds the immutable {@link SagaDefinition}.
         *
         * @return the saga definition
         * @throws IllegalStateException if name is not set, no steps were added,
         *         or duplicate step names exist
         */
        public SagaDefinition build() {
            if (name == null || name.isBlank()) {
                throw new IllegalStateException("name must be set");
            }
            if (steps.isEmpty()) {
                throw new IllegalStateException("at least one step is required");
            }
            validateNoDuplicateStepNames();
            return new SagaDefinition(name, steps, sagaTimeout);
        }

        /**
         * Called by StepBuilder to add a completed step back to this builder.
         */
        Builder addBuiltStep(final SagaStep step) {
            this.steps.add(step);
            return this;
        }

        private void validateNoDuplicateStepNames() {
            final Set<String> names = new HashSet<>();
            for (final SagaStep step : steps) {
                if (!names.add(step.getName())) {
                    throw new IllegalStateException("Duplicate step name: " + step.getName());
                }
            }
        }
    }

    /**
     * Nested builder for defining a step within the fluent DSL.
     *
     * <p>When {@link #build()} is called, the step is added to the parent
     * {@link Builder} and control returns to it.
     */
    public static final class StepBuilder {

        private final Builder parent;
        private final SagaStep.Builder stepBuilder;

        private StepBuilder(final Builder parent, final String stepName) {
            this.parent = parent;
            this.stepBuilder = SagaStep.builder(stepName);
        }

        /**
         * Sets the forward action.
         *
         * @param action the action
         * @return this step builder
         */
        public StepBuilder action(final SagaAction action) {
            stepBuilder.action(action);
            return this;
        }

        /**
         * Sets the compensation action.
         *
         * @param compensation the compensation action
         * @return this step builder
         */
        public StepBuilder compensation(final SagaCompensation compensation) {
            stepBuilder.compensation(compensation);
            return this;
        }

        /**
         * Marks this step as having no compensation.
         *
         * @return this step builder
         */
        public StepBuilder noCompensation() {
            stepBuilder.noCompensation();
            return this;
        }

        /**
         * Sets the step timeout.
         *
         * @param timeout the timeout
         * @return this step builder
         */
        public StepBuilder timeout(final Duration timeout) {
            stepBuilder.timeout(timeout);
            return this;
        }

        /**
         * Sets the max retry count.
         *
         * @param maxRetries the max retries
         * @return this step builder
         */
        public StepBuilder maxRetries(final int maxRetries) {
            stepBuilder.maxRetries(maxRetries);
            return this;
        }

        /**
         * Sets the retry delay.
         *
         * @param retryDelay the delay between retries
         * @return this step builder
         */
        public StepBuilder retryDelay(final Duration retryDelay) {
            stepBuilder.retryDelay(retryDelay);
            return this;
        }

        /**
         * Builds the step and adds it to the parent saga definition builder.
         *
         * @return the parent builder for continued chaining
         */
        public Builder build() {
            return parent.addBuiltStep(stepBuilder.build());
        }
    }
}
