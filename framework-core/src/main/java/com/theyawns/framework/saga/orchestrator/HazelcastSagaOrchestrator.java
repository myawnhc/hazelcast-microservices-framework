package com.theyawns.framework.saga.orchestrator;

import com.theyawns.framework.saga.SagaMetrics;
import com.theyawns.framework.saga.SagaStateStore;
import com.theyawns.framework.saga.SagaStatus;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Duration;
import java.time.Instant;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.CompletionException;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executors;
import java.util.concurrent.ScheduledExecutorService;
import java.util.concurrent.ScheduledFuture;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.TimeoutException;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.function.Consumer;

/**
 * Hazelcast-backed implementation of {@link SagaOrchestrator}.
 *
 * <p>Executes saga steps sequentially as defined by a {@link SagaDefinition}, handles
 * failures with reverse-order compensation, enforces per-step and saga-level timeouts,
 * and persists state via a {@link SagaStateStore}.
 *
 * <p>Key behaviors:
 * <ul>
 *   <li><strong>Forward execution</strong>: Steps run in order; each step's result data
 *       is merged into the {@link SagaContext} for downstream steps</li>
 *   <li><strong>Compensation</strong>: On failure, completed steps are compensated in
 *       reverse order; steps without compensation are skipped</li>
 *   <li><strong>Retry</strong>: Failed steps (not timeouts) are retried up to
 *       {@link SagaStep#getMaxRetries()} times with configurable delay</li>
 *   <li><strong>Timeout</strong>: Per-step timeout via {@code orTimeout}; saga-level
 *       timeout via scheduled task</li>
 *   <li><strong>External completion</strong>: {@link #handleStepResult} allows async
 *       step completion from external sources (e.g., message listeners)</li>
 * </ul>
 *
 * <p>Example:
 * <pre>{@code
 * SagaOrchestrator orchestrator = new HazelcastSagaOrchestrator(stateStore, listeners, null);
 *
 * SagaDefinition definition = SagaDefinition.builder()
 *     .name("OrderFulfillment")
 *     .step("ReserveStock").action(...).compensation(...).build()
 *     .step("ProcessPayment").action(...).compensation(...).build()
 *     .step("ConfirmOrder").action(...).noCompensation().build()
 *     .sagaTimeout(Duration.ofMinutes(2))
 *     .build();
 *
 * SagaContext context = SagaContext.of(Map.of("orderId", "order-123"));
 *
 * orchestrator.start("saga-1", definition, context)
 *     .thenAccept(result -> log.info("Saga completed: {}", result));
 * }</pre>
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see SagaOrchestrator
 * @see SagaDefinition
 * @see SagaStateStore
 */
public class HazelcastSagaOrchestrator implements SagaOrchestrator {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastSagaOrchestrator.class);

    /**
     * State store for persisting saga state.
     */
    private final SagaStateStore stateStore;

    /**
     * Lifecycle listeners notified of saga events.
     */
    private final List<SagaOrchestratorListener> listeners;

    /**
     * Scheduler for timeouts and retry delays.
     */
    private final ScheduledExecutorService scheduler;

    /**
     * Optional metrics collector for per-step timing.
     */
    private final SagaMetrics sagaMetrics;

    /**
     * Tracks in-flight saga executions by saga ID.
     */
    private final ConcurrentHashMap<String, SagaExecution> activeExecutions = new ConcurrentHashMap<>();

    /**
     * Creates a new orchestrator without metrics.
     *
     * @param stateStore the state store for persisting saga state (must not be null)
     * @param listeners lifecycle listeners (may be null or empty)
     * @param scheduler scheduler for timeouts and retry delays (null creates a default)
     * @throws NullPointerException if stateStore is null
     */
    public HazelcastSagaOrchestrator(final SagaStateStore stateStore,
                                      final List<SagaOrchestratorListener> listeners,
                                      final ScheduledExecutorService scheduler) {
        this(stateStore, listeners, scheduler, null);
    }

    /**
     * Creates a new orchestrator with optional metrics.
     *
     * @param stateStore the state store for persisting saga state (must not be null)
     * @param listeners lifecycle listeners (may be null or empty)
     * @param scheduler scheduler for timeouts and retry delays (null creates a default)
     * @param sagaMetrics optional metrics collector (may be null)
     * @throws NullPointerException if stateStore is null
     */
    public HazelcastSagaOrchestrator(final SagaStateStore stateStore,
                                      final List<SagaOrchestratorListener> listeners,
                                      final ScheduledExecutorService scheduler,
                                      final SagaMetrics sagaMetrics) {
        this.stateStore = Objects.requireNonNull(stateStore, "stateStore must not be null");
        this.listeners = listeners != null ? new ArrayList<>(listeners) : Collections.emptyList();
        this.scheduler = scheduler != null ? scheduler : Executors.newScheduledThreadPool(2);
        this.sagaMetrics = sagaMetrics;
    }

    @Override
    public CompletableFuture<SagaOrchestratorResult> start(final String sagaId,
                                                            final SagaDefinition definition,
                                                            final SagaContext context) {
        Objects.requireNonNull(sagaId, "sagaId must not be null");
        Objects.requireNonNull(definition, "definition must not be null");
        Objects.requireNonNull(context, "context must not be null");

        if (activeExecutions.containsKey(sagaId)) {
            throw new IllegalArgumentException("Saga already active: " + sagaId);
        }

        final SagaExecution exec = new SagaExecution(sagaId, definition, context);
        activeExecutions.put(sagaId, exec);

        final Duration effectiveTimeout = definition.getSagaTimeout()
                .orElse(definition.computeTotalStepTimeout());

        stateStore.startSaga(sagaId, definition.getName(), definition.getStepCount(), effectiveTimeout);

        notifyListeners(l -> l.onSagaStarted(sagaId, definition, context));
        logger.info("Saga started: sagaId={}, name={}, steps={}", sagaId, definition.getName(),
                definition.getStepCount());

        // Schedule saga-level timeout
        exec.timeoutFuture = scheduler.schedule(() -> {
            if (!exec.resultFuture.isDone()) {
                logger.warn("Saga timed out: sagaId={}", sagaId);
                compensate(exec, exec.currentStepName, "Saga timed out", true);
            }
        }, effectiveTimeout.toMillis(), TimeUnit.MILLISECONDS);

        // Start step execution
        executeStep(exec, 0);

        return exec.resultFuture;
    }

    @Override
    public void handleStepResult(final String sagaId, final String stepName, final SagaStepResult result) {
        Objects.requireNonNull(sagaId, "sagaId must not be null");
        Objects.requireNonNull(stepName, "stepName must not be null");
        Objects.requireNonNull(result, "result must not be null");

        final SagaExecution exec = activeExecutions.get(sagaId);
        if (exec == null) {
            throw new IllegalArgumentException("Saga not found: " + sagaId);
        }
        if (!stepName.equals(exec.currentStepName)) {
            throw new IllegalArgumentException("Step name mismatch: expected '"
                    + exec.currentStepName + "' but got '" + stepName + "'");
        }
        if (exec.pendingStepFuture == null) {
            throw new IllegalArgumentException("No pending step for saga: " + sagaId);
        }

        logger.debug("External step result received: sagaId={}, step={}, status={}",
                sagaId, stepName, result.getStatus());
        exec.pendingStepFuture.complete(result);
    }

    @Override
    public Optional<SagaOrchestratorResult> getStatus(final String sagaId) {
        Objects.requireNonNull(sagaId, "sagaId must not be null");

        final SagaExecution exec = activeExecutions.get(sagaId);
        if (exec != null) {
            if (exec.resultFuture.isDone()) {
                try {
                    return Optional.of(exec.resultFuture.get());
                } catch (final InterruptedException e) {
                    Thread.currentThread().interrupt();
                    return Optional.empty();
                } catch (final ExecutionException e) {
                    return Optional.empty();
                }
            }
            // Active saga — return in-progress status
            return Optional.of(SagaOrchestratorResult.inProgress(
                    exec.sagaId, exec.definition.getName(), exec.startedAt,
                    exec.completedStepNames.size()));
        }

        // Check state store for completed sagas
        return stateStore.getSagaState(sagaId)
                .flatMap(this::mapStateToResult);
    }

    @Override
    public CompletableFuture<SagaOrchestratorResult> cancel(final String sagaId, final String reason) {
        Objects.requireNonNull(sagaId, "sagaId must not be null");
        Objects.requireNonNull(reason, "reason must not be null");

        final SagaExecution exec = activeExecutions.get(sagaId);
        if (exec == null) {
            throw new IllegalArgumentException("Saga not found: " + sagaId);
        }
        if (exec.resultFuture.isDone()) {
            throw new IllegalArgumentException("Saga already completed: " + sagaId);
        }

        logger.info("Cancelling saga: sagaId={}, reason={}", sagaId, reason);
        compensate(exec, exec.currentStepName, reason, false);
        return exec.resultFuture;
    }

    // ========== Internal Step Execution ==========

    /**
     * Executes the step at the given index, or completes the saga if all steps are done.
     *
     * @param exec the saga execution context
     * @param stepIndex the zero-based step index to execute
     */
    private void executeStep(final SagaExecution exec, final int stepIndex) {
        if (exec.compensating.get() || exec.resultFuture.isDone()) {
            return;
        }

        final int stepCount = exec.definition.getStepCount();

        // All steps completed — success
        if (stepIndex >= stepCount) {
            completeSuccess(exec);
            return;
        }

        final SagaStep step = exec.definition.getStep(stepIndex);
        exec.currentStepIndex = stepIndex;
        exec.currentStepName = step.getName();
        exec.stepStartedAt = Instant.now();

        notifyListeners(l -> l.onStepStarted(exec.sagaId, step.getName(), stepIndex));
        logger.debug("Executing step: sagaId={}, step={}, index={}", exec.sagaId, step.getName(), stepIndex);

        final CompletableFuture<SagaStepResult> stepFuture = executeWithRetry(exec, step, 0);
        exec.pendingStepFuture = stepFuture;

        stepFuture.whenComplete((result, ex) -> {
            if (exec.compensating.get() || exec.resultFuture.isDone()) {
                return;
            }

            if (ex != null) {
                final SagaStepResult failResult = SagaStepResult.failure(
                        ex.getMessage() != null ? ex.getMessage() : "Unknown error");
                handleStepFailure(exec, step, stepIndex, failResult);
                return;
            }

            if (result.isSuccess()) {
                handleStepSuccessInternal(exec, step, stepIndex, result);
            } else if (result.isTimeout()) {
                handleStepTimeout(exec, step, stepIndex, result);
            } else {
                handleStepFailure(exec, step, stepIndex, result);
            }
        });
    }

    /**
     * Executes a step action with retry support.
     *
     * <p>Retries are attempted only on FAILURE results (not timeouts). Each retry
     * is delayed by {@link SagaStep#getRetryDelay()} using the scheduler.
     *
     * @param exec the saga execution context
     * @param step the step to execute
     * @param attempt the current attempt number (0-based)
     * @return a future resolving to the step result
     */
    private CompletableFuture<SagaStepResult> executeWithRetry(final SagaExecution exec,
                                                                 final SagaStep step,
                                                                 final int attempt) {
        return step.getAction().execute(exec.context)
                .orTimeout(step.getTimeout().toMillis(), TimeUnit.MILLISECONDS)
                .exceptionally(ex -> {
                    final Throwable cause = ex instanceof CompletionException ? ex.getCause() : ex;
                    if (cause instanceof TimeoutException) {
                        return SagaStepResult.timeout(
                                "Step '" + step.getName() + "' timed out after " + step.getTimeout());
                    }
                    final String message = cause != null ? cause.getMessage() : ex.getMessage();
                    return SagaStepResult.failure(message != null ? message : "Unknown error");
                })
                .thenCompose(result -> {
                    if (result.isSuccess() || result.isTimeout()) {
                        return CompletableFuture.completedFuture(result);
                    }
                    // FAILURE: retry if attempts remain
                    if (attempt < step.getMaxRetries()) {
                        logger.debug("Retrying step: sagaId={}, step={}, attempt={}/{}",
                                exec.sagaId, step.getName(), attempt + 1, step.getMaxRetries());
                        final CompletableFuture<SagaStepResult> delayedRetry = new CompletableFuture<>();
                        scheduler.schedule(() -> {
                            executeWithRetry(exec, step, attempt + 1)
                                    .whenComplete((r, ex) -> {
                                        if (ex != null) {
                                            delayedRetry.completeExceptionally(ex);
                                        } else {
                                            delayedRetry.complete(r);
                                        }
                                    });
                        }, step.getRetryDelay().toMillis(), TimeUnit.MILLISECONDS);
                        return delayedRetry;
                    }
                    return CompletableFuture.completedFuture(result);
                });
    }

    /**
     * Handles a successful step by merging result data, recording state, and advancing.
     */
    private void handleStepSuccessInternal(final SagaExecution exec, final SagaStep step,
                                            final int stepIndex, final SagaStepResult result) {
        // Record step duration metric
        recordStepDuration(exec, step.getName());

        // Merge result data into context
        result.getData().forEach((k, v) -> exec.context.put(k, v));

        stateStore.recordStepCompleted(exec.sagaId, stepIndex, step.getName(), "orchestrator", exec.sagaId);

        notifyListeners(l -> l.onStepCompleted(exec.sagaId, step.getName(), result));
        logger.debug("Step completed: sagaId={}, step={}", exec.sagaId, step.getName());

        exec.completedStepNames.add(step.getName());

        // Execute next step
        executeStep(exec, stepIndex + 1);
    }

    /**
     * Handles a step failure by recording state and triggering compensation.
     */
    private void handleStepFailure(final SagaExecution exec, final SagaStep step,
                                    final int stepIndex, final SagaStepResult result) {
        // Record step duration metric
        recordStepDuration(exec, step.getName());

        final String reason = result.getErrorMessage().orElse("Unknown failure");
        stateStore.recordStepFailed(exec.sagaId, stepIndex, step.getName(), "orchestrator", reason);

        notifyListeners(l -> l.onStepCompleted(exec.sagaId, step.getName(), result));
        logger.warn("Step failed: sagaId={}, step={}, reason={}", exec.sagaId, step.getName(), reason);

        compensate(exec, step.getName(), reason, false);
    }

    /**
     * Handles a step timeout by recording state and triggering compensation.
     */
    private void handleStepTimeout(final SagaExecution exec, final SagaStep step,
                                    final int stepIndex, final SagaStepResult result) {
        // Record step duration metric
        recordStepDuration(exec, step.getName());

        final String reason = result.getErrorMessage().orElse("Step timed out");
        stateStore.recordStepFailed(exec.sagaId, stepIndex, step.getName(), "orchestrator", reason);

        notifyListeners(l -> l.onStepCompleted(exec.sagaId, step.getName(), result));
        logger.warn("Step timed out: sagaId={}, step={}", exec.sagaId, step.getName());

        compensate(exec, step.getName(), reason, true);
    }

    /**
     * Completes the saga successfully.
     */
    private void completeSuccess(final SagaExecution exec) {
        stateStore.completeSaga(exec.sagaId, SagaStatus.COMPLETED);

        final SagaOrchestratorResult result = SagaOrchestratorResult.success(
                exec.sagaId, exec.definition.getName(), exec.startedAt,
                exec.completedStepNames.size());

        activeExecutions.remove(exec.sagaId);
        notifyListeners(l -> l.onSagaCompleted(exec.sagaId, result));
        exec.resultFuture.complete(result);
        cancelTimeoutFuture(exec);

        logger.info("Saga completed successfully: sagaId={}, steps={}",
                exec.sagaId, exec.completedStepNames.size());
    }

    // ========== Compensation ==========

    /**
     * Compensates completed steps in reverse order.
     *
     * <p>Uses a compare-and-set on the compensating flag to ensure only one thread
     * enters compensation (handles races between step failure and saga timeout).
     *
     * @param exec the saga execution context
     * @param failedStepName the name of the step that triggered compensation (may be null)
     * @param failureReason the reason for compensation
     * @param isTimeout true if triggered by timeout
     */
    private void compensate(final SagaExecution exec, final String failedStepName,
                             final String failureReason, final boolean isTimeout) {
        if (!exec.compensating.compareAndSet(false, true)) {
            return;
        }

        stateStore.recordCompensationStarted(exec.sagaId);

        // Get completed steps in reverse order for compensation
        final List<String> stepsToCompensate = new ArrayList<>(exec.completedStepNames);
        Collections.reverse(stepsToCompensate);

        notifyListeners(l -> l.onCompensationStarted(exec.sagaId,
                failedStepName != null ? failedStepName : "cancelled", stepsToCompensate.size()));
        logger.info("Starting compensation: sagaId={}, stepsToCompensate={}",
                exec.sagaId, stepsToCompensate.size());

        // If no steps to compensate, complete immediately
        if (stepsToCompensate.isEmpty()) {
            finishCompensation(exec, failedStepName, failureReason, isTimeout, 0, false);
            return;
        }

        // Chain compensation steps sequentially
        final AtomicInteger compensatedCount = new AtomicInteger(0);
        final AtomicBoolean compensationFailed = new AtomicBoolean(false);

        CompletableFuture<Void> chain = CompletableFuture.completedFuture(null);

        for (final String stepName : stepsToCompensate) {
            final Optional<SagaStep> stepOpt = exec.definition.getStep(stepName);
            if (stepOpt.isEmpty() || !stepOpt.get().hasCompensation()) {
                continue;
            }

            final SagaStep step = stepOpt.get();
            final int stepIndex = exec.definition.getSteps().indexOf(step);

            chain = chain.thenCompose(v ->
                    step.getCompensation().get().execute(exec.context)
                            .orTimeout(step.getTimeout().toMillis(), TimeUnit.MILLISECONDS)
                            .handle((compResult, compEx) -> {
                                if (compEx != null) {
                                    compensationFailed.set(true);
                                    final Throwable cause = compEx instanceof CompletionException
                                            ? compEx.getCause() : compEx;
                                    final String msg = cause != null ? cause.getMessage()
                                            : compEx.getMessage();
                                    final SagaStepResult failResult = SagaStepResult.failure(
                                            msg != null ? msg : "Compensation failed");
                                    notifyListeners(l -> l.onCompensationStepCompleted(
                                            exec.sagaId, stepName, failResult));
                                    logger.warn("Compensation step failed: sagaId={}, step={}, error={}",
                                            exec.sagaId, stepName, msg);
                                } else if (compResult != null && compResult.isSuccess()) {
                                    compensatedCount.incrementAndGet();
                                    stateStore.recordCompensationStep(
                                            exec.sagaId, stepIndex, stepName, "orchestrator");
                                    notifyListeners(l -> l.onCompensationStepCompleted(
                                            exec.sagaId, stepName, compResult));
                                    logger.debug("Compensation step completed: sagaId={}, step={}",
                                            exec.sagaId, stepName);
                                } else {
                                    compensationFailed.set(true);
                                    final SagaStepResult effectiveResult = compResult != null
                                            ? compResult
                                            : SagaStepResult.failure("Compensation failed");
                                    notifyListeners(l -> l.onCompensationStepCompleted(
                                            exec.sagaId, stepName, effectiveResult));
                                    logger.warn("Compensation step returned failure: sagaId={}, step={}",
                                            exec.sagaId, stepName);
                                }
                                return null;
                            })
            );
        }

        chain.whenComplete((v, ex) -> finishCompensation(exec, failedStepName, failureReason,
                isTimeout, compensatedCount.get(), compensationFailed.get()));
    }

    /**
     * Completes the saga after compensation (or compensation failure).
     */
    private void finishCompensation(final SagaExecution exec, final String failedStepName,
                                     final String failureReason, final boolean isTimeout,
                                     final int compensatedCount, final boolean compensationFailed) {
        final SagaOrchestratorResult result;

        if (compensationFailed) {
            stateStore.completeSaga(exec.sagaId, SagaStatus.FAILED);
            result = SagaOrchestratorResult.failed(exec.sagaId, exec.definition.getName(),
                    exec.startedAt, exec.completedStepNames.size(), compensatedCount,
                    failedStepName, failureReason);
            logger.error("Saga failed (compensation failure): sagaId={}", exec.sagaId);
        } else if (isTimeout) {
            stateStore.completeSaga(exec.sagaId, SagaStatus.TIMED_OUT);
            result = SagaOrchestratorResult.timedOut(exec.sagaId, exec.definition.getName(),
                    exec.startedAt, exec.completedStepNames.size(), failedStepName);
            logger.warn("Saga timed out: sagaId={}", exec.sagaId);
        } else {
            stateStore.completeSaga(exec.sagaId, SagaStatus.COMPENSATED);
            result = SagaOrchestratorResult.compensated(exec.sagaId, exec.definition.getName(),
                    exec.startedAt, exec.completedStepNames.size(), compensatedCount,
                    failedStepName, failureReason);
            logger.info("Saga compensated: sagaId={}, compensated={}", exec.sagaId, compensatedCount);
        }

        activeExecutions.remove(exec.sagaId);
        notifyListeners(l -> l.onSagaCompleted(exec.sagaId, result));
        exec.resultFuture.complete(result);
        cancelTimeoutFuture(exec);
    }

    // ========== Helpers ==========

    /**
     * Maps a persisted {@link com.theyawns.framework.saga.SagaState} to a
     * {@link SagaOrchestratorResult}.
     */
    private Optional<SagaOrchestratorResult> mapStateToResult(
            final com.theyawns.framework.saga.SagaState state) {
        final SagaStatus status = state.getStatus();
        switch (status) {
            case COMPLETED:
                return Optional.of(SagaOrchestratorResult.success(
                        state.getSagaId(), state.getSagaType(),
                        state.getStartedAt(), state.getCurrentStep()));
            case COMPENSATED:
                return Optional.of(SagaOrchestratorResult.compensated(
                        state.getSagaId(), state.getSagaType(),
                        state.getStartedAt(), state.getCurrentStep(), 0,
                        null, state.getFailureReason()));
            case FAILED:
                return Optional.of(SagaOrchestratorResult.failed(
                        state.getSagaId(), state.getSagaType(),
                        state.getStartedAt(), state.getCurrentStep(), 0,
                        null, state.getFailureReason()));
            case TIMED_OUT:
                return Optional.of(SagaOrchestratorResult.timedOut(
                        state.getSagaId(), state.getSagaType(),
                        state.getStartedAt(), state.getCurrentStep(), null));
            case IN_PROGRESS:
            case STARTED:
            case COMPENSATING:
                return Optional.of(SagaOrchestratorResult.inProgress(
                        state.getSagaId(), state.getSagaType(),
                        state.getStartedAt(), state.getCurrentStep()));
            default:
                return Optional.empty();
        }
    }

    /**
     * Notifies all listeners, catching and logging any exceptions.
     */
    private void notifyListeners(final Consumer<SagaOrchestratorListener> action) {
        for (final SagaOrchestratorListener listener : listeners) {
            try {
                action.accept(listener);
            } catch (final Exception e) {
                logger.warn("Listener threw exception: {}", e.getMessage(), e);
            }
        }
    }

    /**
     * Cancels the saga-level timeout future if it hasn't fired.
     */
    private void cancelTimeoutFuture(final SagaExecution exec) {
        if (exec.timeoutFuture != null) {
            exec.timeoutFuture.cancel(false);
        }
    }

    /**
     * Records the duration of a step from its start time.
     */
    private void recordStepDuration(final SagaExecution exec, final String stepName) {
        if (sagaMetrics != null && exec.stepStartedAt != null) {
            final Duration stepDuration = Duration.between(exec.stepStartedAt, Instant.now());
            sagaMetrics.recordStepDuration(exec.definition.getName(), stepName, stepDuration);
        }
    }

    // ========== Inner Class ==========

    /**
     * Tracks the state of an in-flight saga execution.
     */
    private static class SagaExecution {

        final String sagaId;
        final SagaDefinition definition;
        final SagaContext context;
        final Instant startedAt;
        final CompletableFuture<SagaOrchestratorResult> resultFuture;
        final CopyOnWriteArrayList<String> completedStepNames;
        final AtomicBoolean compensating;

        volatile int currentStepIndex;
        volatile String currentStepName;
        volatile CompletableFuture<SagaStepResult> pendingStepFuture;
        volatile ScheduledFuture<?> timeoutFuture;
        volatile Instant stepStartedAt;

        SagaExecution(final String sagaId, final SagaDefinition definition, final SagaContext context) {
            this.sagaId = sagaId;
            this.definition = definition;
            this.context = context;
            this.startedAt = Instant.now();
            this.resultFuture = new CompletableFuture<>();
            this.completedStepNames = new CopyOnWriteArrayList<>();
            this.compensating = new AtomicBoolean(false);
        }
    }
}
