package com.theyawns.framework.saga;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.Collections;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;
import java.util.Set;
import java.util.concurrent.ConcurrentHashMap;

/**
 * Registry mapping domain events to their compensating counterparts.
 * Used by saga infrastructure to know how to roll back completed steps.
 *
 * <p>When a saga fails, the system needs to undo (compensate) the effects
 * of previously completed steps. This registry maintains the mapping from
 * forward events to their compensation events.
 *
 * <p>Example registrations:
 * <pre>
 * CompensationRegistry registry = new CompensationRegistry();
 * registry.register("OrderCreated", "OrderCancelled", "order-service");
 * registry.register("StockReserved", "StockReleased", "inventory-service");
 * registry.register("PaymentProcessed", "PaymentRefunded", "payment-service");
 * </pre>
 *
 * <p>During compensation:
 * <pre>
 * Optional&lt;CompensationMapping&gt; mapping = registry.getCompensation("StockReserved");
 * if (mapping.isPresent()) {
 *     // Trigger "StockReleased" event via "inventory-service"
 *     String compensatingEvent = mapping.get().compensatingEventType();
 *     String responsibleService = mapping.get().service();
 * }
 * </pre>
 *
 * <p>This class is thread-safe and can be safely shared across threads
 * and service instances.
 *
 * @author Generated by Claude Code
 * @since 2.0
 * @see SagaEvent
 * @see SagaState
 */
public class CompensationRegistry {

    private static final Logger logger = LoggerFactory.getLogger(CompensationRegistry.class);

    /**
     * Maps forward event types to their compensation mappings.
     * Key: forward event type (e.g., "StockReserved")
     * Value: CompensationMapping containing compensation event and responsible service
     */
    private final Map<String, CompensationMapping> mappings = new ConcurrentHashMap<>();

    /**
     * Creates an empty compensation registry.
     */
    public CompensationRegistry() {
        // Empty registry - mappings added via register()
    }

    /**
     * Registers a compensation mapping for an event type.
     *
     * <p>This method is idempotent - registering the same mapping multiple
     * times has no effect. However, registering a different mapping for
     * the same event type will overwrite the previous mapping with a warning.
     *
     * @param eventType the forward event type (e.g., "StockReserved")
     * @param compensatingEventType the event that undoes it (e.g., "StockReleased")
     * @param service the service responsible for handling compensation
     * @throws IllegalArgumentException if any argument is null or blank
     */
    public void register(String eventType, String compensatingEventType, String service) {
        Objects.requireNonNull(eventType, "eventType cannot be null");
        Objects.requireNonNull(compensatingEventType, "compensatingEventType cannot be null");
        Objects.requireNonNull(service, "service cannot be null");

        if (eventType.isBlank()) {
            throw new IllegalArgumentException("eventType cannot be blank");
        }
        if (compensatingEventType.isBlank()) {
            throw new IllegalArgumentException("compensatingEventType cannot be blank");
        }
        if (service.isBlank()) {
            throw new IllegalArgumentException("service cannot be blank");
        }

        CompensationMapping newMapping = new CompensationMapping(compensatingEventType, service);
        CompensationMapping existing = mappings.put(eventType, newMapping);

        if (existing != null && !existing.equals(newMapping)) {
            logger.warn("Overwriting compensation mapping for {}: {} -> {}",
                    eventType, existing, newMapping);
        } else {
            logger.debug("Registered compensation: {} -> {} (via {})",
                    eventType, compensatingEventType, service);
        }
    }

    /**
     * Registers a compensation mapping with an optional step number.
     *
     * @param eventType the forward event type
     * @param compensatingEventType the compensating event type
     * @param service the responsible service
     * @param stepNumber the step number in the saga sequence
     */
    public void register(String eventType, String compensatingEventType,
                         String service, int stepNumber) {
        register(eventType, compensatingEventType, service);
        // Step number is available from the SagaEvent interface,
        // but we store it in a separate map for lookup during compensation
        stepMappings.put(eventType, stepNumber);
    }

    private final Map<String, Integer> stepMappings = new ConcurrentHashMap<>();

    /**
     * Gets the compensation mapping for an event type.
     *
     * @param eventType the forward event type to look up
     * @return Optional containing the mapping, or empty if not registered
     */
    public Optional<CompensationMapping> getCompensation(String eventType) {
        if (eventType == null) {
            return Optional.empty();
        }
        return Optional.ofNullable(mappings.get(eventType));
    }

    /**
     * Gets the compensating event type for a forward event.
     * Convenience method that extracts just the event type from the mapping.
     *
     * @param eventType the forward event type
     * @return Optional containing the compensating event type, or empty if not registered
     */
    public Optional<String> getCompensatingEventType(String eventType) {
        return getCompensation(eventType)
                .map(CompensationMapping::compensatingEventType);
    }

    /**
     * Gets the service responsible for handling compensation.
     *
     * @param eventType the forward event type
     * @return Optional containing the service name, or empty if not registered
     */
    public Optional<String> getCompensatingService(String eventType) {
        return getCompensation(eventType)
                .map(CompensationMapping::service);
    }

    /**
     * Gets the step number for an event type.
     *
     * @param eventType the event type
     * @return Optional containing the step number, or empty if not registered
     */
    public Optional<Integer> getStepNumber(String eventType) {
        return Optional.ofNullable(stepMappings.get(eventType));
    }

    /**
     * Checks if a compensation mapping exists for an event type.
     *
     * @param eventType the event type to check
     * @return true if compensation is registered for this event
     */
    public boolean hasCompensation(String eventType) {
        return eventType != null && mappings.containsKey(eventType);
    }

    /**
     * Removes a compensation mapping.
     *
     * @param eventType the event type to unregister
     * @return true if a mapping was removed, false if none existed
     */
    public boolean unregister(String eventType) {
        CompensationMapping removed = mappings.remove(eventType);
        stepMappings.remove(eventType);
        if (removed != null) {
            logger.debug("Unregistered compensation for: {}", eventType);
            return true;
        }
        return false;
    }

    /**
     * Returns all registered event types that have compensation mappings.
     *
     * @return unmodifiable set of registered event types
     */
    public Set<String> getRegisteredEventTypes() {
        return Collections.unmodifiableSet(mappings.keySet());
    }

    /**
     * Returns the number of registered compensation mappings.
     *
     * @return count of registered mappings
     */
    public int size() {
        return mappings.size();
    }

    /**
     * Checks if the registry is empty.
     *
     * @return true if no compensation mappings are registered
     */
    public boolean isEmpty() {
        return mappings.isEmpty();
    }

    /**
     * Clears all compensation mappings.
     * Typically used in tests.
     */
    public void clear() {
        mappings.clear();
        stepMappings.clear();
        logger.debug("Cleared all compensation mappings");
    }

    /**
     * Represents a compensation mapping with the compensating event type
     * and the service responsible for handling it.
     *
     * @param compensatingEventType the event type that undoes the forward event
     * @param service the service responsible for publishing the compensation event
     */
    public record CompensationMapping(String compensatingEventType, String service) {

        /**
         * Creates a compensation mapping.
         *
         * @param compensatingEventType the compensating event type
         * @param service the responsible service
         */
        public CompensationMapping {
            Objects.requireNonNull(compensatingEventType, "compensatingEventType cannot be null");
            Objects.requireNonNull(service, "service cannot be null");
        }

        @Override
        public String toString() {
            return compensatingEventType + " (via " + service + ")";
        }
    }

    @Override
    public String toString() {
        return "CompensationRegistry{" +
                "mappings=" + mappings.size() +
                ", registered=" + mappings.keySet() +
                '}';
    }
}
