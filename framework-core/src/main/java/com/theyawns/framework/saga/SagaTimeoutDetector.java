package com.theyawns.framework.saga;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.topic.ITopic;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.context.ApplicationEventPublisher;
import org.springframework.scheduling.annotation.Scheduled;

import java.time.Duration;
import java.time.Instant;
import java.util.List;
import java.util.Objects;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicBoolean;
import java.util.concurrent.atomic.AtomicLong;

/**
 * Scheduled service that detects and handles sagas that have exceeded their timeout deadline.
 *
 * <p>The detector runs periodically (configurable via {@link SagaTimeoutConfig}) to:
 * <ol>
 *   <li>Query the {@link SagaStateStore} for sagas past their deadline</li>
 *   <li>Mark each timed-out saga with TIMED_OUT status</li>
 *   <li>Publish {@link SagaTimedOutEvent} for notification</li>
 *   <li>Optionally trigger compensation via {@link SagaCompensator}</li>
 *   <li>Record metrics for observability</li>
 * </ol>
 *
 * <p>Configuration example:
 * <pre>{@code
 * saga:
 *   timeout:
 *     enabled: true
 *     check-interval: 5s
 *     default-deadline: 30s
 *     auto-compensate: true
 *     max-batch-size: 100
 *     saga-types:
 *       OrderFulfillment: 60s
 * }</pre>
 *
 * <p>The detector is designed to be cluster-safe - only one instance should
 * actively process timeouts at a time to prevent duplicate compensation.
 * This is achieved through Hazelcast distributed locking.
 *
 * @author Generated by Claude Code
 * @since 2.0
 * @see SagaTimeoutConfig
 * @see SagaCompensator
 * @see SagaTimedOutEvent
 */
public class SagaTimeoutDetector {

    private static final Logger logger = LoggerFactory.getLogger(SagaTimeoutDetector.class);

    /**
     * Distributed lock name for ensuring single-instance processing.
     */
    public static final String TIMEOUT_DETECTOR_LOCK = "saga-timeout-detector-lock";

    private final SagaStateStore sagaStateStore;
    private final SagaCompensator compensator;
    private final SagaTimeoutConfig config;
    private final HazelcastInstance hazelcast;
    private final ApplicationEventPublisher eventPublisher;
    private final MeterRegistry meterRegistry;

    // Runtime state
    private final AtomicBoolean running = new AtomicBoolean(false);
    private final AtomicLong lastCheckTime = new AtomicLong(0);
    private final AtomicLong totalTimeoutsDetected = new AtomicLong(0);

    // Metrics
    private final Counter timeoutsDetectedCounter;
    private final Counter compensationsTriggeredCounter;
    private final Timer checkDurationTimer;

    /**
     * Creates a new SagaTimeoutDetector.
     *
     * @param sagaStateStore the saga state store for querying sagas
     * @param compensator the compensator for triggering rollbacks
     * @param config the timeout configuration
     * @param hazelcast the Hazelcast instance
     * @param eventPublisher Spring's event publisher
     * @param meterRegistry the metrics registry (may be null)
     */
    public SagaTimeoutDetector(SagaStateStore sagaStateStore,
                                SagaCompensator compensator,
                                SagaTimeoutConfig config,
                                HazelcastInstance hazelcast,
                                ApplicationEventPublisher eventPublisher,
                                MeterRegistry meterRegistry) {
        this.sagaStateStore = Objects.requireNonNull(sagaStateStore, "sagaStateStore cannot be null");
        this.compensator = Objects.requireNonNull(compensator, "compensator cannot be null");
        this.config = Objects.requireNonNull(config, "config cannot be null");
        this.hazelcast = Objects.requireNonNull(hazelcast, "hazelcast cannot be null");
        this.eventPublisher = eventPublisher;
        this.meterRegistry = meterRegistry;

        // Initialize metrics
        if (meterRegistry != null) {
            this.timeoutsDetectedCounter = meterRegistry.counter("saga.timeouts.detected");
            this.compensationsTriggeredCounter = meterRegistry.counter("saga.timeouts.compensations.triggered");
            this.checkDurationTimer = meterRegistry.timer("saga.timeout.check.duration");

            // Register gauges
            meterRegistry.gauge("saga.timeout.detector.running", running, b -> b.get() ? 1 : 0);
            meterRegistry.gauge("saga.timeouts.total", totalTimeoutsDetected);
        } else {
            this.timeoutsDetectedCounter = null;
            this.compensationsTriggeredCounter = null;
            this.checkDurationTimer = null;
        }

        logger.info("Initialized SagaTimeoutDetector with config: {}", config);
    }

    /**
     * Scheduled method that checks for timed-out sagas.
     *
     * <p>Uses a distributed lock to ensure only one instance processes
     * timeouts at a time in a clustered environment.
     */
    @Scheduled(fixedDelayString = "${saga.timeout.check-interval:5000}")
    public void checkForTimedOutSagas() {
        if (!config.isEnabled()) {
            logger.trace("Saga timeout detection is disabled");
            return;
        }

        // Try to acquire distributed lock
        com.hazelcast.cp.lock.FencedLock lock = null;
        boolean lockAcquired = false;

        try {
            lock = hazelcast.getCPSubsystem().getLock(TIMEOUT_DETECTOR_LOCK);
            // Try lock with short timeout - if another instance has it, skip this check
            lockAcquired = lock.tryLock(100, TimeUnit.MILLISECONDS);
            if (!lockAcquired) {
                logger.trace("Could not acquire timeout detector lock, skipping this check");
                return;
            }

            performTimeoutCheck();

        } catch (Exception e) {
            // Fall back to non-locked execution if CP subsystem not available
            if (e.getMessage() != null && e.getMessage().contains("CP Subsystem")) {
                logger.debug("CP Subsystem not available, running without distributed lock");
                performTimeoutCheck();
            } else {
                logger.error("Error during timeout check", e);
            }
        } finally {
            if (lockAcquired && lock != null) {
                try {
                    lock.unlock();
                } catch (Exception e) {
                    logger.warn("Error releasing timeout detector lock", e);
                }
            }
        }
    }

    /**
     * Performs the actual timeout check without locking.
     * Can be called directly for testing or manual triggering.
     */
    public void performTimeoutCheck() {
        if (running.getAndSet(true)) {
            logger.debug("Timeout check already in progress, skipping");
            return;
        }

        Instant startTime = Instant.now();
        int processedCount = 0;
        int compensatedCount = 0;

        try {
            logger.debug("Starting saga timeout check");

            // Find timed-out sagas
            List<SagaState> timedOutSagas = sagaStateStore.findTimedOutSagas();

            if (timedOutSagas.isEmpty()) {
                logger.trace("No timed-out sagas found");
                return;
            }

            logger.info("Found {} timed-out sagas", timedOutSagas.size());

            // Process up to max batch size
            int limit = Math.min(timedOutSagas.size(), config.getMaxBatchSize());

            for (int i = 0; i < limit; i++) {
                SagaState saga = timedOutSagas.get(i);

                try {
                    processTimedOutSaga(saga);
                    processedCount++;

                    if (config.isAutoCompensate() && compensator.canCompensate(saga)) {
                        compensator.compensate(saga);
                        compensatedCount++;
                        if (compensationsTriggeredCounter != null) {
                            compensationsTriggeredCounter.increment();
                        }
                    }
                } catch (Exception e) {
                    logger.error("Error processing timed-out saga: {}", saga.getSagaId(), e);
                }
            }

            totalTimeoutsDetected.addAndGet(processedCount);

            if (processedCount > 0) {
                logger.info("Processed {} timed-out sagas, triggered {} compensations",
                        processedCount, compensatedCount);
            }

        } finally {
            running.set(false);
            lastCheckTime.set(System.currentTimeMillis());

            // Record check duration
            Duration checkDuration = Duration.between(startTime, Instant.now());
            if (checkDurationTimer != null) {
                checkDurationTimer.record(checkDuration);
            }
            logger.debug("Timeout check completed in {}ms", checkDuration.toMillis());
        }
    }

    /**
     * Processes a single timed-out saga.
     *
     * @param saga the saga that has timed out
     */
    private void processTimedOutSaga(SagaState saga) {
        String sagaId = saga.getSagaId();
        logger.warn("Saga {} timed out after {} - deadline was {}",
                sagaId, saga.getDuration(), saga.getDeadline());

        // Mark as timed out
        sagaStateStore.completeSaga(sagaId, SagaStatus.TIMED_OUT);

        // Record metric
        if (timeoutsDetectedCounter != null) {
            timeoutsDetectedCounter.increment();
        }

        // Publish timeout event
        publishTimeoutEvent(saga);
    }

    /**
     * Publishes timeout notification events.
     *
     * @param saga the timed-out saga
     */
    private void publishTimeoutEvent(SagaState saga) {
        SagaTimedOutEvent.TimeoutDetails details = SagaTimedOutEvent.TimeoutDetails.from(saga);

        // Publish as Spring application event
        if (eventPublisher != null) {
            SagaTimedOutEvent event = new SagaTimedOutEvent(this, details);
            eventPublisher.publishEvent(event);
        }

        // Publish to Hazelcast topic for cross-service notification
        try {
            ITopic<SagaTimedOutEvent.TimeoutDetails> topic =
                    hazelcast.getTopic(SagaTimedOutEvent.TIMEOUT_TOPIC);
            topic.publish(details);
            logger.debug("Published timeout event to topic: {}", SagaTimedOutEvent.TIMEOUT_TOPIC);
        } catch (Exception e) {
            logger.error("Failed to publish timeout event to Hazelcast topic", e);
        }
    }

    /**
     * Manually triggers a timeout check.
     * Useful for testing or immediate timeout handling.
     */
    public void triggerCheck() {
        performTimeoutCheck();
    }

    /**
     * Returns whether timeout detection is enabled.
     *
     * @return true if enabled
     */
    public boolean isEnabled() {
        return config.isEnabled();
    }

    /**
     * Returns whether a check is currently running.
     *
     * @return true if running
     */
    public boolean isRunning() {
        return running.get();
    }

    /**
     * Returns the timestamp of the last check.
     *
     * @return last check time in milliseconds
     */
    public long getLastCheckTime() {
        return lastCheckTime.get();
    }

    /**
     * Returns the total number of timeouts detected since startup.
     *
     * @return total timeout count
     */
    public long getTotalTimeoutsDetected() {
        return totalTimeoutsDetected.get();
    }

    /**
     * Returns the configuration being used.
     *
     * @return timeout configuration
     */
    public SagaTimeoutConfig getConfig() {
        return config;
    }
}
