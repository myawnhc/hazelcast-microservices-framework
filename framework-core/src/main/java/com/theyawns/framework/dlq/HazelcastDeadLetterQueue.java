package com.theyawns.framework.dlq;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.hazelcast.query.Predicates;
import com.hazelcast.topic.ITopic;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Hazelcast IMap-backed implementation of {@link DeadLetterQueueOperations}.
 *
 * <p>Stores dead letter entries as Compact-serialized {@link GenericRecord}
 * values in Hazelcast IMap. The conversion between {@link DeadLetterEntry}
 * POJOs and GenericRecords happens in this class, keeping serialization
 * concerns out of the domain model.
 *
 * <p>Uses the shared cluster's IMap to store entries, making them accessible
 * from any service in the cluster. Falls back to the embedded instance if
 * no shared cluster is configured.
 *
 * <p>Replay publishes the event record to the original ITopic on the same
 * Hazelcast instance that hosts the DLQ map.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
public class HazelcastDeadLetterQueue implements DeadLetterQueueOperations {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastDeadLetterQueue.class);

    private static final String SCHEMA_NAME = "DeadLetterEntry";

    private final HazelcastInstance hazelcast;
    private final IMap<String, GenericRecord> dlqMap;
    private final DeadLetterQueueProperties properties;
    private final MeterRegistry meterRegistry;

    /**
     * Creates a new HazelcastDeadLetterQueue.
     *
     * @param hazelcast the Hazelcast instance (shared cluster preferred)
     * @param properties the DLQ configuration properties
     * @param meterRegistry the meter registry for metrics
     */
    public HazelcastDeadLetterQueue(final HazelcastInstance hazelcast,
                                     final DeadLetterQueueProperties properties,
                                     final MeterRegistry meterRegistry) {
        this.hazelcast = Objects.requireNonNull(hazelcast, "hazelcast cannot be null");
        this.properties = Objects.requireNonNull(properties, "properties cannot be null");
        this.meterRegistry = Objects.requireNonNull(meterRegistry, "meterRegistry cannot be null");
        this.dlqMap = hazelcast.getMap(properties.getMapName());
        logger.info("Initialized HazelcastDeadLetterQueue with map: {}", properties.getMapName());
    }

    @Override
    public void add(final DeadLetterEntry entry) {
        Objects.requireNonNull(entry, "entry cannot be null");
        dlqMap.set(entry.getDlqEntryId(), toRecord(entry));
        meterRegistry.counter("dlq.entries.added").increment();
        logger.info("Added DLQ entry: dlqEntryId={}, originalEventId={}, eventType={}, sourceService={}",
                entry.getDlqEntryId(), entry.getOriginalEventId(),
                entry.getEventType(), entry.getSourceService());
    }

    @Override
    public List<DeadLetterEntry> list(final int limit) {
        final Collection<GenericRecord> allRecords = dlqMap.values();
        return allRecords.stream()
                .map(HazelcastDeadLetterQueue::fromRecord)
                .sorted(Comparator.comparing(DeadLetterEntry::getFailureTimestamp).reversed())
                .limit(limit)
                .collect(Collectors.toList());
    }

    @Override
    public DeadLetterEntry getEntry(final String dlqEntryId) {
        final GenericRecord record = dlqMap.get(dlqEntryId);
        return record != null ? fromRecord(record) : null;
    }

    @Override
    public void replay(final String dlqEntryId) {
        final GenericRecord record = dlqMap.get(dlqEntryId);
        if (record == null) {
            throw new IllegalArgumentException("DLQ entry not found: " + dlqEntryId);
        }

        final DeadLetterEntry entry = fromRecord(record);

        if (entry.getStatus() != DeadLetterEntry.Status.PENDING) {
            throw new IllegalStateException(
                    "Cannot replay entry in status " + entry.getStatus() + ": " + dlqEntryId);
        }
        if (entry.getReplayCount() >= properties.getMaxReplayAttempts()) {
            throw new IllegalStateException(
                    "Max replay attempts (" + properties.getMaxReplayAttempts() +
                            ") exceeded for entry: " + dlqEntryId);
        }

        // Re-publish to the original topic
        final GenericRecord eventRecord = entry.getEventRecord();
        if (eventRecord != null && entry.getTopicName() != null) {
            final ITopic<GenericRecord> topic = hazelcast.getTopic(entry.getTopicName());
            topic.publish(eventRecord);
        }

        // Update entry status
        entry.setReplayCount(entry.getReplayCount() + 1);
        entry.setStatus(DeadLetterEntry.Status.REPLAYED);
        dlqMap.set(dlqEntryId, toRecord(entry));

        meterRegistry.counter("dlq.entries.replayed").increment();
        logger.info("Replayed DLQ entry: dlqEntryId={}, originalEventId={}, topicName={}",
                dlqEntryId, entry.getOriginalEventId(), entry.getTopicName());
    }

    @Override
    public void discard(final String dlqEntryId) {
        final GenericRecord record = dlqMap.get(dlqEntryId);
        if (record == null) {
            throw new IllegalArgumentException("DLQ entry not found: " + dlqEntryId);
        }

        final DeadLetterEntry entry = fromRecord(record);

        if (entry.getStatus() != DeadLetterEntry.Status.PENDING) {
            throw new IllegalStateException(
                    "Cannot discard entry in status " + entry.getStatus() + ": " + dlqEntryId);
        }

        entry.setStatus(DeadLetterEntry.Status.DISCARDED);
        dlqMap.set(dlqEntryId, toRecord(entry));

        meterRegistry.counter("dlq.entries.discarded").increment();
        logger.info("Discarded DLQ entry: dlqEntryId={}, originalEventId={}",
                dlqEntryId, entry.getOriginalEventId());
    }

    @Override
    public long count() {
        final Collection<GenericRecord> pending = dlqMap.values(
                Predicates.equal("status", DeadLetterEntry.Status.PENDING.name()));
        return pending.size();
    }

    /**
     * Converts a DeadLetterEntry POJO to a Compact GenericRecord for IMap storage.
     *
     * @param entry the dead letter entry
     * @return the GenericRecord representation
     */
    static GenericRecord toRecord(final DeadLetterEntry entry) {
        return GenericRecordBuilder.compact(SCHEMA_NAME)
                .setString("dlqEntryId", entry.getDlqEntryId())
                .setString("originalEventId", entry.getOriginalEventId())
                .setString("eventType", entry.getEventType())
                .setString("topicName", entry.getTopicName())
                .setGenericRecord("eventRecord", entry.getEventRecord())
                .setString("failureReason", entry.getFailureReason())
                .setInt64("failureTimestamp", entry.getFailureTimestamp().toEpochMilli())
                .setString("sourceService", entry.getSourceService())
                .setString("sagaId", entry.getSagaId())
                .setString("correlationId", entry.getCorrelationId())
                .setInt32("replayCount", entry.getReplayCount())
                .setString("status", entry.getStatus().name())
                .build();
    }

    /**
     * Reconstitutes a DeadLetterEntry POJO from a Compact GenericRecord read from IMap.
     *
     * @param record the GenericRecord
     * @return the reconstituted dead letter entry
     */
    static DeadLetterEntry fromRecord(final GenericRecord record) {
        return DeadLetterEntry.reconstitute(
                record.getString("dlqEntryId"),
                record.getString("originalEventId"),
                record.getString("eventType"),
                record.getString("topicName"),
                record.getGenericRecord("eventRecord"),
                record.getString("failureReason"),
                Instant.ofEpochMilli(record.getInt64("failureTimestamp")),
                record.getString("sourceService"),
                record.getString("sagaId"),
                record.getString("correlationId"),
                record.getInt32("replayCount"),
                DeadLetterEntry.Status.valueOf(record.getString("status"))
        );
    }
}
