package com.theyawns.framework.edition;

import com.hazelcast.core.HazelcastInstance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import jakarta.annotation.PostConstruct;
import java.util.EnumSet;
import java.util.Set;

/**
 * Central service for detecting and reporting Hazelcast edition capabilities.
 *
 * <p>This is the <strong>single source of truth</strong> for edition detection.
 * All components should inject this service rather than detecting edition themselves.
 *
 * <p>Detection strategy:
 * <ul>
 *   <li>{@code mode=auto} (default): Enterprise if license env var is set, else Community</li>
 *   <li>{@code mode=community}: Always Community, even if license is present</li>
 *   <li>{@code mode=enterprise}: Requires license; behavior on missing depends on
 *       {@code license.missing-behavior}</li>
 * </ul>
 *
 * <p><strong>Security:</strong> This class handles license keys securely:
 * <ul>
 *   <li>License is read ONLY from environment variable</li>
 *   <li>License value is NEVER logged, even partially</li>
 *   <li>License value is NEVER included in error messages</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 2.0
 * @see EditionProperties
 * @see EnterpriseFeature
 */
public class EditionDetector {

    private static final Logger logger = LoggerFactory.getLogger(EditionDetector.class);

    private final EditionProperties properties;
    private final HazelcastInstance hazelcast;

    private Edition detectedEdition;
    private Set<EnterpriseFeature> availableFeatures;
    private boolean licensePresent;

    /**
     * Available Hazelcast editions.
     */
    public enum Edition {
        /** Community Edition (free, open source). */
        COMMUNITY,
        /** Enterprise Edition (licensed, premium features). */
        ENTERPRISE
    }

    /**
     * Enterprise-only features that can be detected at runtime.
     */
    public enum EnterpriseFeature {
        /** Vector Store for similarity search. */
        VECTOR_STORE("Vector Store", "Similarity search for recommendations"),

        /** CP Subsystem for strong consistency. */
        CP_SUBSYSTEM("CP Subsystem", "Strong consistency primitives"),

        /** Hot Restart for persistence. */
        HOT_RESTART("Hot Restart", "In-memory data persistence"),

        /** TLS for encrypted communication. */
        TLS("TLS Security", "Encrypted cluster communication"),

        /** HD Memory for off-heap storage. */
        HD_MEMORY("HD Memory", "Off-heap storage for large datasets"),

        /**
         * Thread-Per-Core networking for high throughput.
         *
         * <p>Note: TPC is {@code @Beta} in Hazelcast 5.6 and may change in future releases.
         */
        THREAD_PER_CORE("Thread-Per-Core", "High-throughput thread-per-core networking"),

        /** WAN Replication for multi-datacenter. */
        WAN_REPLICATION("WAN Replication", "Multi-datacenter replication");

        private final String displayName;
        private final String description;

        EnterpriseFeature(String displayName, String description) {
            this.displayName = displayName;
            this.description = description;
        }

        /**
         * Returns the human-readable display name.
         *
         * @return display name
         */
        public String getDisplayName() {
            return displayName;
        }

        /**
         * Returns the feature description.
         *
         * @return description
         */
        public String getDescription() {
            return description;
        }
    }

    /**
     * Creates a new EditionDetector.
     *
     * @param properties the edition configuration properties
     * @param hazelcast the Hazelcast instance for runtime feature detection
     */
    public EditionDetector(EditionProperties properties, HazelcastInstance hazelcast) {
        this.properties = properties;
        this.hazelcast = hazelcast;
    }

    /**
     * Performs edition detection at startup.
     *
     * <p>Checks the license environment variable, determines the edition based on
     * the configured mode, detects available Enterprise features, and logs the results.
     */
    @PostConstruct
    public void detectEdition() {
        // Check for license in environment variable
        final String envVar = properties.getLicense().getEnvVar();
        final String license = System.getenv(envVar);
        this.licensePresent = license != null && !license.isBlank();

        // Detect edition based on mode setting
        this.detectedEdition = detectEditionFromMode();

        // Detect available features
        this.availableFeatures = detectAvailableFeatures();

        // Log status (safely, no license exposure)
        logEditionStatus();
    }

    private Edition detectEditionFromMode() {
        final String mode = properties.getMode();

        return switch (mode.toLowerCase()) {
            case "community" -> Edition.COMMUNITY;
            case "enterprise" -> {
                if (!licensePresent) {
                    handleMissingLicense();
                }
                yield Edition.ENTERPRISE;
            }
            case "auto" -> licensePresent ? Edition.ENTERPRISE : Edition.COMMUNITY;
            default -> {
                logger.warn("Unknown edition mode '{}', defaulting to 'auto'", mode);
                yield licensePresent ? Edition.ENTERPRISE : Edition.COMMUNITY;
            }
        };
    }

    private void handleMissingLicense() {
        final String behavior = properties.getLicense().getMissingBehavior();

        switch (behavior.toLowerCase()) {
            case "fail" -> throw new EditionConfigurationException(
                    "Enterprise Edition requested but license not found. " +
                    "Set environment variable: " + properties.getLicense().getEnvVar()
            );
            case "warn" -> logger.warn(
                    "Enterprise Edition requested but license not found in {}. " +
                    "Falling back to Community Edition.",
                    properties.getLicense().getEnvVar()
            );
            case "silent" -> {
                // No logging
            }
            default -> logger.warn("Unknown missing-behavior '{}', treating as 'warn'", behavior);
        }
    }

    private Set<EnterpriseFeature> detectAvailableFeatures() {
        if (detectedEdition == Edition.COMMUNITY) {
            return EnumSet.noneOf(EnterpriseFeature.class);
        }

        final Set<EnterpriseFeature> features = EnumSet.noneOf(EnterpriseFeature.class);

        if (isVectorStoreAvailable()) {
            features.add(EnterpriseFeature.VECTOR_STORE);
        }
        if (isCpSubsystemAvailable()) {
            features.add(EnterpriseFeature.CP_SUBSYSTEM);
        }
        if (isHotRestartAvailable()) {
            features.add(EnterpriseFeature.HOT_RESTART);
        }
        if (isTlsAvailable()) {
            features.add(EnterpriseFeature.TLS);
        }
        if (isHdMemoryAvailable()) {
            features.add(EnterpriseFeature.HD_MEMORY);
        }
        if (isTpcAvailable()) {
            features.add(EnterpriseFeature.THREAD_PER_CORE);
        }

        return features;
    }

    private boolean isVectorStoreAvailable() {
        try {
            Class.forName("com.hazelcast.vector.VectorCollection");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }

    private boolean isCpSubsystemAvailable() {
        try {
            // CP Subsystem requires explicit configuration of member count to be usable.
            // getCPSubsystem() always returns a non-null proxy, so we check config instead.
            return hazelcast.getConfig().getCPSubsystemConfig().getCPMemberCount() > 0;
        } catch (Exception e) {
            return false;
        }
    }

    private boolean isHotRestartAvailable() {
        try {
            return hazelcast.getConfig().getHotRestartPersistenceConfig().isEnabled();
        } catch (Exception e) {
            return false;
        }
    }

    private boolean isTlsAvailable() {
        try {
            return hazelcast.getConfig().getNetworkConfig()
                    .getSSLConfig().isEnabled();
        } catch (Exception e) {
            return false;
        }
    }

    private boolean isHdMemoryAvailable() {
        try {
            return hazelcast.getConfig().getNativeMemoryConfig().isEnabled();
        } catch (Exception e) {
            return false;
        }
    }

    private boolean isTpcAvailable() {
        try {
            return hazelcast.getConfig().getTpcConfig().isEnabled();
        } catch (Exception e) {
            return false;
        }
    }

    private void logEditionStatus() {
        if (!properties.getObservability().isLogEditionStatus()) {
            return;
        }

        logger.info("=== Hazelcast Edition Detection ===");
        logger.info("  License environment variable ({}): {}",
                properties.getLicense().getEnvVar(),
                licensePresent ? "SET" : "NOT SET");
        logger.info("  Configuration mode: {}", properties.getMode());
        logger.info("  Detected edition: {}", detectedEdition);

        if (detectedEdition == Edition.ENTERPRISE) {
            if (availableFeatures.isEmpty()) {
                logger.info("  No Enterprise features detected at runtime");
            } else {
                logger.info("  Available Enterprise features:");
                for (final EnterpriseFeature feature : availableFeatures) {
                    logger.info("    - {} ({})", feature.getDisplayName(), feature.getDescription());
                }
            }
        } else {
            logger.info("  Running with Community Edition (all core features available)");
            logger.info("  To enable Enterprise features, set: {}",
                    properties.getLicense().getEnvVar());
        }
        logger.info("===================================");
    }

    // ========== Public API ==========

    /**
     * Returns the detected Hazelcast edition.
     *
     * @return the detected edition
     */
    public Edition getEdition() {
        return detectedEdition;
    }

    /**
     * Returns true if Enterprise Edition is available.
     *
     * @return true if Enterprise
     */
    public boolean isEnterprise() {
        return detectedEdition == Edition.ENTERPRISE;
    }

    /**
     * Returns true if Community Edition is being used.
     *
     * @return true if Community
     */
    public boolean isCommunity() {
        return detectedEdition == Edition.COMMUNITY;
    }

    /**
     * Returns true if the specified Enterprise feature is available at runtime.
     *
     * @param feature the feature to check
     * @return true if the feature is available
     */
    public boolean isFeatureAvailable(EnterpriseFeature feature) {
        return availableFeatures.contains(feature);
    }

    /**
     * Returns the set of available Enterprise features.
     * Returns an empty set for Community Edition.
     *
     * @return unmodifiable set of available features
     */
    public Set<EnterpriseFeature> getAvailableFeatures() {
        if (availableFeatures.isEmpty()) {
            return EnumSet.noneOf(EnterpriseFeature.class);
        }
        return EnumSet.copyOf(availableFeatures);
    }

    /**
     * Returns true if a license key was found in the configured environment variable.
     *
     * @return true if license is present
     */
    public boolean isLicensePresent() {
        return licensePresent;
    }
}
