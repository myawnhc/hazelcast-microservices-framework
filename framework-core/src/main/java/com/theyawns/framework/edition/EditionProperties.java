package com.theyawns.framework.edition;

import org.springframework.boot.context.properties.ConfigurationProperties;

import java.util.Objects;

/**
 * Configuration properties for Hazelcast edition detection and feature management.
 *
 * <p>Binds to the {@code framework} prefix in application.yml. Provides:
 * <ul>
 *   <li>Edition mode configuration (auto/community/enterprise)</li>
 *   <li>License key environment variable reference</li>
 *   <li>Per-feature enable/disable flags</li>
 *   <li>Observability settings for edition status</li>
 * </ul>
 *
 * <p>Example configuration in application.yml:
 * <pre>{@code
 * framework:
 *   edition:
 *     mode: auto
 *     license:
 *       env-var: HZ_LICENSEKEY
 *       missing-behavior: warn
 *   features:
 *     vector-store:
 *       enabled: auto
 *       fallback-behavior: empty-results
 *     cp-subsystem:
 *       enabled: auto
 *       fallback-behavior: optimistic
 *   observability:
 *     log-edition-status: true
 *     log-feature-status: true
 *     expose-in-actuator: true
 * }</pre>
 *
 * @author Generated by Claude Code
 * @since 2.0
 * @see EditionDetector
 * @see EditionAutoConfiguration
 */
@ConfigurationProperties(prefix = "framework")
public class EditionProperties {

    /**
     * Edition configuration (mode, license).
     */
    private EditionConfig edition = new EditionConfig();

    /**
     * Feature-level configuration for Enterprise features.
     */
    private FeaturesConfig features = new FeaturesConfig();

    /**
     * Observability settings for edition and feature status.
     */
    private ObservabilityConfig observability = new ObservabilityConfig();

    /**
     * Creates a new EditionProperties with default values.
     */
    public EditionProperties() {
        // Default constructor
    }

    // ========== Getters and Setters ==========

    /**
     * Returns the edition configuration.
     *
     * @return edition config
     */
    public EditionConfig getEdition() {
        return edition;
    }

    /**
     * Sets the edition configuration.
     *
     * @param edition the edition config
     */
    public void setEdition(EditionConfig edition) {
        this.edition = edition != null ? edition : new EditionConfig();
    }

    /**
     * Returns the features configuration.
     *
     * @return features config
     */
    public FeaturesConfig getFeatures() {
        return features;
    }

    /**
     * Sets the features configuration.
     *
     * @param features the features config
     */
    public void setFeatures(FeaturesConfig features) {
        this.features = features != null ? features : new FeaturesConfig();
    }

    /**
     * Returns the observability configuration.
     *
     * @return observability config
     */
    public ObservabilityConfig getObservability() {
        return observability;
    }

    /**
     * Sets the observability configuration.
     *
     * @param observability the observability config
     */
    public void setObservability(ObservabilityConfig observability) {
        this.observability = observability != null ? observability : new ObservabilityConfig();
    }

    // ========== Convenience Methods ==========

    /**
     * Returns the edition mode setting.
     *
     * @return mode string (auto, community, enterprise)
     */
    public String getMode() {
        return edition.getMode();
    }

    /**
     * Returns the license configuration.
     *
     * @return license config
     */
    public LicenseConfig getLicense() {
        return edition.getLicense();
    }

    // ========== Nested Configuration Classes ==========

    /**
     * Configuration for Hazelcast edition selection.
     */
    public static class EditionConfig {

        /**
         * Edition mode: auto (detect from license), community, or enterprise.
         * Default: auto
         */
        private String mode = "auto";

        /**
         * License key configuration.
         */
        private LicenseConfig license = new LicenseConfig();

        /**
         * Creates a new EditionConfig with default values.
         */
        public EditionConfig() {
            // Default constructor
        }

        /**
         * Returns the edition mode.
         *
         * @return mode string
         */
        public String getMode() {
            return mode;
        }

        /**
         * Sets the edition mode.
         *
         * @param mode auto, community, or enterprise
         */
        public void setMode(String mode) {
            this.mode = Objects.requireNonNull(mode, "mode cannot be null");
        }

        /**
         * Returns the license configuration.
         *
         * @return license config
         */
        public LicenseConfig getLicense() {
            return license;
        }

        /**
         * Sets the license configuration.
         *
         * @param license the license config
         */
        public void setLicense(LicenseConfig license) {
            this.license = license != null ? license : new LicenseConfig();
        }
    }

    /**
     * Configuration for license key management.
     *
     * <p>The actual license key is NEVER stored in configuration files.
     * Only the name of the environment variable containing the key is configured.
     */
    public static class LicenseConfig {

        /**
         * Name of the environment variable containing the Hazelcast license key.
         * Default: HZ_LICENSEKEY
         */
        private String envVar = "HZ_LICENSEKEY";

        /**
         * Behavior when mode=enterprise but no license is found.
         * Values: fail (throw exception), warn (log warning), silent.
         * Default: warn
         */
        private String missingBehavior = "warn";

        /**
         * Creates a new LicenseConfig with default values.
         */
        public LicenseConfig() {
            // Default constructor
        }

        /**
         * Returns the license key environment variable name.
         *
         * @return env var name
         */
        public String getEnvVar() {
            return envVar;
        }

        /**
         * Sets the license key environment variable name.
         *
         * @param envVar the env var name
         */
        public void setEnvVar(String envVar) {
            this.envVar = Objects.requireNonNull(envVar, "envVar cannot be null");
        }

        /**
         * Returns the missing license behavior.
         *
         * @return behavior string (fail, warn, silent)
         */
        public String getMissingBehavior() {
            return missingBehavior;
        }

        /**
         * Sets the missing license behavior.
         *
         * @param missingBehavior fail, warn, or silent
         */
        public void setMissingBehavior(String missingBehavior) {
            this.missingBehavior = Objects.requireNonNull(missingBehavior,
                    "missingBehavior cannot be null");
        }
    }

    /**
     * Feature-level configuration for all Enterprise features.
     *
     * <p>Each feature can be individually enabled/disabled with a fallback behavior.
     */
    public static class FeaturesConfig {

        /**
         * Vector Store feature configuration.
         */
        private FeatureConfig vectorStore = new FeatureConfig("auto", "empty-results");

        /**
         * CP Subsystem feature configuration.
         */
        private FeatureConfig cpSubsystem = new FeatureConfig("auto", "optimistic");

        /**
         * Hot Restart feature configuration.
         */
        private FeatureConfig hotRestart = new FeatureConfig("auto", "mapstore");

        /**
         * TLS security feature configuration.
         */
        private FeatureConfig tls = new FeatureConfig("auto", "warn");

        /**
         * HD Memory feature configuration with capacity and allocator settings.
         */
        private HdMemoryFeatureConfig hdMemory = new HdMemoryFeatureConfig();

        /**
         * WAN Replication feature configuration.
         */
        private FeatureConfig wanReplication = new FeatureConfig("auto", "disabled");

        /**
         * Thread-Per-Core feature configuration with eventloop count and client settings.
         */
        private TpcFeatureConfig tpc = new TpcFeatureConfig();

        /**
         * Creates a new FeaturesConfig with default values.
         */
        public FeaturesConfig() {
            // Default constructor
        }

        public FeatureConfig getVectorStore() {
            return vectorStore;
        }

        public void setVectorStore(FeatureConfig vectorStore) {
            this.vectorStore = vectorStore != null ? vectorStore : new FeatureConfig("auto", "empty-results");
        }

        public FeatureConfig getCpSubsystem() {
            return cpSubsystem;
        }

        public void setCpSubsystem(FeatureConfig cpSubsystem) {
            this.cpSubsystem = cpSubsystem != null ? cpSubsystem : new FeatureConfig("auto", "optimistic");
        }

        public FeatureConfig getHotRestart() {
            return hotRestart;
        }

        public void setHotRestart(FeatureConfig hotRestart) {
            this.hotRestart = hotRestart != null ? hotRestart : new FeatureConfig("auto", "mapstore");
        }

        public FeatureConfig getTls() {
            return tls;
        }

        public void setTls(FeatureConfig tls) {
            this.tls = tls != null ? tls : new FeatureConfig("auto", "warn");
        }

        public HdMemoryFeatureConfig getHdMemory() {
            return hdMemory;
        }

        public void setHdMemory(HdMemoryFeatureConfig hdMemory) {
            this.hdMemory = hdMemory != null ? hdMemory : new HdMemoryFeatureConfig();
        }

        public FeatureConfig getWanReplication() {
            return wanReplication;
        }

        public void setWanReplication(FeatureConfig wanReplication) {
            this.wanReplication = wanReplication != null ? wanReplication : new FeatureConfig("auto", "disabled");
        }

        public TpcFeatureConfig getTpc() {
            return tpc;
        }

        public void setTpc(TpcFeatureConfig tpc) {
            this.tpc = tpc != null ? tpc : new TpcFeatureConfig();
        }

        /**
         * Returns the feature config for the given enterprise feature.
         *
         * @param feature the enterprise feature
         * @return the feature config
         */
        public FeatureConfig getConfigFor(EditionDetector.EnterpriseFeature feature) {
            return switch (feature) {
                case VECTOR_STORE -> vectorStore;
                case CP_SUBSYSTEM -> cpSubsystem;
                case HOT_RESTART -> hotRestart;
                case TLS -> tls;
                case HD_MEMORY -> hdMemory;
                case THREAD_PER_CORE -> tpc;
                case WAN_REPLICATION -> wanReplication;
            };
        }
    }

    /**
     * Configuration for a single Enterprise feature.
     */
    public static class FeatureConfig {

        /**
         * Whether this feature is enabled.
         * Values: auto (enable if Enterprise available), true (require), false (disable).
         * Default: auto
         */
        private String enabled = "auto";

        /**
         * Behavior when the feature is unavailable.
         * Values are feature-specific (e.g., empty-results, optimistic, warn).
         * Default: graceful
         */
        private String fallbackBehavior = "graceful";

        /**
         * Creates a new FeatureConfig with default values.
         */
        public FeatureConfig() {
            // Default constructor
        }

        /**
         * Creates a new FeatureConfig with specified values.
         *
         * @param enabled enabled mode
         * @param fallbackBehavior fallback behavior
         */
        public FeatureConfig(String enabled, String fallbackBehavior) {
            this.enabled = enabled;
            this.fallbackBehavior = fallbackBehavior;
        }

        /**
         * Returns the enabled setting.
         *
         * @return enabled string (auto, true, false)
         */
        public String getEnabled() {
            return enabled;
        }

        /**
         * Sets the enabled setting.
         *
         * @param enabled auto, true, or false
         */
        public void setEnabled(String enabled) {
            this.enabled = Objects.requireNonNull(enabled, "enabled cannot be null");
        }

        /**
         * Returns the fallback behavior.
         *
         * @return fallback behavior string
         */
        public String getFallbackBehavior() {
            return fallbackBehavior;
        }

        /**
         * Sets the fallback behavior.
         *
         * @param fallbackBehavior the fallback behavior
         */
        public void setFallbackBehavior(String fallbackBehavior) {
            this.fallbackBehavior = Objects.requireNonNull(fallbackBehavior,
                    "fallbackBehavior cannot be null");
        }

        @Override
        public String toString() {
            return "FeatureConfig{enabled='" + enabled + "', fallbackBehavior='" + fallbackBehavior + "'}";
        }
    }

    /**
     * Extended feature configuration for HD Memory with capacity and allocator settings.
     */
    public static class HdMemoryFeatureConfig extends FeatureConfig {

        /**
         * HD Memory pool capacity in megabytes.
         * Default: 512
         */
        private int capacityMb = 512;

        /**
         * Memory allocator type: STANDARD or POOLED.
         * POOLED generally offers better performance for varied allocation sizes.
         * Default: POOLED
         */
        private String allocatorType = "POOLED";

        /**
         * Creates a new HdMemoryFeatureConfig with default values.
         */
        public HdMemoryFeatureConfig() {
            super("auto", "on-heap");
        }

        public int getCapacityMb() {
            return capacityMb;
        }

        public void setCapacityMb(int capacityMb) {
            this.capacityMb = capacityMb;
        }

        public String getAllocatorType() {
            return allocatorType;
        }

        public void setAllocatorType(String allocatorType) {
            this.allocatorType = Objects.requireNonNull(allocatorType, "allocatorType cannot be null");
        }
    }

    /**
     * Extended feature configuration for Thread-Per-Core networking.
     *
     * <p>Note: TPC is {@code @Beta} in Hazelcast 5.6 and may change in future releases.
     */
    public static class TpcFeatureConfig extends FeatureConfig {

        /**
         * Number of eventloop threads. 0 means auto-detect (available processors).
         * Default: 0
         */
        private int eventloopCount = 0;

        /**
         * Whether to also enable TPC on the hazelcastClient (shared cluster client).
         * Default: true
         */
        private boolean clientEnabled = true;

        /**
         * Creates a new TpcFeatureConfig with default values.
         */
        public TpcFeatureConfig() {
            super("auto", "standard-threading");
        }

        public int getEventloopCount() {
            return eventloopCount;
        }

        public void setEventloopCount(int eventloopCount) {
            this.eventloopCount = eventloopCount;
        }

        public boolean isClientEnabled() {
            return clientEnabled;
        }

        public void setClientEnabled(boolean clientEnabled) {
            this.clientEnabled = clientEnabled;
        }
    }

    /**
     * Observability configuration for edition and feature status.
     */
    public static class ObservabilityConfig {

        /**
         * Whether to log edition detection status at startup.
         * Default: true
         */
        private boolean logEditionStatus = true;

        /**
         * Whether to log feature availability at startup.
         * Default: true
         */
        private boolean logFeatureStatus = true;

        /**
         * Whether to expose edition info at /actuator/info.
         * Default: true
         */
        private boolean exposeInActuator = true;

        /**
         * Creates a new ObservabilityConfig with default values.
         */
        public ObservabilityConfig() {
            // Default constructor
        }

        public boolean isLogEditionStatus() {
            return logEditionStatus;
        }

        public void setLogEditionStatus(boolean logEditionStatus) {
            this.logEditionStatus = logEditionStatus;
        }

        public boolean isLogFeatureStatus() {
            return logFeatureStatus;
        }

        public void setLogFeatureStatus(boolean logFeatureStatus) {
            this.logFeatureStatus = logFeatureStatus;
        }

        public boolean isExposeInActuator() {
            return exposeInActuator;
        }

        public void setExposeInActuator(boolean exposeInActuator) {
            this.exposeInActuator = exposeInActuator;
        }
    }

    @Override
    public String toString() {
        return "EditionProperties{" +
                "mode='" + edition.getMode() + "'" +
                ", licenseEnvVar='" + edition.getLicense().getEnvVar() + "'" +
                ", observability.logEditionStatus=" + observability.isLogEditionStatus() +
                ", observability.exposeInActuator=" + observability.isExposeInActuator() +
                '}';
    }
}
