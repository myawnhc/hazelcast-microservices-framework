package com.theyawns.framework.edition;

import org.springframework.boot.actuate.info.Info;
import org.springframework.boot.actuate.info.InfoContributor;

import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;

/**
 * Spring Boot Actuator {@link InfoContributor} that exposes Hazelcast edition
 * information at {@code /actuator/info}.
 *
 * <p>Exposes:
 * <ul>
 *   <li>Detected edition (COMMUNITY or ENTERPRISE)</li>
 *   <li>Whether a license key is configured (boolean, never the actual key)</li>
 *   <li>Available Enterprise features</li>
 *   <li>Feature configuration status</li>
 * </ul>
 *
 * <p>Example response:
 * <pre>{@code
 * {
 *   "hazelcast": {
 *     "edition": "COMMUNITY",
 *     "licenseConfigured": false,
 *     "availableFeatures": [],
 *     "featureConfiguration": {
 *       "vectorStore": "DISABLED (not available)",
 *       "cpSubsystem": "DISABLED (not available)"
 *     }
 *   }
 * }
 * }</pre>
 *
 * @author Generated by Claude Code
 * @since 2.0
 * @see EditionDetector
 */
public class EditionInfoContributor implements InfoContributor {

    private final EditionDetector editionDetector;
    private final EditionProperties properties;

    /**
     * Creates a new EditionInfoContributor.
     *
     * @param editionDetector the edition detector service
     * @param properties the edition properties
     */
    public EditionInfoContributor(EditionDetector editionDetector, EditionProperties properties) {
        this.editionDetector = editionDetector;
        this.properties = properties;
    }

    @Override
    public void contribute(Info.Builder builder) {
        final Map<String, Object> editionInfo = new LinkedHashMap<>();

        editionInfo.put("edition", editionDetector.getEdition().name());
        editionInfo.put("licenseConfigured", editionDetector.isLicensePresent());

        // Available features
        final List<Map<String, String>> features = editionDetector.getAvailableFeatures().stream()
                .map(f -> Map.of(
                        "name", f.name(),
                        "displayName", f.getDisplayName(),
                        "description", f.getDescription()
                ))
                .toList();
        editionInfo.put("availableFeatures", features);

        // Feature configuration status
        final Map<String, String> featureStatus = new LinkedHashMap<>();
        for (final EditionDetector.EnterpriseFeature feature : EditionDetector.EnterpriseFeature.values()) {
            featureStatus.put(toCamelCase(feature.name()), getFeatureStatus(feature));
        }
        editionInfo.put("featureConfiguration", featureStatus);

        builder.withDetail("hazelcast", editionInfo);
    }

    private String getFeatureStatus(EditionDetector.EnterpriseFeature feature) {
        final boolean available = editionDetector.isFeatureAvailable(feature);
        final String configured = properties.getFeatures().getConfigFor(feature).getEnabled();

        return switch (configured.toLowerCase()) {
            case "true" -> available ? "ENABLED (required)" : "ERROR (required but unavailable)";
            case "false" -> "DISABLED (explicitly)";
            case "auto" -> available ? "ENABLED (auto-detected)" : "DISABLED (not available)";
            default -> "UNKNOWN (" + configured + ")";
        };
    }

    /**
     * Converts UPPER_SNAKE_CASE to camelCase.
     * Example: VECTOR_STORE -> vectorStore
     */
    private static String toCamelCase(String upperSnake) {
        final String[] parts = upperSnake.toLowerCase().split("_");
        final StringBuilder sb = new StringBuilder(parts[0]);
        for (int i = 1; i < parts.length; i++) {
            sb.append(Character.toUpperCase(parts[i].charAt(0)));
            sb.append(parts[i].substring(1));
        }
        return sb.toString();
    }
}
