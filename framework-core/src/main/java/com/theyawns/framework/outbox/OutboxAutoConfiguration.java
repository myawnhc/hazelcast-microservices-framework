package com.theyawns.framework.outbox;

import com.hazelcast.core.HazelcastInstance;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.boot.autoconfigure.condition.ConditionalOnBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnMissingBean;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.Lazy;
import org.springframework.scheduling.annotation.EnableScheduling;
import org.springframework.scheduling.annotation.SchedulingConfigurer;
import org.springframework.scheduling.config.ScheduledTaskRegistrar;

/**
 * Auto-configuration for the transactional outbox pattern.
 *
 * <p>Enabled by default when a {@link HazelcastInstance} bean is available.
 * Provides:
 * <ul>
 *   <li>{@link OutboxStore} — uses the @Primary embedded Hazelcast instance</li>
 *   <li>{@link OutboxPublisher} — polls the store and delivers to the shared cluster</li>
 * </ul>
 *
 * <p>The publisher is scheduled programmatically using the {@code Duration} from
 * {@link OutboxProperties#getPollInterval()}, which supports Spring Boot's
 * human-readable duration format (e.g., {@code 2s}, {@code 500ms}).
 *
 * <p>To disable, set:
 * <pre>
 * framework.outbox.enabled=false
 * </pre>
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@Configuration
@ConditionalOnProperty(name = "framework.outbox.enabled", matchIfMissing = true)
@ConditionalOnBean(HazelcastInstance.class)
@EnableConfigurationProperties(OutboxProperties.class)
@EnableScheduling
public class OutboxAutoConfiguration implements SchedulingConfigurer {

    private static final Logger logger = LoggerFactory.getLogger(OutboxAutoConfiguration.class);

    @Lazy
    @Autowired(required = false)
    private OutboxPublisher outboxPublisher;

    @Autowired
    private OutboxProperties outboxProperties;

    /**
     * Registers the outbox publisher as a scheduled task. Uses an event-driven
     * loop: the publisher sleeps until either a new entry signal arrives
     * (via {@link OutboxPublisher#notifyNewEntry()}) or the poll interval elapses
     * as a safety-net fallback.
     *
     * @param taskRegistrar the task registrar
     */
    @Override
    public void configureTasks(final ScheduledTaskRegistrar taskRegistrar) {
        if (outboxPublisher != null) {
            final long intervalMs = outboxProperties.getPollInterval().toMillis();
            // Use a minimal fixed delay (1ms) for the scheduling loop; actual wait
            // time is controlled by OutboxPublisher.waitForWork() which blocks
            // until signaled or the poll interval elapses.
            taskRegistrar.addFixedDelayTask(() -> {
                outboxPublisher.waitForWork();
                outboxPublisher.publishPendingEntries();
            }, 1);
            logger.info("Scheduled outbox publisher with event-driven wake-up "
                    + "(fallback poll interval: {}ms)", intervalMs);
        }
    }

    /**
     * Creates the OutboxStore bean backed by the embedded Hazelcast instance.
     *
     * @param hazelcastInstance the @Primary embedded Hazelcast instance
     * @param meterRegistry the meter registry
     * @return the outbox store
     */
    @Bean
    @ConditionalOnMissingBean
    public OutboxStore outboxStore(final HazelcastInstance hazelcastInstance,
                                    final MeterRegistry meterRegistry) {
        logger.info("Creating HazelcastOutboxStore bean");
        return new HazelcastOutboxStore(hazelcastInstance, meterRegistry);
    }

    /**
     * Creates the OutboxPublisher bean that delivers entries to the shared cluster.
     *
     * @param outboxStore the outbox store to poll
     * @param sharedHazelcast the shared Hazelcast client (nullable)
     * @param properties the outbox properties
     * @param meterRegistry the meter registry
     * @return the outbox publisher
     */
    @Bean
    @ConditionalOnMissingBean
    public OutboxPublisher outboxPublisher(
            final OutboxStore outboxStore,
            @Qualifier("hazelcastClient")
            @Autowired(required = false)
            final HazelcastInstance sharedHazelcast,
            final OutboxProperties properties,
            final MeterRegistry meterRegistry) {
        logger.info("Creating OutboxPublisher bean (sharedHazelcast={})",
                sharedHazelcast != null ? "connected" : "not configured");
        return new OutboxPublisher(outboxStore, sharedHazelcast, properties, meterRegistry);
    }
}
