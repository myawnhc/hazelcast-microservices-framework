package com.theyawns.framework.outbox;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.topic.ITopic;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.util.List;
import java.util.Objects;

/**
 * Polls the {@link OutboxStore} for pending entries and delivers them
 * to the shared cluster's ITopic.
 *
 * <p>Runs on a configurable schedule (default: every 1 second). Each cycle:
 * <ol>
 *   <li>Polls for up to {@code maxBatchSize} pending entries</li>
 *   <li>Publishes each entry to its target ITopic on the shared cluster</li>
 *   <li>Marks entries as DELIVERED on success</li>
 *   <li>Increments retry count on failure</li>
 *   <li>Marks entries as FAILED when max retries are exceeded</li>
 * </ol>
 *
 * <p>When no shared Hazelcast instance is configured, the publisher logs
 * a warning once and skips delivery (graceful degradation).
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
public class OutboxPublisher {

    private static final Logger logger = LoggerFactory.getLogger(OutboxPublisher.class);

    private final OutboxStore outboxStore;
    private final HazelcastInstance sharedHazelcast;
    private final OutboxProperties properties;
    private final MeterRegistry meterRegistry;

    private volatile boolean noSharedClusterWarningLogged = false;

    /**
     * Creates a new OutboxPublisher.
     *
     * @param outboxStore the outbox store to poll
     * @param sharedHazelcast the shared Hazelcast instance for ITopic publishing (nullable)
     * @param properties the outbox configuration properties
     * @param meterRegistry the meter registry for metrics
     */
    public OutboxPublisher(final OutboxStore outboxStore,
                           final HazelcastInstance sharedHazelcast,
                           final OutboxProperties properties,
                           final MeterRegistry meterRegistry) {
        this.outboxStore = Objects.requireNonNull(outboxStore, "outboxStore cannot be null");
        this.sharedHazelcast = sharedHazelcast; // nullable — graceful degradation
        this.properties = Objects.requireNonNull(properties, "properties cannot be null");
        this.meterRegistry = Objects.requireNonNull(meterRegistry, "meterRegistry cannot be null");
        logger.info("Initialized OutboxPublisher (sharedHazelcast={}, maxBatchSize={}, maxRetries={})",
                sharedHazelcast != null ? "connected" : "not configured",
                properties.getMaxBatchSize(), properties.getMaxRetries());
    }

    /**
     * Polls pending outbox entries and delivers them to the shared cluster.
     *
     * <p>Scheduled by {@link OutboxAutoConfiguration} using the interval
     * from {@link OutboxProperties#getPollInterval()}.
     */
    public void publishPendingEntries() {
        if (sharedHazelcast == null) {
            if (!noSharedClusterWarningLogged) {
                logger.warn("No shared Hazelcast instance configured — outbox delivery skipped");
                noSharedClusterWarningLogged = true;
            }
            return;
        }

        Timer.Sample sample = Timer.start(meterRegistry);
        try {
            List<OutboxEntry> pending = outboxStore.pollPending(properties.getMaxBatchSize());
            if (pending.isEmpty()) {
                meterRegistry.counter("outbox.poll.empty").increment();
                return;
            }

            int delivered = 0;
            int failed = 0;

            for (OutboxEntry entry : pending) {
                try {
                    ITopic<GenericRecord> topic = sharedHazelcast.getTopic(entry.getEventType());
                    topic.publish(entry.getEventRecord());
                    outboxStore.markDelivered(entry.getEventId());
                    delivered++;
                    logger.debug("Delivered outbox entry: eventId={}, eventType={}",
                            entry.getEventId(), entry.getEventType());
                } catch (Exception e) {
                    failed++;
                    if (entry.getRetryCount() + 1 >= properties.getMaxRetries()) {
                        outboxStore.markFailed(entry.getEventId(),
                                "Max retries exceeded: " + e.getMessage());
                        meterRegistry.counter("outbox.entries.failed").increment();
                        logger.error("Outbox entry permanently failed after {} retries: eventId={}, reason={}",
                                entry.getRetryCount() + 1, entry.getEventId(), e.getMessage());
                    } else {
                        outboxStore.incrementRetryCount(entry.getEventId(), e.getMessage());
                        logger.warn("Failed to deliver outbox entry (retry {}): eventId={}, reason={}",
                                entry.getRetryCount() + 1, entry.getEventId(), e.getMessage());
                    }
                }
            }

            if (delivered > 0) {
                meterRegistry.counter("outbox.entries.delivered").increment(delivered);
            }

            if (delivered > 0 || failed > 0) {
                logger.info("Outbox publish cycle: delivered={}, failed={}, remaining={}",
                        delivered, failed, pending.size() - delivered - failed);
            }
        } finally {
            sample.stop(meterRegistry.timer("outbox.publish.duration"));
        }
    }
}
