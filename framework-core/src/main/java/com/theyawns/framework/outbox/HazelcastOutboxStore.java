package com.theyawns.framework.outbox;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.hazelcast.query.PagingPredicate;
import com.hazelcast.query.Predicates;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;
import java.util.stream.Collectors;

/**
 * Hazelcast IMap-backed implementation of {@link OutboxStore}.
 *
 * <p>Stores outbox entries as Compact-serialized {@link GenericRecord} values
 * in the embedded Hazelcast instance's IMap. The conversion between
 * {@link OutboxEntry} POJOs and GenericRecords happens in this class,
 * keeping serialization concerns out of the domain model.
 *
 * <p>{@code Instant} fields are stored as {@code int64} epoch millis.
 * The nested {@code eventRecord} (itself a GenericRecord) is stored via
 * {@code setGenericRecord()}, which Compact serialization handles natively.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
public class HazelcastOutboxStore implements OutboxStore {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastOutboxStore.class);

    private static final String DEFAULT_MAP_NAME = "framework_OUTBOX";
    private static final String SCHEMA_NAME = "OutboxEntry";

    private final IMap<String, GenericRecord> outboxMap;
    private final MeterRegistry meterRegistry;

    /**
     * Creates a new HazelcastOutboxStore.
     *
     * @param hazelcast the embedded Hazelcast instance
     * @param meterRegistry the meter registry for metrics
     */
    public HazelcastOutboxStore(final HazelcastInstance hazelcast, final MeterRegistry meterRegistry) {
        Objects.requireNonNull(hazelcast, "hazelcast cannot be null");
        this.outboxMap = hazelcast.getMap(DEFAULT_MAP_NAME);
        this.meterRegistry = Objects.requireNonNull(meterRegistry, "meterRegistry cannot be null");
        logger.info("Initialized HazelcastOutboxStore with map: {}", DEFAULT_MAP_NAME);
    }

    @Override
    public void write(final OutboxEntry entry) {
        Objects.requireNonNull(entry, "entry cannot be null");
        outboxMap.set(entry.getEventId(), toRecord(entry));
        meterRegistry.counter("outbox.entries.written").increment();
        logger.debug("Wrote outbox entry: eventId={}, eventType={}", entry.getEventId(), entry.getEventType());
    }

    @Override
    public List<OutboxEntry> pollPending(final int maxBatchSize) {
        Comparator<Map.Entry<String, GenericRecord>> byCreatedAt =
                Comparator.comparingLong(e -> e.getValue().getInt64("createdAt"));

        PagingPredicate<String, GenericRecord> pagingPredicate = Predicates.pagingPredicate(
                Predicates.equal("status", OutboxEntry.Status.PENDING.name()),
                byCreatedAt,
                maxBatchSize);

        Collection<GenericRecord> page = outboxMap.values(pagingPredicate);

        return page.stream()
                .map(HazelcastOutboxStore::fromRecord)
                .collect(Collectors.toList());
    }

    @Override
    public void markDelivered(final String eventId) {
        final GenericRecord record = outboxMap.get(eventId);
        if (record != null) {
            final OutboxEntry entry = fromRecord(record);
            entry.setStatus(OutboxEntry.Status.DELIVERED);
            entry.setLastAttemptAt(Instant.now());
            outboxMap.set(eventId, toRecord(entry));
            logger.debug("Marked outbox entry as DELIVERED: eventId={}", eventId);
        }
    }

    @Override
    public void markFailed(final String eventId, final String reason) {
        final GenericRecord record = outboxMap.get(eventId);
        if (record != null) {
            final OutboxEntry entry = fromRecord(record);
            entry.setStatus(OutboxEntry.Status.FAILED);
            entry.setLastAttemptAt(Instant.now());
            entry.setFailureReason(reason);
            outboxMap.set(eventId, toRecord(entry));
            logger.warn("Marked outbox entry as FAILED: eventId={}, reason={}", eventId, reason);
        }
    }

    @Override
    public void incrementRetryCount(final String eventId, final String failureReason) {
        final GenericRecord record = outboxMap.get(eventId);
        if (record != null) {
            final OutboxEntry entry = fromRecord(record);
            entry.setRetryCount(entry.getRetryCount() + 1);
            entry.setLastAttemptAt(Instant.now());
            entry.setFailureReason(failureReason);
            outboxMap.set(eventId, toRecord(entry));
            logger.debug("Incremented retry count for outbox entry: eventId={}, retryCount={}",
                    eventId, entry.getRetryCount());
        }
    }

    @Override
    public long pendingCount() {
        return outboxMap.keySet(
                Predicates.equal("status", OutboxEntry.Status.PENDING.name())).size();
    }

    @Override
    public List<OutboxEntry> claimPending(final int maxBatchSize, final String claimantId) {
        // Step 1: Find PENDING entry keys
        Comparator<Map.Entry<String, GenericRecord>> byCreatedAt =
                Comparator.comparingLong(e -> e.getValue().getInt64("createdAt"));

        PagingPredicate<String, GenericRecord> pagingPredicate = Predicates.pagingPredicate(
                Predicates.equal("status", OutboxEntry.Status.PENDING.name()),
                byCreatedAt,
                maxBatchSize);

        Set<String> candidateKeys = outboxMap.keySet(pagingPredicate);

        // Step 2: Attempt atomic CAS claim on each candidate
        ClaimEntryProcessor claimProcessor = new ClaimEntryProcessor(claimantId);
        List<OutboxEntry> claimed = new ArrayList<>();

        for (String key : candidateKeys) {
            Boolean won = outboxMap.executeOnKey(key, claimProcessor);
            if (Boolean.TRUE.equals(won)) {
                GenericRecord record = outboxMap.get(key);
                if (record != null) {
                    claimed.add(fromRecord(record));
                }
            }
        }

        if (!claimed.isEmpty()) {
            meterRegistry.counter("outbox.entries.claimed").increment(claimed.size());
            logger.debug("Claimed {} outbox entries for member {}", claimed.size(), claimantId);
        }

        return claimed;
    }

    @Override
    public int releaseExpiredClaims(final long staleTimeoutMs) {
        Set<String> claimedKeys = outboxMap.keySet(
                Predicates.equal("status", OutboxEntry.Status.CLAIMED.name()));

        if (claimedKeys.isEmpty()) {
            return 0;
        }

        ReleaseClaimEntryProcessor releaseProcessor = new ReleaseClaimEntryProcessor(staleTimeoutMs);
        int released = 0;

        for (String key : claimedKeys) {
            Boolean wasReleased = outboxMap.executeOnKey(key, releaseProcessor);
            if (Boolean.TRUE.equals(wasReleased)) {
                released++;
            }
        }

        if (released > 0) {
            meterRegistry.counter("outbox.claims.released").increment(released);
            logger.info("Released {} stale outbox claims (timeout={}ms)", released, staleTimeoutMs);
        }

        return released;
    }

    /**
     * Converts an OutboxEntry POJO to a Compact GenericRecord for IMap storage.
     *
     * @param entry the outbox entry
     * @return the GenericRecord representation
     */
    static GenericRecord toRecord(final OutboxEntry entry) {
        return GenericRecordBuilder.compact(SCHEMA_NAME)
                .setString("eventId", entry.getEventId())
                .setString("eventType", entry.getEventType())
                .setGenericRecord("eventRecord", entry.getEventRecord())
                .setInt32("retryCount", entry.getRetryCount())
                .setString("status", entry.getStatus().name())
                .setInt64("createdAt", entry.getCreatedAt().toEpochMilli())
                .setNullableInt64("lastAttemptAt",
                        entry.getLastAttemptAt() != null ? entry.getLastAttemptAt().toEpochMilli() : null)
                .setString("failureReason", entry.getFailureReason())
                .setString("claimantId", entry.getClaimantId())
                .setNullableInt64("claimedAt",
                        entry.getClaimedAt() != null ? entry.getClaimedAt().toEpochMilli() : null)
                .build();
    }

    /**
     * Reconstitutes an OutboxEntry POJO from a Compact GenericRecord read from IMap.
     *
     * @param record the GenericRecord
     * @return the reconstituted outbox entry
     */
    static OutboxEntry fromRecord(final GenericRecord record) {
        final Long lastAttemptMillis = record.getNullableInt64("lastAttemptAt");
        final Long claimedAtMillis = record.getNullableInt64("claimedAt");
        return OutboxEntry.reconstitute(
                record.getString("eventId"),
                record.getString("eventType"),
                record.getGenericRecord("eventRecord"),
                record.getInt32("retryCount"),
                OutboxEntry.Status.valueOf(record.getString("status")),
                Instant.ofEpochMilli(record.getInt64("createdAt")),
                lastAttemptMillis != null ? Instant.ofEpochMilli(lastAttemptMillis) : null,
                record.getString("failureReason"),
                record.getString("claimantId"),
                claimedAtMillis != null ? Instant.ofEpochMilli(claimedAtMillis) : null
        );
    }
}
