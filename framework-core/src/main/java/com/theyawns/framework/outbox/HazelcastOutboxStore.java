package com.theyawns.framework.outbox;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.hazelcast.query.Predicates;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.Collection;
import java.util.Comparator;
import java.util.List;
import java.util.Objects;
import java.util.stream.Collectors;

/**
 * Hazelcast IMap-backed implementation of {@link OutboxStore}.
 *
 * <p>Stores outbox entries as Compact-serialized {@link GenericRecord} values
 * in the embedded Hazelcast instance's IMap. The conversion between
 * {@link OutboxEntry} POJOs and GenericRecords happens in this class,
 * keeping serialization concerns out of the domain model.
 *
 * <p>{@code Instant} fields are stored as {@code int64} epoch millis.
 * The nested {@code eventRecord} (itself a GenericRecord) is stored via
 * {@code setGenericRecord()}, which Compact serialization handles natively.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
public class HazelcastOutboxStore implements OutboxStore {

    private static final Logger logger = LoggerFactory.getLogger(HazelcastOutboxStore.class);

    private static final String DEFAULT_MAP_NAME = "framework_OUTBOX";
    private static final String SCHEMA_NAME = "OutboxEntry";

    private final IMap<String, GenericRecord> outboxMap;
    private final MeterRegistry meterRegistry;

    /**
     * Creates a new HazelcastOutboxStore.
     *
     * @param hazelcast the embedded Hazelcast instance
     * @param meterRegistry the meter registry for metrics
     */
    public HazelcastOutboxStore(final HazelcastInstance hazelcast, final MeterRegistry meterRegistry) {
        Objects.requireNonNull(hazelcast, "hazelcast cannot be null");
        this.outboxMap = hazelcast.getMap(DEFAULT_MAP_NAME);
        this.meterRegistry = Objects.requireNonNull(meterRegistry, "meterRegistry cannot be null");
        logger.info("Initialized HazelcastOutboxStore with map: {}", DEFAULT_MAP_NAME);
    }

    @Override
    public void write(final OutboxEntry entry) {
        Objects.requireNonNull(entry, "entry cannot be null");
        outboxMap.set(entry.getEventId(), toRecord(entry));
        meterRegistry.counter("outbox.entries.written").increment();
        logger.debug("Wrote outbox entry: eventId={}, eventType={}", entry.getEventId(), entry.getEventType());
    }

    @Override
    public List<OutboxEntry> pollPending(final int maxBatchSize) {
        final Collection<GenericRecord> pending = outboxMap.values(
                Predicates.equal("status", OutboxEntry.Status.PENDING.name()));

        return pending.stream()
                .map(HazelcastOutboxStore::fromRecord)
                .sorted(Comparator.comparing(OutboxEntry::getCreatedAt))
                .limit(maxBatchSize)
                .collect(Collectors.toList());
    }

    @Override
    public void markDelivered(final String eventId) {
        final GenericRecord record = outboxMap.get(eventId);
        if (record != null) {
            final OutboxEntry entry = fromRecord(record);
            entry.setStatus(OutboxEntry.Status.DELIVERED);
            entry.setLastAttemptAt(Instant.now());
            outboxMap.set(eventId, toRecord(entry));
            logger.debug("Marked outbox entry as DELIVERED: eventId={}", eventId);
        }
    }

    @Override
    public void markFailed(final String eventId, final String reason) {
        final GenericRecord record = outboxMap.get(eventId);
        if (record != null) {
            final OutboxEntry entry = fromRecord(record);
            entry.setStatus(OutboxEntry.Status.FAILED);
            entry.setLastAttemptAt(Instant.now());
            entry.setFailureReason(reason);
            outboxMap.set(eventId, toRecord(entry));
            logger.warn("Marked outbox entry as FAILED: eventId={}, reason={}", eventId, reason);
        }
    }

    @Override
    public void incrementRetryCount(final String eventId, final String failureReason) {
        final GenericRecord record = outboxMap.get(eventId);
        if (record != null) {
            final OutboxEntry entry = fromRecord(record);
            entry.setRetryCount(entry.getRetryCount() + 1);
            entry.setLastAttemptAt(Instant.now());
            entry.setFailureReason(failureReason);
            outboxMap.set(eventId, toRecord(entry));
            logger.debug("Incremented retry count for outbox entry: eventId={}, retryCount={}",
                    eventId, entry.getRetryCount());
        }
    }

    @Override
    public long pendingCount() {
        final Collection<GenericRecord> pending = outboxMap.values(
                Predicates.equal("status", OutboxEntry.Status.PENDING.name()));
        return pending.size();
    }

    /**
     * Converts an OutboxEntry POJO to a Compact GenericRecord for IMap storage.
     *
     * @param entry the outbox entry
     * @return the GenericRecord representation
     */
    static GenericRecord toRecord(final OutboxEntry entry) {
        return GenericRecordBuilder.compact(SCHEMA_NAME)
                .setString("eventId", entry.getEventId())
                .setString("eventType", entry.getEventType())
                .setGenericRecord("eventRecord", entry.getEventRecord())
                .setInt32("retryCount", entry.getRetryCount())
                .setString("status", entry.getStatus().name())
                .setInt64("createdAt", entry.getCreatedAt().toEpochMilli())
                .setNullableInt64("lastAttemptAt",
                        entry.getLastAttemptAt() != null ? entry.getLastAttemptAt().toEpochMilli() : null)
                .setString("failureReason", entry.getFailureReason())
                .build();
    }

    /**
     * Reconstitutes an OutboxEntry POJO from a Compact GenericRecord read from IMap.
     *
     * @param record the GenericRecord
     * @return the reconstituted outbox entry
     */
    static OutboxEntry fromRecord(final GenericRecord record) {
        final Long lastAttemptMillis = record.getNullableInt64("lastAttemptAt");
        return OutboxEntry.reconstitute(
                record.getString("eventId"),
                record.getString("eventType"),
                record.getGenericRecord("eventRecord"),
                record.getInt32("retryCount"),
                OutboxEntry.Status.valueOf(record.getString("status")),
                Instant.ofEpochMilli(record.getInt64("createdAt")),
                lastAttemptMillis != null ? Instant.ofEpochMilli(lastAttemptMillis) : null,
                record.getString("failureReason")
        );
    }
}
