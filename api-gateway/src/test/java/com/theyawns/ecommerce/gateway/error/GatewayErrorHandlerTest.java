package com.theyawns.ecommerce.gateway.error;

import java.net.ConnectException;
import java.util.concurrent.TimeoutException;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.theyawns.ecommerce.gateway.filter.CorrelationIdFilter;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.mock.http.server.reactive.MockServerHttpRequest;
import org.springframework.mock.web.server.MockServerWebExchange;
import org.springframework.web.server.ResponseStatusException;
import reactor.test.StepVerifier;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link GatewayErrorHandler}.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@DisplayName("GatewayErrorHandler - Error handling")
class GatewayErrorHandlerTest {

    private GatewayErrorHandler handler;
    private ObjectMapper objectMapper;

    @BeforeEach
    void setUp() {
        objectMapper = new ObjectMapper();
        objectMapper.registerModule(new JavaTimeModule());
        handler = new GatewayErrorHandler(objectMapper);
    }

    @Nested
    @DisplayName("resolveStatus")
    class ResolveStatus {

        @Test
        @DisplayName("should return 503 for ConnectException")
        void shouldReturn503ForConnectException() {
            assertThat(handler.resolveStatus(new ConnectException("Connection refused")))
                    .isEqualTo(HttpStatus.SERVICE_UNAVAILABLE);
        }

        @Test
        @DisplayName("should return 504 for TimeoutException")
        void shouldReturn504ForTimeoutException() {
            assertThat(handler.resolveStatus(new TimeoutException("Timed out")))
                    .isEqualTo(HttpStatus.GATEWAY_TIMEOUT);
        }

        @Test
        @DisplayName("should return 502 for unknown exception")
        void shouldReturn502ForUnknownException() {
            assertThat(handler.resolveStatus(new RuntimeException("Unknown")))
                    .isEqualTo(HttpStatus.BAD_GATEWAY);
        }

        @Test
        @DisplayName("should preserve status for ResponseStatusException")
        void shouldPreserveStatusForResponseStatusException() {
            assertThat(handler.resolveStatus(new ResponseStatusException(HttpStatus.NOT_FOUND, "Not found")))
                    .isEqualTo(HttpStatus.NOT_FOUND);
        }

        @Test
        @DisplayName("should walk cause chain to find ConnectException")
        void shouldWalkCauseChainForConnectException() {
            final Throwable wrapped = new RuntimeException("Wrapper",
                    new RuntimeException("Inner", new ConnectException("Connection refused")));

            assertThat(handler.resolveStatus(wrapped))
                    .isEqualTo(HttpStatus.SERVICE_UNAVAILABLE);
        }

        @Test
        @DisplayName("should walk cause chain to find TimeoutException")
        void shouldWalkCauseChainForTimeoutException() {
            final Throwable wrapped = new RuntimeException("Wrapper",
                    new TimeoutException("Timed out"));

            assertThat(handler.resolveStatus(wrapped))
                    .isEqualTo(HttpStatus.GATEWAY_TIMEOUT);
        }

        @Test
        @DisplayName("should walk cause chain to find ResponseStatusException")
        void shouldWalkCauseChainForResponseStatusException() {
            final Throwable wrapped = new RuntimeException("Wrapper",
                    new ResponseStatusException(HttpStatus.FORBIDDEN, "Forbidden"));

            assertThat(handler.resolveStatus(wrapped))
                    .isEqualTo(HttpStatus.FORBIDDEN);
        }
    }

    @Nested
    @DisplayName("resolveErrorCode")
    class ResolveErrorCode {

        @Test
        @DisplayName("should return SERVICE_UNAVAILABLE for ConnectException")
        void shouldReturnServiceUnavailableForConnectException() {
            assertThat(handler.resolveErrorCode(new ConnectException("refused")))
                    .isEqualTo("SERVICE_UNAVAILABLE");
        }

        @Test
        @DisplayName("should return GATEWAY_TIMEOUT for TimeoutException")
        void shouldReturnGatewayTimeoutForTimeoutException() {
            assertThat(handler.resolveErrorCode(new TimeoutException("timeout")))
                    .isEqualTo("GATEWAY_TIMEOUT");
        }

        @Test
        @DisplayName("should return BAD_GATEWAY for unknown exception")
        void shouldReturnBadGatewayForUnknownException() {
            assertThat(handler.resolveErrorCode(new RuntimeException("unknown")))
                    .isEqualTo("BAD_GATEWAY");
        }

        @Test
        @DisplayName("should return status name for ResponseStatusException")
        void shouldReturnStatusNameForResponseStatusException() {
            assertThat(handler.resolveErrorCode(new ResponseStatusException(HttpStatus.NOT_FOUND)))
                    .isEqualTo("NOT_FOUND");
        }
    }

    @Nested
    @DisplayName("resolveMessage")
    class ResolveMessage {

        @Test
        @DisplayName("should return service unavailable message for ConnectException")
        void shouldReturnServiceUnavailableMessage() {
            assertThat(handler.resolveMessage(new ConnectException("refused"), HttpStatus.SERVICE_UNAVAILABLE))
                    .isEqualTo("Downstream service is unavailable");
        }

        @Test
        @DisplayName("should return timeout message for TimeoutException")
        void shouldReturnTimeoutMessage() {
            assertThat(handler.resolveMessage(new TimeoutException("timeout"), HttpStatus.GATEWAY_TIMEOUT))
                    .isEqualTo("Downstream service did not respond in time");
        }

        @Test
        @DisplayName("should return generic message for unknown exception")
        void shouldReturnGenericMessage() {
            assertThat(handler.resolveMessage(new RuntimeException("unknown"), HttpStatus.BAD_GATEWAY))
                    .isEqualTo("An unexpected gateway error occurred");
        }

        @Test
        @DisplayName("should return reason from ResponseStatusException")
        void shouldReturnReasonFromResponseStatusException() {
            assertThat(handler.resolveMessage(
                    new ResponseStatusException(HttpStatus.NOT_FOUND, "Customer not found"),
                    HttpStatus.NOT_FOUND))
                    .isEqualTo("Customer not found");
        }
    }

    @Nested
    @DisplayName("handle - JSON response writing")
    class Handle {

        @Test
        @DisplayName("should write JSON response with correct Content-Type")
        void shouldWriteJsonWithCorrectContentType() {
            final MockServerHttpRequest request = MockServerHttpRequest.get("/api/customers").build();
            final MockServerWebExchange exchange = MockServerWebExchange.from(request);
            exchange.getAttributes().put(CorrelationIdFilter.CORRELATION_ID_ATTR, "test-corr-id");

            StepVerifier.create(handler.handle(exchange, new ConnectException("refused")))
                    .verifyComplete();

            assertThat(exchange.getResponse().getHeaders().getContentType())
                    .isEqualTo(MediaType.APPLICATION_JSON);
        }

        @Test
        @DisplayName("should set correct HTTP status on response")
        void shouldSetCorrectHttpStatus() {
            final MockServerHttpRequest request = MockServerHttpRequest.get("/api/orders").build();
            final MockServerWebExchange exchange = MockServerWebExchange.from(request);

            StepVerifier.create(handler.handle(exchange, new TimeoutException("timeout")))
                    .verifyComplete();

            assertThat(exchange.getResponse().getStatusCode())
                    .isEqualTo(HttpStatus.GATEWAY_TIMEOUT);
        }

        @Test
        @DisplayName("should include correlation ID in response body")
        void shouldIncludeCorrelationId() {
            final MockServerHttpRequest request = MockServerHttpRequest.get("/api/products").build();
            final MockServerWebExchange exchange = MockServerWebExchange.from(request);
            exchange.getAttributes().put(CorrelationIdFilter.CORRELATION_ID_ATTR, "my-corr-id");

            StepVerifier.create(handler.handle(exchange, new ConnectException("refused")))
                    .verifyComplete();

            final String body = exchange.getResponse().getBodyAsString().block();
            assertThat(body).contains("\"correlationId\":\"my-corr-id\"");
        }

        @Test
        @DisplayName("should include request path in response body")
        void shouldIncludeRequestPath() {
            final MockServerHttpRequest request = MockServerHttpRequest.get("/api/payments/123").build();
            final MockServerWebExchange exchange = MockServerWebExchange.from(request);

            StepVerifier.create(handler.handle(exchange, new RuntimeException("error")))
                    .verifyComplete();

            final String body = exchange.getResponse().getBodyAsString().block();
            assertThat(body).contains("\"path\":\"/api/payments/123\"");
        }

        @Test
        @DisplayName("should handle null correlation ID gracefully")
        void shouldHandleNullCorrelationId() {
            final MockServerHttpRequest request = MockServerHttpRequest.get("/api/orders").build();
            final MockServerWebExchange exchange = MockServerWebExchange.from(request);
            // No correlationId attribute set

            StepVerifier.create(handler.handle(exchange, new RuntimeException("error")))
                    .verifyComplete();

            final String body = exchange.getResponse().getBodyAsString().block();
            assertThat(body).contains("\"correlationId\":null");
        }
    }
}
