package com.theyawns.ecommerce.gateway;

import java.util.concurrent.atomic.AtomicInteger;

import com.github.tomakehurst.wiremock.WireMockServer;
import com.github.tomakehurst.wiremock.client.WireMock;
import com.github.tomakehurst.wiremock.core.WireMockConfiguration;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpHeaders;
import org.springframework.http.MediaType;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.web.reactive.server.WebTestClient;

import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;
import static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;
import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration test for gateway rate limiting.
 *
 * <p>Configures a very low rate limit (2 req/s) so the test can trigger
 * HTTP 429 responses without sending hundreds of requests. Uses a
 * separate Spring context from the main integration tests since rate
 * limiting must be enabled here.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@DisplayName("Rate Limit Integration Tests")
class RateLimitIntegrationTest {

    private static final WireMockServer wireMock;

    static {
        wireMock = new WireMockServer(WireMockConfiguration.options().dynamicPort());
        wireMock.start();
    }

    @Autowired
    private WebTestClient webTestClient;

    @AfterAll
    static void stopWireMock() {
        wireMock.stop();
    }

    @DynamicPropertySource
    static void configureProperties(final DynamicPropertyRegistry registry) {
        registry.add("ACCOUNT_SERVICE_URL", () -> wireMock.baseUrl());
        registry.add("INVENTORY_SERVICE_URL", () -> wireMock.baseUrl());
        registry.add("ORDER_SERVICE_URL", () -> wireMock.baseUrl());
        registry.add("PAYMENT_SERVICE_URL", () -> wireMock.baseUrl());
        // Enable rate limiting with a very low limit for testing
        registry.add("gateway.rate-limit.enabled", () -> "true");
        registry.add("gateway.rate-limit.read-limit", () -> "2");
        registry.add("gateway.rate-limit.write-limit", () -> "2");
    }

    @Test
    @DisplayName("should return 429 when read rate limit is exceeded")
    void shouldReturn429WhenReadRateLimitExceeded() {
        wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/customers"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                        .withBody("[]")));

        final AtomicInteger successCount = new AtomicInteger(0);
        final AtomicInteger rateLimitedCount = new AtomicInteger(0);

        // Send more requests than the limit allows
        for (int i = 0; i < 10; i++) {
            webTestClient.get().uri("/api/customers")
                    .exchange()
                    .expectStatus().value(status -> {
                        if (status == 200) {
                            successCount.incrementAndGet();
                        } else if (status == 429) {
                            rateLimitedCount.incrementAndGet();
                        }
                    });
        }

        // At least some requests should have been rate limited
        assertThat(rateLimitedCount.get())
                .as("Some requests should have been rate limited")
                .isGreaterThan(0);
    }

    @Test
    @DisplayName("should include rate limit headers in response")
    void shouldIncludeRateLimitHeaders() {
        wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/products"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                        .withBody("[]")));

        webTestClient.get().uri("/api/products")
                .exchange()
                .expectHeader().exists("X-RateLimit-Limit");
    }

    @Test
    @DisplayName("should include Retry-After header on 429 response")
    void shouldIncludeRetryAfterOn429() {
        wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/customers/ratelimit"))
                .willReturn(aResponse()
                        .withStatus(200)
                        .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                        .withBody("{}")));

        boolean gotRateLimited = false;
        // Send rapid requests until we hit the limit
        for (int i = 0; i < 20; i++) {
            final WebTestClient.ResponseSpec response = webTestClient.get()
                    .uri("/api/customers/ratelimit")
                    .exchange();

            try {
                response.expectStatus().isEqualTo(429)
                        .expectHeader().exists("Retry-After")
                        .expectHeader().valueEquals("X-RateLimit-Remaining", "0");
                gotRateLimited = true;
                break;
            } catch (final AssertionError e) {
                // Not yet rate limited, continue
            }
        }

        assertThat(gotRateLimited)
                .as("Should eventually get rate limited with Retry-After header")
                .isTrue();
    }
}
