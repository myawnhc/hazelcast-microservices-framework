package com.theyawns.ecommerce.gateway.health;

import java.time.Duration;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.Status;
import org.springframework.web.reactive.function.client.ClientResponse;
import org.springframework.web.reactive.function.client.ExchangeFunction;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Mono;
import reactor.test.StepVerifier;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link DownstreamServicesHealthIndicator}.
 *
 * <p>Uses {@link ExchangeFunction} to simulate HTTP responses without
 * starting an actual HTTP server or mocking concrete classes.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@DisplayName("DownstreamServicesHealthIndicator - Health checks")
class DownstreamServicesHealthIndicatorTest {

    private static final Duration TIMEOUT = Duration.ofSeconds(3);

    @Test
    @DisplayName("should report UP when all services are healthy")
    void shouldReportUpWhenAllServicesHealthy() {
        final WebClient webClient = buildWebClient(jsonResponse("{\"status\":\"UP\"}"));
        final DownstreamServicesHealthIndicator indicator = createIndicator(webClient);

        StepVerifier.create(indicator.health())
                .assertNext(health -> {
                    assertThat(health.getStatus()).isEqualTo(Status.UP);
                    assertThat(health.getDetails()).containsEntry("account-service", "UP");
                    assertThat(health.getDetails()).containsEntry("inventory-service", "UP");
                    assertThat(health.getDetails()).containsEntry("order-service", "UP");
                    assertThat(health.getDetails()).containsEntry("payment-service", "UP");
                })
                .verifyComplete();
    }

    @Test
    @DisplayName("should report DOWN when one service is unavailable")
    void shouldReportDownWhenOneServiceUnavailable() {
        int[] callCount = {0};
        final ExchangeFunction exchangeFunction = request -> {
            callCount[0]++;
            // Simulate one service failing by checking the URL
            if (request.url().toString().contains("localhost:8082")) {
                return Mono.error(new RuntimeException("Connection refused"));
            }
            return Mono.just(ClientResponse.create(org.springframework.http.HttpStatus.OK)
                    .header("Content-Type", "application/json")
                    .body("{\"status\":\"UP\"}")
                    .build());
        };

        final WebClient webClient = WebClient.builder()
                .exchangeFunction(exchangeFunction)
                .build();
        final DownstreamServicesHealthIndicator indicator = createIndicator(webClient);

        StepVerifier.create(indicator.health())
                .assertNext(health -> {
                    assertThat(health.getStatus()).isEqualTo(Status.DOWN);
                    assertThat(health.getDetails()).containsEntry("inventory-service", "DOWN");
                })
                .verifyComplete();
    }

    @Test
    @DisplayName("should report non-UP status from service")
    void shouldReportNonUpStatus() {
        int[] callCount = {0};
        final ExchangeFunction exchangeFunction = request -> {
            // Simulate one service reporting degraded status
            if (request.url().toString().contains("localhost:8084")) {
                return Mono.just(ClientResponse.create(org.springframework.http.HttpStatus.OK)
                        .header("Content-Type", "application/json")
                        .body("{\"status\":\"DOWN\"}")
                        .build());
            }
            return Mono.just(ClientResponse.create(org.springframework.http.HttpStatus.OK)
                    .header("Content-Type", "application/json")
                    .body("{\"status\":\"UP\"}")
                    .build());
        };

        final WebClient webClient = WebClient.builder()
                .exchangeFunction(exchangeFunction)
                .build();
        final DownstreamServicesHealthIndicator indicator = createIndicator(webClient);

        StepVerifier.create(indicator.health())
                .assertNext(health -> {
                    assertThat(health.getStatus()).isEqualTo(Status.DOWN);
                    assertThat(health.getDetails()).containsEntry("payment-service", "DOWN");
                })
                .verifyComplete();
    }

    @Test
    @DisplayName("should report DOWN on timeout")
    void shouldReportDownOnTimeout() {
        final ExchangeFunction exchangeFunction = request -> {
            if (request.url().toString().contains("localhost:8083")) {
                // Simulate a timeout by delaying longer than the health check timeout
                return Mono.delay(Duration.ofSeconds(10))
                        .then(Mono.just(ClientResponse.create(org.springframework.http.HttpStatus.OK)
                                .header("Content-Type", "application/json")
                                .body("{\"status\":\"UP\"}")
                                .build()));
            }
            return Mono.just(ClientResponse.create(org.springframework.http.HttpStatus.OK)
                    .header("Content-Type", "application/json")
                    .body("{\"status\":\"UP\"}")
                    .build());
        };

        final WebClient webClient = WebClient.builder()
                .exchangeFunction(exchangeFunction)
                .build();
        // Use a very short timeout to trigger quickly
        final DownstreamServicesHealthIndicator indicator = new DownstreamServicesHealthIndicator(
                webClient, "http://localhost:8081", "http://localhost:8082",
                "http://localhost:8083", "http://localhost:8084", Duration.ofMillis(100));

        StepVerifier.create(indicator.health())
                .assertNext(health -> {
                    assertThat(health.getStatus()).isEqualTo(Status.DOWN);
                    assertThat(health.getDetails()).containsEntry("order-service", "DOWN");
                })
                .verifyComplete();
    }

    @Test
    @DisplayName("should include all service detail keys")
    void shouldIncludeAllServiceDetailKeys() {
        final WebClient webClient = buildWebClient(jsonResponse("{\"status\":\"UP\"}"));
        final DownstreamServicesHealthIndicator indicator = createIndicator(webClient);

        StepVerifier.create(indicator.health())
                .assertNext(health -> assertThat(health.getDetails().keySet())
                        .containsExactlyInAnyOrder(
                                "account-service", "inventory-service",
                                "order-service", "payment-service"))
                .verifyComplete();
    }

    private DownstreamServicesHealthIndicator createIndicator(final WebClient webClient) {
        return new DownstreamServicesHealthIndicator(
                webClient, "http://localhost:8081", "http://localhost:8082",
                "http://localhost:8083", "http://localhost:8084", TIMEOUT);
    }

    private WebClient buildWebClient(final ExchangeFunction exchangeFunction) {
        return WebClient.builder()
                .exchangeFunction(exchangeFunction)
                .build();
    }

    private ExchangeFunction jsonResponse(final String body) {
        return request -> Mono.just(ClientResponse.create(org.springframework.http.HttpStatus.OK)
                .header("Content-Type", "application/json")
                .body(body)
                .build());
    }
}
