package com.theyawns.ecommerce.gateway;

import java.time.Duration;

import com.github.tomakehurst.wiremock.WireMockServer;
import com.github.tomakehurst.wiremock.client.WireMock;
import com.github.tomakehurst.wiremock.core.WireMockConfiguration;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.boot.test.context.SpringBootTest;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpMethod;
import org.springframework.http.MediaType;
import org.springframework.test.context.DynamicPropertyRegistry;
import org.springframework.test.context.DynamicPropertySource;
import org.springframework.test.web.reactive.server.WebTestClient;

import static com.github.tomakehurst.wiremock.client.WireMock.aResponse;
import static com.github.tomakehurst.wiremock.client.WireMock.getRequestedFor;
import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;
import static com.github.tomakehurst.wiremock.client.WireMock.urlPathEqualTo;
import static org.assertj.core.api.Assertions.assertThat;

/**
 * Integration tests for the API Gateway.
 *
 * <p>Uses WireMock as a mock backend for all downstream services. Tests verify
 * route forwarding, correlation ID propagation, rate limiting, error handling,
 * and CORS behavior end-to-end through the full gateway filter chain.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@DisplayName("Gateway Integration Tests")
class GatewayIntegrationTest {

    private static final WireMockServer wireMock;

    static {
        wireMock = new WireMockServer(WireMockConfiguration.options().dynamicPort());
        wireMock.start();
    }

    @Autowired
    private WebTestClient webTestClient;

    @AfterAll
    static void stopWireMock() {
        wireMock.stop();
    }

    @DynamicPropertySource
    static void configureRoutes(final DynamicPropertyRegistry registry) {
        // Point all routes to the WireMock server
        registry.add("ACCOUNT_SERVICE_URL", () -> wireMock.baseUrl());
        registry.add("INVENTORY_SERVICE_URL", () -> wireMock.baseUrl());
        registry.add("ORDER_SERVICE_URL", () -> wireMock.baseUrl());
        registry.add("PAYMENT_SERVICE_URL", () -> wireMock.baseUrl());
        // Disable rate limiting for most tests (tested separately)
        registry.add("gateway.rate-limit.enabled", () -> "false");
    }

    // ========================================================================
    // Route Forwarding
    // ========================================================================

    @Nested
    @DisplayName("Route Forwarding")
    class RouteForwarding {

        @Test
        @DisplayName("should forward GET /api/customers to account-service")
        void shouldForwardGetCustomers() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/customers"))
                    .willReturn(aResponse()
                            .withStatus(200)
                            .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                            .withBody("[{\"customerId\":\"c1\",\"name\":\"Alice\"}]")));

            webTestClient.get().uri("/api/customers")
                    .exchange()
                    .expectStatus().isOk()
                    .expectBody(String.class)
                    .value(body -> assertThat(body).contains("Alice"));

            wireMock.verify(getRequestedFor(urlPathEqualTo("/api/customers")));
        }

        @Test
        @DisplayName("should forward GET /api/products to inventory-service")
        void shouldForwardGetProducts() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/products"))
                    .willReturn(aResponse()
                            .withStatus(200)
                            .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                            .withBody("[{\"productId\":\"p1\",\"name\":\"Laptop\"}]")));

            webTestClient.get().uri("/api/products")
                    .exchange()
                    .expectStatus().isOk()
                    .expectBody(String.class)
                    .value(body -> assertThat(body).contains("Laptop"));

            wireMock.verify(getRequestedFor(urlPathEqualTo("/api/products")));
        }

        @Test
        @DisplayName("should forward POST /api/orders to order-service")
        void shouldForwardPostOrders() {
            wireMock.stubFor(WireMock.post(urlPathEqualTo("/api/orders"))
                    .willReturn(aResponse()
                            .withStatus(201)
                            .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                            .withBody("{\"orderId\":\"o1\",\"status\":\"PENDING\"}")));

            webTestClient.post().uri("/api/orders")
                    .contentType(MediaType.APPLICATION_JSON)
                    .bodyValue("{\"customerId\":\"c1\"}")
                    .exchange()
                    .expectStatus().isCreated()
                    .expectBody(String.class)
                    .value(body -> assertThat(body).contains("o1"));

            wireMock.verify(postRequestedFor(urlPathEqualTo("/api/orders")));
        }

        @Test
        @DisplayName("should forward GET /api/payments to payment-service")
        void shouldForwardGetPayments() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/payments"))
                    .willReturn(aResponse()
                            .withStatus(200)
                            .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                            .withBody("[]")));

            webTestClient.get().uri("/api/payments")
                    .exchange()
                    .expectStatus().isOk();

            wireMock.verify(getRequestedFor(urlPathEqualTo("/api/payments")));
        }

        @Test
        @DisplayName("should forward GET /api/sagas to order-service")
        void shouldForwardGetSagas() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/sagas"))
                    .willReturn(aResponse()
                            .withStatus(200)
                            .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                            .withBody("[]")));

            webTestClient.get().uri("/api/sagas")
                    .exchange()
                    .expectStatus().isOk();

            wireMock.verify(getRequestedFor(urlPathEqualTo("/api/sagas")));
        }

        @Test
        @DisplayName("should forward GET /api/metrics to order-service")
        void shouldForwardGetMetrics() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/metrics"))
                    .willReturn(aResponse()
                            .withStatus(200)
                            .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                            .withBody("{}")));

            webTestClient.get().uri("/api/metrics")
                    .exchange()
                    .expectStatus().isOk();

            wireMock.verify(getRequestedFor(urlPathEqualTo("/api/metrics")));
        }

        @Test
        @DisplayName("should forward GET /api/saga/inventory to inventory-service")
        void shouldForwardInventorySaga() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/saga/inventory/status"))
                    .willReturn(aResponse()
                            .withStatus(200)
                            .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                            .withBody("{}")));

            webTestClient.get().uri("/api/saga/inventory/status")
                    .exchange()
                    .expectStatus().isOk();

            wireMock.verify(getRequestedFor(urlPathEqualTo("/api/saga/inventory/status")));
        }

        @Test
        @DisplayName("should forward GET /api/saga/payment to payment-service")
        void shouldForwardPaymentSaga() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/saga/payment/status"))
                    .willReturn(aResponse()
                            .withStatus(200)
                            .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                            .withBody("{}")));

            webTestClient.get().uri("/api/saga/payment/status")
                    .exchange()
                    .expectStatus().isOk();

            wireMock.verify(getRequestedFor(urlPathEqualTo("/api/saga/payment/status")));
        }
    }

    // ========================================================================
    // Correlation ID Propagation
    // ========================================================================

    @Nested
    @DisplayName("Correlation ID Propagation")
    class CorrelationId {

        @Test
        @DisplayName("should generate correlation ID when not provided")
        void shouldGenerateCorrelationId() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/customers"))
                    .willReturn(aResponse().withStatus(200)));

            webTestClient.get().uri("/api/customers")
                    .exchange()
                    .expectStatus().isOk()
                    .expectHeader().exists("X-Correlation-ID")
                    .expectHeader().value("X-Correlation-ID",
                            value -> assertThat(value).matches(
                                    "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}"));
        }

        @Test
        @DisplayName("should propagate existing correlation ID")
        void shouldPropagateExistingCorrelationId() {
            final String existingId = "test-correlation-id-12345";

            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/customers"))
                    .willReturn(aResponse().withStatus(200)));

            webTestClient.get().uri("/api/customers")
                    .header("X-Correlation-ID", existingId)
                    .exchange()
                    .expectStatus().isOk()
                    .expectHeader().valueEquals("X-Correlation-ID", existingId);
        }

        @Test
        @DisplayName("should forward correlation ID to downstream service")
        void shouldForwardCorrelationIdToDownstream() {
            final String correlationId = "forwarded-corr-id-99";

            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/products"))
                    .willReturn(aResponse().withStatus(200)));

            webTestClient.get().uri("/api/products")
                    .header("X-Correlation-ID", correlationId)
                    .exchange()
                    .expectStatus().isOk();

            wireMock.verify(getRequestedFor(urlPathEqualTo("/api/products"))
                    .withHeader("X-Correlation-ID", WireMock.equalTo(correlationId)));
        }
    }

    // ========================================================================
    // Error Handling
    // ========================================================================

    @Nested
    @DisplayName("Error Handling")
    class ErrorHandling {

        @Test
        @DisplayName("should return 502 for backend 500 errors")
        void shouldReturn502ForBackend500() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/customers/bad"))
                    .willReturn(aResponse().withStatus(500)));

            webTestClient.get().uri("/api/customers/bad")
                    .exchange()
                    .expectStatus().isEqualTo(500);
        }

        @Test
        @DisplayName("should preserve backend 404 responses")
        void shouldPreserveBackend404() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/customers/nonexistent"))
                    .willReturn(aResponse()
                            .withStatus(404)
                            .withHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
                            .withBody("{\"error\":\"Not found\"}")));

            webTestClient.get().uri("/api/customers/nonexistent")
                    .exchange()
                    .expectStatus().isNotFound();
        }

        @Test
        @DisplayName("should return error for unrouted paths")
        void shouldReturnErrorForUnroutedPaths() {
            webTestClient.get().uri("/api/unknown/resource")
                    .exchange()
                    .expectStatus().isNotFound();
        }
    }

    // ========================================================================
    // Circuit Breaker Fallback
    // ========================================================================

    @Nested
    @DisplayName("Circuit Breaker Fallback")
    class CircuitBreakerFallback {

        @Test
        @DisplayName("should return 503 with service name on fallback")
        void shouldReturn503OnFallback() {
            webTestClient.get().uri("/fallback/account-service")
                    .exchange()
                    .expectStatus().isEqualTo(503)
                    .expectBody()
                    .jsonPath("$.errorCode").isEqualTo("CIRCUIT_BREAKER_OPEN")
                    .jsonPath("$.message").value(msg ->
                            assertThat((String) msg).contains("account-service"));
        }

        @Test
        @DisplayName("should return 503 with correct service name for inventory fallback")
        void shouldReturn503ForInventoryFallback() {
            webTestClient.get().uri("/fallback/inventory-service")
                    .exchange()
                    .expectStatus().isEqualTo(503)
                    .expectBody()
                    .jsonPath("$.errorCode").isEqualTo("CIRCUIT_BREAKER_OPEN")
                    .jsonPath("$.message").value(msg ->
                            assertThat((String) msg).contains("inventory-service"));
        }
    }

    // ========================================================================
    // CORS
    // ========================================================================

    @Nested
    @DisplayName("CORS Preflight")
    class Cors {

        @Test
        @DisplayName("should handle CORS preflight from allowed origin")
        void shouldHandleCorsPreflight() {
            webTestClient.options().uri("/api/customers")
                    .header(HttpHeaders.ORIGIN, "http://localhost:3000")
                    .header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.GET.name())
                    .exchange()
                    .expectStatus().isOk()
                    .expectHeader().valueEquals(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN,
                            "http://localhost:3000")
                    .expectHeader().exists(HttpHeaders.ACCESS_CONTROL_ALLOW_METHODS);
        }

        @Test
        @DisplayName("should expose custom headers in CORS response")
        void shouldExposeCustomHeaders() {
            webTestClient.options().uri("/api/customers")
                    .header(HttpHeaders.ORIGIN, "http://localhost:5173")
                    .header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.GET.name())
                    .exchange()
                    .expectStatus().isOk()
                    .expectHeader().value(HttpHeaders.ACCESS_CONTROL_EXPOSE_HEADERS,
                            value -> assertThat(value).contains("X-Correlation-ID"));
        }

        @Test
        @DisplayName("should reject CORS preflight from disallowed origin")
        void shouldRejectDisallowedOrigin() {
            webTestClient.options().uri("/api/customers")
                    .header(HttpHeaders.ORIGIN, "http://evil.example.com")
                    .header(HttpHeaders.ACCESS_CONTROL_REQUEST_METHOD, HttpMethod.GET.name())
                    .exchange()
                    .expectHeader().doesNotExist(HttpHeaders.ACCESS_CONTROL_ALLOW_ORIGIN);
        }
    }

    // ========================================================================
    // Response Timing
    // ========================================================================

    @Nested
    @DisplayName("Response Timing")
    class Timing {

        @Test
        @DisplayName("should include response time header")
        void shouldIncludeResponseTimeHeader() {
            wireMock.stubFor(WireMock.get(urlPathEqualTo("/api/customers"))
                    .willReturn(aResponse().withStatus(200)));

            webTestClient.get().uri("/api/customers")
                    .exchange()
                    .expectStatus().isOk()
                    .expectHeader().exists("X-Response-Time");
        }
    }

    // ========================================================================
    // Actuator Health
    // ========================================================================

    @Nested
    @DisplayName("Actuator Health")
    class ActuatorHealth {

        @Test
        @DisplayName("should expose health endpoint")
        void shouldExposeHealthEndpoint() {
            // Health may be DOWN (503) because WireMock doesn't serve /actuator/health,
            // but the endpoint itself must be reachable and return a status field
            webTestClient.get().uri("/actuator/health")
                    .exchange()
                    .expectBody()
                    .jsonPath("$.status").exists();
        }

        @Test
        @DisplayName("should expose metrics endpoint")
        void shouldExposeMetricsEndpoint() {
            webTestClient.get().uri("/actuator/metrics")
                    .exchange()
                    .expectStatus().isOk();
        }
    }
}
