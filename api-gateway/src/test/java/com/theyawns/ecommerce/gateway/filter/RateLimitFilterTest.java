package com.theyawns.ecommerce.gateway.filter;

import java.net.InetSocketAddress;
import java.util.UUID;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.theyawns.ecommerce.gateway.config.RateLimitProperties;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.http.HttpStatus;
import org.springframework.mock.http.server.reactive.MockServerHttpRequest;
import org.springframework.mock.web.server.MockServerWebExchange;
import reactor.core.publisher.Mono;

import static org.assertj.core.api.Assertions.assertThat;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.when;

/**
 * Unit tests for {@link RateLimitFilter}.
 *
 * <p>Uses a real embedded Hazelcast instance for accurate token bucket testing.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@DisplayName("RateLimitFilter - Hazelcast-backed rate limiting")
class RateLimitFilterTest {

    private HazelcastInstance hazelcast;
    private RateLimitProperties properties;
    private RateLimitFilter filter;
    private GatewayFilterChain chain;

    @BeforeAll
    void setUpHazelcast() {
        final Config config = new Config();
        config.setClusterName("test-rate-limit-" + UUID.randomUUID());
        config.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
        config.getNetworkConfig().getJoin().getAutoDetectionConfig().setEnabled(false);
        config.getJetConfig().setEnabled(false);
        hazelcast = Hazelcast.newHazelcastInstance(config);
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void setUp() {
        // Clear rate limit map between tests
        hazelcast.getMap("rate-limit").clear();

        properties = new RateLimitProperties();
        properties.setEnabled(true);
        properties.setReadLimit(5);
        properties.setWriteLimit(2);

        filter = new RateLimitFilter(hazelcast, properties);

        chain = mock(GatewayFilterChain.class);
        when(chain.filter(any())).thenReturn(Mono.empty());
    }

    @Test
    @DisplayName("should allow requests within read limit")
    void shouldAllowRequestsWithinReadLimit() {
        final MockServerWebExchange exchange = createExchange("GET", "/api/customers", "10.0.0.1");

        filter.filter(exchange, chain).block();

        assertThat(exchange.getResponse().getStatusCode()).isNotEqualTo(HttpStatus.TOO_MANY_REQUESTS);
    }

    @Test
    @DisplayName("should reject requests exceeding read limit with 429")
    void shouldRejectRequestsExceedingReadLimit() {
        // Exhaust the read limit (5 requests)
        for (int i = 0; i < 5; i++) {
            final MockServerWebExchange exchange = createExchange("GET", "/api/customers", "10.0.0.2");
            filter.filter(exchange, chain).block();
        }

        // 6th request should be rate limited
        final MockServerWebExchange exchange = createExchange("GET", "/api/customers", "10.0.0.2");
        filter.filter(exchange, chain).block();

        assertThat(exchange.getResponse().getStatusCode()).isEqualTo(HttpStatus.TOO_MANY_REQUESTS);
    }

    @Test
    @DisplayName("should use write limit for POST requests")
    void shouldUseWriteLimitForPostRequests() {
        // Exhaust the write limit (2 requests)
        for (int i = 0; i < 2; i++) {
            final MockServerWebExchange exchange = createExchange("POST", "/api/customers", "10.0.0.3");
            filter.filter(exchange, chain).block();
        }

        // 3rd request should be rate limited
        final MockServerWebExchange exchange = createExchange("POST", "/api/customers", "10.0.0.3");
        filter.filter(exchange, chain).block();

        assertThat(exchange.getResponse().getStatusCode()).isEqualTo(HttpStatus.TOO_MANY_REQUESTS);
    }

    @Test
    @DisplayName("should use separate buckets for read and write")
    void shouldUseSeparateBucketsForReadAndWrite() {
        final String clientIp = "10.0.0.4";

        // Exhaust write limit
        for (int i = 0; i < 2; i++) {
            final MockServerWebExchange exchange = createExchange("POST", "/api/customers", clientIp);
            filter.filter(exchange, chain).block();
        }

        // POST should be rate limited
        final MockServerWebExchange writeExchange = createExchange("POST", "/api/customers", clientIp);
        filter.filter(writeExchange, chain).block();
        assertThat(writeExchange.getResponse().getStatusCode()).isEqualTo(HttpStatus.TOO_MANY_REQUESTS);

        // But GET from same client should still work (separate bucket)
        final MockServerWebExchange readExchange = createExchange("GET", "/api/customers", clientIp);
        filter.filter(readExchange, chain).block();
        assertThat(readExchange.getResponse().getStatusCode()).isNotEqualTo(HttpStatus.TOO_MANY_REQUESTS);
    }

    @Test
    @DisplayName("should pass through when rate limiting is disabled")
    void shouldPassThroughWhenDisabled() {
        properties.setEnabled(false);

        // Send many requests â€” none should be rate limited
        for (int i = 0; i < 20; i++) {
            final MockServerWebExchange exchange = createExchange("GET", "/api/customers", "10.0.0.5");
            filter.filter(exchange, chain).block();
            assertThat(exchange.getResponse().getStatusCode()).isNotEqualTo(HttpStatus.TOO_MANY_REQUESTS);
        }
    }

    @Test
    @DisplayName("should set Retry-After header on 429 response")
    void shouldSetRetryAfterHeaderOn429() {
        // Exhaust limit
        for (int i = 0; i < 5; i++) {
            final MockServerWebExchange exchange = createExchange("GET", "/api/customers", "10.0.0.6");
            filter.filter(exchange, chain).block();
        }

        final MockServerWebExchange exchange = createExchange("GET", "/api/customers", "10.0.0.6");
        filter.filter(exchange, chain).block();

        assertThat(exchange.getResponse().getHeaders().getFirst("Retry-After")).isEqualTo("1");
    }

    @Test
    @DisplayName("should set X-RateLimit-Limit header")
    void shouldSetRateLimitHeader() {
        final MockServerWebExchange exchange = createExchange("GET", "/api/customers", "10.0.0.7");
        filter.filter(exchange, chain).block();

        assertThat(exchange.getResponse().getHeaders().getFirst("X-RateLimit-Limit")).isEqualTo("5");
    }

    @Test
    @DisplayName("should extract client IP from X-Forwarded-For header")
    void shouldExtractClientIpFromXForwardedFor() {
        final MockServerWebExchange exchange = MockServerWebExchange.from(
                MockServerHttpRequest.get("/api/customers")
                        .header("X-Forwarded-For", "203.0.113.50, 70.41.3.18")
                        .remoteAddress(new InetSocketAddress("10.0.0.1", 12345))
                        .build());

        final String clientIp = filter.extractClientIp(exchange);
        assertThat(clientIp).isEqualTo("203.0.113.50");
    }

    @Test
    @DisplayName("should use remote address when X-Forwarded-For is absent")
    void shouldUseRemoteAddressWhenNoXForwardedFor() {
        final MockServerWebExchange exchange = MockServerWebExchange.from(
                MockServerHttpRequest.get("/api/customers")
                        .remoteAddress(new InetSocketAddress("192.168.1.100", 12345))
                        .build());

        final String clientIp = filter.extractClientIp(exchange);
        assertThat(clientIp).isEqualTo("192.168.1.100");
    }

    @Test
    @DisplayName("should have order -2")
    void shouldHaveCorrectOrder() {
        assertThat(filter.getOrder()).isEqualTo(-2);
    }

    /**
     * Creates a mock exchange with the given HTTP method, path, and client IP.
     */
    private MockServerWebExchange createExchange(final String method, final String path, final String clientIp) {
        final MockServerHttpRequest.BaseBuilder<?> builder;
        switch (method) {
            case "POST":
                builder = MockServerHttpRequest.post(path);
                break;
            case "PUT":
                builder = MockServerHttpRequest.put(path);
                break;
            case "DELETE":
                builder = MockServerHttpRequest.delete(path);
                break;
            default:
                builder = MockServerHttpRequest.get(path);
                break;
        }
        return MockServerWebExchange.from(
                builder.remoteAddress(new InetSocketAddress(clientIp, 12345)).build());
    }
}
