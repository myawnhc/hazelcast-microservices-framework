package com.theyawns.ecommerce.gateway.filter;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpHeaders;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

/**
 * Global filter that propagates the {@code Authorization} header from incoming
 * requests to downstream services, enabling service-to-service JWT forwarding.
 *
 * <p>When a client sends a request with a Bearer JWT token to the API Gateway,
 * the gateway validates the token (via {@code GatewaySecurityConfig}), then this
 * filter copies the {@code Authorization} header to the downstream request so
 * that services can also validate the caller's identity if needed.
 *
 * <p>Only active when {@code framework.security.enabled=true}. When security is
 * disabled (default), this filter is not registered and no header propagation occurs.
 *
 * <p>Filter order: {@code -3} (runs after CorrelationIdFilter at -4, but before
 * rate limiting and other filters).
 *
 * @author Generated by Claude Code
 * @since 3.0
 * @see com.theyawns.ecommerce.gateway.config.GatewaySecurityConfig
 */
@Component
@ConditionalOnProperty(name = "framework.security.enabled", havingValue = "true")
public class ServiceTokenRelayFilter implements GlobalFilter, Ordered {

    private static final Logger logger = LoggerFactory.getLogger(ServiceTokenRelayFilter.class);

    /** The HTTP header used for Bearer token propagation. */
    private static final String AUTHORIZATION_HEADER = HttpHeaders.AUTHORIZATION;

    /** Prefix for Bearer tokens. */
    private static final String BEARER_PREFIX = "Bearer ";

    /**
     * Creates a new ServiceTokenRelayFilter.
     */
    public ServiceTokenRelayFilter() {
        logger.info("ServiceTokenRelayFilter initialized — JWT tokens will be forwarded to downstream services");
    }

    @Override
    public Mono<Void> filter(final ServerWebExchange exchange, final GatewayFilterChain chain) {
        final String authHeader = exchange.getRequest().getHeaders().getFirst(AUTHORIZATION_HEADER);

        if (authHeader == null || !authHeader.startsWith(BEARER_PREFIX)) {
            // No Bearer token present — pass through without modification
            return chain.filter(exchange);
        }

        // Propagate the Authorization header to the downstream service
        final ServerHttpRequest mutatedRequest = exchange.getRequest().mutate()
                .header(AUTHORIZATION_HEADER, authHeader)
                .build();

        final ServerWebExchange mutatedExchange = exchange.mutate()
                .request(mutatedRequest)
                .build();

        if (logger.isDebugEnabled()) {
            logger.debug("Relaying Bearer token to downstream service for path: {}",
                    exchange.getRequest().getPath());
        }

        return chain.filter(mutatedExchange);
    }

    @Override
    public int getOrder() {
        return -3;
    }
}
