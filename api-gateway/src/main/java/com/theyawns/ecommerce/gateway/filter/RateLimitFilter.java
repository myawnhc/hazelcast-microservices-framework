package com.theyawns.ecommerce.gateway.filter;

import java.net.InetSocketAddress;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.theyawns.ecommerce.gateway.config.RateLimitProperties;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpMethod;
import org.springframework.http.HttpStatus;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

/**
 * Global filter that enforces per-client rate limits using a Hazelcast-backed token bucket.
 *
 * <p>Each client (identified by IP address) gets a separate token bucket stored in
 * a Hazelcast {@link IMap}. Read operations (GET, HEAD) and write operations
 * (POST, PUT, DELETE, PATCH) use separate rate limits, configurable via
 * {@link RateLimitProperties}.
 *
 * <p>When a client exceeds the rate limit, the filter short-circuits the request
 * with HTTP 429 (Too Many Requests) and includes {@code Retry-After} and
 * rate limit headers in the response.
 *
 * <p>Filter order: {@code -2} (runs after correlation ID, before logging).
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Component
@EnableConfigurationProperties(RateLimitProperties.class)
public class RateLimitFilter implements GlobalFilter, Ordered {

    private static final Logger logger = LoggerFactory.getLogger(RateLimitFilter.class);

    private final RateLimitProperties properties;
    private final IMap<String, long[]> rateLimitMap;

    /**
     * Creates the rate limit filter.
     *
     * @param hazelcast the embedded Hazelcast instance for rate limit state
     * @param properties rate limit configuration properties
     */
    public RateLimitFilter(final HazelcastInstance hazelcast, final RateLimitProperties properties) {
        this.properties = properties;
        this.rateLimitMap = hazelcast.getMap("rate-limit");
    }

    @Override
    public Mono<Void> filter(final ServerWebExchange exchange, final GatewayFilterChain chain) {
        if (!properties.isEnabled()) {
            return chain.filter(exchange);
        }

        final String clientIp = extractClientIp(exchange);
        final int limit = resolveLimit(exchange);
        final String bucketKey = clientIp + ":" + (isReadRequest(exchange) ? "read" : "write");

        final Boolean allowed = rateLimitMap.executeOnKey(
                bucketKey,
                new TokenBucketProcessor(limit, limit)
        );

        // Add rate limit headers
        exchange.getResponse().getHeaders().set("X-RateLimit-Limit", String.valueOf(limit));

        if (Boolean.TRUE.equals(allowed)) {
            return chain.filter(exchange);
        }

        // Rate limited
        logger.warn("Rate limit exceeded for client {} on {} {} [limit={}/s]",
                clientIp,
                exchange.getRequest().getMethod(),
                exchange.getRequest().getURI().getPath(),
                limit);

        exchange.getResponse().setStatusCode(HttpStatus.TOO_MANY_REQUESTS);
        exchange.getResponse().getHeaders().set("Retry-After", "1");
        exchange.getResponse().getHeaders().set("X-RateLimit-Remaining", "0");
        return exchange.getResponse().setComplete();
    }

    /**
     * Extracts the client IP address, checking X-Forwarded-For first for
     * clients behind proxies/load balancers.
     *
     * @param exchange the current server exchange
     * @return the client IP address
     */
    String extractClientIp(final ServerWebExchange exchange) {
        final String xff = exchange.getRequest().getHeaders().getFirst("X-Forwarded-For");
        if (xff != null && !xff.isBlank()) {
            return xff.split(",")[0].trim();
        }
        final InetSocketAddress remoteAddress = exchange.getRequest().getRemoteAddress();
        return remoteAddress != null ? remoteAddress.getAddress().getHostAddress() : "unknown";
    }

    /**
     * Resolves the rate limit based on HTTP method.
     *
     * @param exchange the current server exchange
     * @return the applicable rate limit (requests per second)
     */
    private int resolveLimit(final ServerWebExchange exchange) {
        return isReadRequest(exchange) ? properties.getReadLimit() : properties.getWriteLimit();
    }

    private boolean isReadRequest(final ServerWebExchange exchange) {
        final HttpMethod method = exchange.getRequest().getMethod();
        return HttpMethod.GET.equals(method) || HttpMethod.HEAD.equals(method);
    }

    @Override
    public int getOrder() {
        return -2;
    }
}
