package com.theyawns.ecommerce.gateway.filter;

import java.util.concurrent.TimeUnit;

import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.Timer;
import org.springframework.cloud.gateway.filter.GatewayFilterChain;
import org.springframework.cloud.gateway.filter.GlobalFilter;
import org.springframework.core.Ordered;
import org.springframework.http.HttpStatusCode;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

/**
 * Global filter that measures request processing duration.
 *
 * <p>Records the elapsed time for each request and:
 * <ul>
 *   <li>Publishes a {@code gateway.request.duration} Micrometer Timer metric
 *       tagged by HTTP method, path, and response status</li>
 *   <li>Adds an {@code X-Response-Time} header to the response</li>
 * </ul>
 *
 * <p>The timer starts before the request is forwarded and stops when the
 * response is about to be committed, ensuring accurate measurement of
 * the full downstream round-trip.
 *
 * <p>Filter order: {@code -3} (runs after correlation ID, before rate limit).
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Component
public class RequestTimingFilter implements GlobalFilter, Ordered {

    private final MeterRegistry meterRegistry;

    /**
     * Creates the request timing filter.
     *
     * @param meterRegistry the Micrometer registry for recording timer metrics
     */
    public RequestTimingFilter(final MeterRegistry meterRegistry) {
        this.meterRegistry = meterRegistry;
    }

    @Override
    public Mono<Void> filter(final ServerWebExchange exchange, final GatewayFilterChain chain) {
        final long startTime = System.nanoTime();

        // Register a callback that fires before the response is committed,
        // ensuring headers can still be modified and timing is accurate.
        exchange.getResponse().beforeCommit(() -> {
            final long duration = System.nanoTime() - startTime;
            final double durationMs = duration / 1_000_000.0;

            // Add response time header
            exchange.getResponse().getHeaders()
                    .set("X-Response-Time", String.format("%.2fms", durationMs));

            // Record Micrometer metric
            final String method = exchange.getRequest().getMethod() != null
                    ? exchange.getRequest().getMethod().name() : "UNKNOWN";
            final String path = exchange.getRequest().getURI().getPath();
            final HttpStatusCode status = exchange.getResponse().getStatusCode();

            Timer.builder("gateway.request.duration")
                    .tag("method", method)
                    .tag("path", normalizePath(path))
                    .tag("status", status != null ? String.valueOf(status.value()) : "0")
                    .register(meterRegistry)
                    .record(duration, TimeUnit.NANOSECONDS);

            return Mono.empty();
        });

        return chain.filter(exchange);
    }

    /**
     * Normalizes a request path for metric cardinality control.
     *
     * <p>Replaces path segments that look like IDs (UUIDs, numeric IDs) with
     * a placeholder to prevent metric explosion from high-cardinality paths.
     *
     * @param path the raw request path
     * @return the normalized path suitable for metric tagging
     */
    String normalizePath(final String path) {
        if (path == null) {
            return "/";
        }
        // Replace UUID segments
        String normalized = path.replaceAll(
                "[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}",
                "{id}");
        // Replace pure numeric segments
        normalized = normalized.replaceAll("/\\d+(/|$)", "/{id}$1");
        return normalized;
    }

    @Override
    public int getOrder() {
        return -3;
    }
}
