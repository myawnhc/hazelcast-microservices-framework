package com.theyawns.ecommerce.gateway.config;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.web.server.ServerHttpSecurity;
import org.springframework.security.web.server.SecurityWebFilterChain;

/**
 * Security configuration for the API Gateway (reactive/WebFlux).
 *
 * <p>Provides two mutually exclusive security configurations based on the
 * {@code framework.security.enabled} property:
 *
 * <ul>
 *   <li><strong>Enabled ({@code true})</strong>: Validates JWT Bearer tokens on all
 *       non-public endpoints. Actuator endpoints remain publicly accessible for
 *       health checks and metrics scraping.</li>
 *   <li><strong>Disabled ({@code false} or absent)</strong>: Permits all requests
 *       without authentication, preserving backward compatibility.</li>
 * </ul>
 *
 * <p>When security is enabled, JWT decoder configuration is provided by Spring Boot's
 * native properties:
 * <pre>{@code
 * spring:
 *   security:
 *     oauth2:
 *       resourceserver:
 *         jwt:
 *           issuer-uri: https://your-issuer.example.com
 * }</pre>
 *
 * <p>CORS is delegated to Spring Cloud Gateway's global CORS configuration
 * defined in {@code application.yml}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@Configuration
public class GatewaySecurityConfig {

    private static final Logger logger = LoggerFactory.getLogger(GatewaySecurityConfig.class);

    /**
     * Creates a JWT-secured reactive {@link SecurityWebFilterChain}.
     *
     * <p>Activates only when {@code framework.security.enabled=true}.
     * Permits actuator endpoints for health checks and Prometheus scraping,
     * and requires authenticated JWT Bearer tokens for all other routes.
     *
     * @param http the reactive {@link ServerHttpSecurity} builder
     * @return the configured reactive security filter chain
     */
    @Bean
    @ConditionalOnProperty(name = "framework.security.enabled", havingValue = "true")
    public SecurityWebFilterChain jwtSecurityWebFilterChain(final ServerHttpSecurity http) {
        logger.info("Configuring JWT-secured reactive SecurityWebFilterChain");

        http
                .csrf(ServerHttpSecurity.CsrfSpec::disable)
                .cors(Customizer.withDefaults())
                .authorizeExchange(exchanges -> exchanges
                        .pathMatchers("/actuator/**").permitAll()
                        .anyExchange().authenticated()
                )
                .oauth2ResourceServer(oauth2 -> oauth2.jwt(Customizer.withDefaults()));

        return http.build();
    }

    /**
     * Creates a permit-all reactive {@link SecurityWebFilterChain}.
     *
     * <p>Activates when {@code framework.security.enabled=false} or
     * the property is absent (default). Permits all requests without
     * authentication, preserving backward-compatible open-by-default behavior.
     *
     * @param http the reactive {@link ServerHttpSecurity} builder
     * @return the configured reactive security filter chain
     */
    @Bean
    @ConditionalOnProperty(name = "framework.security.enabled", havingValue = "false", matchIfMissing = true)
    public SecurityWebFilterChain permitAllSecurityWebFilterChain(final ServerHttpSecurity http) {
        logger.info("Configuring permit-all reactive SecurityWebFilterChain (security disabled)");

        http
                .csrf(ServerHttpSecurity.CsrfSpec::disable)
                .cors(Customizer.withDefaults())
                .authorizeExchange(exchanges -> exchanges
                        .anyExchange().permitAll()
                );

        return http.build();
    }
}
