package com.theyawns.ecommerce.gateway.error;

import java.net.ConnectException;
import java.util.concurrent.TimeoutException;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.datatype.jsr310.JavaTimeModule;
import com.theyawns.ecommerce.gateway.filter.CorrelationIdFilter;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.web.reactive.error.ErrorWebExceptionHandler;
import org.springframework.core.annotation.Order;
import org.springframework.core.io.buffer.DataBuffer;
import org.springframework.http.HttpStatus;
import org.springframework.http.MediaType;
import org.springframework.http.server.reactive.ServerHttpResponse;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ResponseStatusException;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

/**
 * Global error handler for the API gateway.
 *
 * <p>Intercepts all unhandled exceptions and returns consistent JSON error
 * responses. Runs at {@code @Order(-2)}, before Spring Boot's default error
 * handler at -1.
 *
 * <p>Exception mapping with cause chain walking:
 * <ul>
 *   <li>{@link ConnectException} &rarr; 503 SERVICE_UNAVAILABLE</li>
 *   <li>{@link TimeoutException} &rarr; 504 GATEWAY_TIMEOUT</li>
 *   <li>CallNotPermittedException (Resilience4j) &rarr; 503 CIRCUIT_BREAKER_OPEN</li>
 *   <li>{@link ResponseStatusException} &rarr; preserved status</li>
 *   <li>All others &rarr; 502 BAD_GATEWAY</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Component
@Order(-2)
public class GatewayErrorHandler implements ErrorWebExceptionHandler {

    private static final Logger logger = LoggerFactory.getLogger(GatewayErrorHandler.class);
    private static final String CALL_NOT_PERMITTED = "CallNotPermittedException";

    private final ObjectMapper objectMapper;

    /**
     * Creates a new gateway error handler with a default ObjectMapper.
     */
    public GatewayErrorHandler() {
        this.objectMapper = new ObjectMapper();
        this.objectMapper.registerModule(new JavaTimeModule());
    }

    /**
     * Creates a new gateway error handler with the given ObjectMapper.
     *
     * @param objectMapper the ObjectMapper for JSON serialization
     */
    GatewayErrorHandler(final ObjectMapper objectMapper) {
        this.objectMapper = objectMapper;
    }

    @Override
    public Mono<Void> handle(final ServerWebExchange exchange, final Throwable ex) {
        final HttpStatus status = resolveStatus(ex);
        final String errorCode = resolveErrorCode(ex);
        final String message = resolveMessage(ex, status);
        final String correlationId = exchange.getAttribute(CorrelationIdFilter.CORRELATION_ID_ATTR);
        final String path = exchange.getRequest().getPath().value();

        logger.error("Gateway error [{}] {} {} - correlationId={}: {}",
                status.value(), exchange.getRequest().getMethod(), path,
                correlationId, ex.getMessage(), ex);

        final GatewayErrorResponse errorResponse = new GatewayErrorResponse(
                status.value(), errorCode, message, correlationId, path);

        final ServerHttpResponse response = exchange.getResponse();
        response.setStatusCode(status);
        response.getHeaders().setContentType(MediaType.APPLICATION_JSON);

        try {
            final byte[] bytes = objectMapper.writeValueAsBytes(errorResponse);
            final DataBuffer buffer = response.bufferFactory().wrap(bytes);
            return response.writeWith(Mono.just(buffer));
        } catch (final JsonProcessingException e) {
            logger.error("Failed to serialize error response", e);
            return response.setComplete();
        }
    }

    /**
     * Resolves the HTTP status from the exception, walking the cause chain.
     *
     * @param ex the exception to resolve
     * @return the resolved HTTP status
     */
    HttpStatus resolveStatus(final Throwable ex) {
        Throwable current = ex;
        while (current != null) {
            if (current instanceof ConnectException) {
                return HttpStatus.SERVICE_UNAVAILABLE;
            }
            if (current instanceof TimeoutException) {
                return HttpStatus.GATEWAY_TIMEOUT;
            }
            if (CALL_NOT_PERMITTED.equals(current.getClass().getSimpleName())) {
                return HttpStatus.SERVICE_UNAVAILABLE;
            }
            if (current instanceof ResponseStatusException) {
                return HttpStatus.valueOf(((ResponseStatusException) current).getStatusCode().value());
            }
            current = current.getCause();
        }
        return HttpStatus.BAD_GATEWAY;
    }

    /**
     * Resolves the machine-readable error code from the exception.
     *
     * @param ex the exception to resolve
     * @return the error code
     */
    String resolveErrorCode(final Throwable ex) {
        Throwable current = ex;
        while (current != null) {
            if (current instanceof ConnectException) {
                return "SERVICE_UNAVAILABLE";
            }
            if (current instanceof TimeoutException) {
                return "GATEWAY_TIMEOUT";
            }
            if (CALL_NOT_PERMITTED.equals(current.getClass().getSimpleName())) {
                return "CIRCUIT_BREAKER_OPEN";
            }
            if (current instanceof ResponseStatusException) {
                return HttpStatus.valueOf(((ResponseStatusException) current).getStatusCode().value())
                        .name();
            }
            current = current.getCause();
        }
        return "BAD_GATEWAY";
    }

    /**
     * Resolves a human-readable message from the exception.
     *
     * @param ex the exception to resolve
     * @param status the resolved HTTP status
     * @return the error message
     */
    String resolveMessage(final Throwable ex, final HttpStatus status) {
        Throwable current = ex;
        while (current != null) {
            if (current instanceof ConnectException) {
                return "Downstream service is unavailable";
            }
            if (current instanceof TimeoutException) {
                return "Downstream service did not respond in time";
            }
            if (CALL_NOT_PERMITTED.equals(current.getClass().getSimpleName())) {
                return "Circuit breaker is open â€” downstream service is temporarily unavailable";
            }
            if (current instanceof ResponseStatusException) {
                return ((ResponseStatusException) current).getReason() != null
                        ? ((ResponseStatusException) current).getReason()
                        : status.getReasonPhrase();
            }
            current = current.getCause();
        }
        return "An unexpected gateway error occurred";
    }
}
