package com.theyawns.ecommerce.gateway.filter;

import java.util.Map;

import com.hazelcast.map.EntryProcessor;

/**
 * Hazelcast EntryProcessor implementing a token bucket rate limiter.
 *
 * <p>Each entry in the rate limit IMap stores a {@code long[2]} array:
 * <ul>
 *   <li>Index 0: available tokens (scaled by 1000 for sub-token precision)</li>
 *   <li>Index 1: last refill timestamp in epoch milliseconds</li>
 * </ul>
 *
 * <p>The processor atomically refills tokens based on elapsed time, then
 * attempts to consume one token. Returns {@code true} if the request is
 * allowed, {@code false} if the bucket is exhausted.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
public class TokenBucketProcessor implements EntryProcessor<String, long[], Boolean> {

    private static final long serialVersionUID = 1L;

    /** Precision scale factor — stores tokens * 1000 to avoid floating point. */
    private static final long SCALE = 1000L;

    /** Maximum tokens in the bucket. */
    private final long maxTokens;

    /** Tokens added per millisecond (scaled). */
    private final long refillPerMs;

    /**
     * Creates a token bucket processor.
     *
     * @param maxTokens maximum tokens (bucket capacity) — also the per-second rate
     * @param refillPerSecond tokens refilled per second (typically equals maxTokens)
     */
    public TokenBucketProcessor(final long maxTokens, final long refillPerSecond) {
        this.maxTokens = maxTokens;
        this.refillPerMs = (refillPerSecond * SCALE) / 1000L;
    }

    @Override
    public Boolean process(final Map.Entry<String, long[]> entry) {
        final long now = System.currentTimeMillis();
        long[] state = entry.getValue();

        if (state == null) {
            // New bucket: start full, consume one token
            state = new long[]{(maxTokens - 1) * SCALE, now};
            entry.setValue(state);
            return true;
        }

        // Refill tokens based on elapsed time
        final long elapsed = now - state[1];
        final long refilled = elapsed * refillPerMs / SCALE;
        long tokens = Math.min(state[0] + refilled, maxTokens * SCALE);

        if (tokens >= SCALE) {
            // Consume one token
            state[0] = tokens - SCALE;
            state[1] = now;
            entry.setValue(state);
            return true;
        }

        // Bucket exhausted — reject
        return false;
    }
}
