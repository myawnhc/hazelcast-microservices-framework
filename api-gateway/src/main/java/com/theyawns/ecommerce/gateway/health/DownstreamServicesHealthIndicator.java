package com.theyawns.ecommerce.gateway.health;

import java.time.Duration;
import java.util.LinkedHashMap;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.boot.actuate.health.Health;
import org.springframework.boot.actuate.health.ReactiveHealthIndicator;
import org.springframework.stereotype.Component;
import org.springframework.web.reactive.function.client.WebClient;
import reactor.core.publisher.Flux;
import reactor.core.publisher.Mono;

/**
 * Aggregated health indicator that checks the health of all downstream services.
 *
 * <p>Queries each service's {@code /actuator/health} endpoint and reports their
 * individual statuses as detail entries. The overall health is UP only when all
 * downstream services are reachable and healthy.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Component("downstreamServices")
public class DownstreamServicesHealthIndicator implements ReactiveHealthIndicator {

    private static final Logger logger = LoggerFactory.getLogger(DownstreamServicesHealthIndicator.class);

    private final WebClient webClient;
    private final Map<String, String> serviceUrls;
    private final Duration timeout;

    /**
     * Creates a new health indicator with injected service URLs and timeout.
     *
     * @param accountServiceUrl the account service base URL
     * @param inventoryServiceUrl the inventory service base URL
     * @param orderServiceUrl the order service base URL
     * @param paymentServiceUrl the payment service base URL
     * @param timeout the timeout for health check requests
     */
    @Autowired
    public DownstreamServicesHealthIndicator(
            @Value("${ACCOUNT_SERVICE_URL:http://localhost:8081}") final String accountServiceUrl,
            @Value("${INVENTORY_SERVICE_URL:http://localhost:8082}") final String inventoryServiceUrl,
            @Value("${ORDER_SERVICE_URL:http://localhost:8083}") final String orderServiceUrl,
            @Value("${PAYMENT_SERVICE_URL:http://localhost:8084}") final String paymentServiceUrl,
            @Value("${gateway.health.timeout:3s}") final Duration timeout) {
        this(WebClient.create(), accountServiceUrl, inventoryServiceUrl,
                orderServiceUrl, paymentServiceUrl, timeout);
    }

    /**
     * Creates a new health indicator with an explicit WebClient (for testing).
     *
     * @param webClient the WebClient to use for health checks
     * @param accountServiceUrl the account service base URL
     * @param inventoryServiceUrl the inventory service base URL
     * @param orderServiceUrl the order service base URL
     * @param paymentServiceUrl the payment service base URL
     * @param timeout the timeout for health check requests
     */
    DownstreamServicesHealthIndicator(final WebClient webClient,
                                      final String accountServiceUrl,
                                      final String inventoryServiceUrl,
                                      final String orderServiceUrl,
                                      final String paymentServiceUrl,
                                      final Duration timeout) {
        this.webClient = webClient;
        this.timeout = timeout;
        this.serviceUrls = new LinkedHashMap<>();
        this.serviceUrls.put("account-service", accountServiceUrl);
        this.serviceUrls.put("inventory-service", inventoryServiceUrl);
        this.serviceUrls.put("order-service", orderServiceUrl);
        this.serviceUrls.put("payment-service", paymentServiceUrl);
    }

    @Override
    public Mono<Health> health() {
        return Flux.fromIterable(serviceUrls.entrySet())
                .flatMap(entry -> checkService(entry.getKey(), entry.getValue()))
                .collectMap(ServiceHealth::name, ServiceHealth::status)
                .map(this::buildHealth);
    }

    private Mono<ServiceHealth> checkService(final String name, final String baseUrl) {
        return webClient.get()
                .uri(baseUrl + "/actuator/health")
                .retrieve()
                .bodyToMono(HealthResponse.class)
                .timeout(timeout)
                .map(response -> new ServiceHealth(name,
                        "UP".equalsIgnoreCase(response.status()) ? "UP" : response.status()))
                .onErrorResume(ex -> {
                    logger.warn("Health check failed for {}: {}", name, ex.getMessage());
                    return Mono.just(new ServiceHealth(name, "DOWN"));
                });
    }

    private Health buildHealth(final Map<String, String> statuses) {
        final Health.Builder builder = new Health.Builder();

        final boolean allUp = statuses.values().stream().allMatch("UP"::equals);
        if (allUp) {
            builder.up();
        } else {
            builder.down();
        }

        statuses.forEach(builder::withDetail);
        return builder.build();
    }

    /**
     * Internal record for service health check result.
     */
    private record ServiceHealth(String name, String status) {
    }

    /**
     * Internal record for deserializing the actuator health response.
     */
    private record HealthResponse(String status) {
    }
}
