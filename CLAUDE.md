# Claude Code Rules for Hazelcast Microservices Framework

## Project Context

This is a **Hazelcast-based event sourcing microservices framework** with a clean, educational implementation.

### Core Principles
1. **Event Sourcing First**: Events are the source of truth, not database state
2. **Domain-Agnostic Framework**: Core framework should work for any domain
3. **Educational Quality**: Code should be exemplary for blog posts and demos
4. **Production-Ready Patterns**: Follow enterprise best practices
5. **Test-Driven**: >80% test coverage required

---

## Technology Stack

### Required Versions
- **Java**: 17 or higher
- **Spring Boot**: 3.2.x (latest stable)
- **Hazelcast**: 5.6.0 (Community Edition default, Enterprise Edition optional)
- **Maven**: 3.8+

### Hazelcast Edition Strategy

**Core Principle**: Community Edition is the default. Enterprise features are optional enhancements.

#### Default Configuration (Community Edition)
The framework MUST work fully with Community Edition only. This is:
- The default configuration
- Required for demos and tutorials
- The expected setup for most users

**Community Edition Features** (always available):
- ✅ FlakeIdGenerator (for sequence generation)
- ✅ IMap, ITopic, Jet Pipeline
- ✅ Event Journal
- ✅ Entry Processors
- ✅ Near Cache

#### Optional Enhancements (Enterprise Edition)
Enterprise features MAY be used for optional capabilities that enhance:
- **High Availability**: CP Subsystem for stronger consistency guarantees
- **Resilience**: Hot Restart, Rolling Upgrades
- **Security**: TLS, Authentication, Authorization
- **Performance**: HD Memory
- **AI/ML**: Vector Store (similarity search, recommendations)

**Implementation Rules for Enterprise Features**:
1. **Always Optional**: Code must detect and gracefully handle absence of Enterprise
2. **Feature Flags**: Use configuration to enable/disable Enterprise features
3. **Fallback Required**: Every Enterprise feature must have a Community fallback
4. **Clear Documentation**: Mark Enterprise-only features in JavaDoc

**Example Pattern**:
```java
@Value("${hazelcast.enterprise.cp-subsystem.enabled:false}")
private boolean cpSubsystemEnabled;

public long getNextSequence() {
    if (cpSubsystemEnabled) {
        // Enterprise: Use CP AtomicLong for strong consistency
        return cpSubsystem.getAtomicLong("sequence").incrementAndGet();
    } else {
        // Community: Use FlakeIdGenerator (default)
        return flakeIdGenerator.newId();
    }
}
```

### Dependencies
```xml
<!-- Always use these exact dependency patterns -->
<dependency>
    <groupId>com.hazelcast</groupId>
    <artifactId>hazelcast</artifactId>
    <version>5.6.0</version>
</dependency>
<dependency>
    <groupId>com.hazelcast</groupId>
    <artifactId>hazelcast-spring</artifactId>
    <version>5.6.0</version>
</dependency>
```

---

## Code Standards

### Package Structure
**Base package**: `com.theyawns.framework`

**Modules**:
- `com.theyawns.framework.event` - Event abstractions
- `com.theyawns.framework.domain` - Domain object interfaces
- `com.theyawns.framework.store` - Event store
- `com.theyawns.framework.view` - Materialized views
- `com.theyawns.framework.pipeline` - Jet pipeline
- `com.theyawns.framework.controller` - Main controller
- `com.theyawns.framework.config` - Spring configuration

**eCommerce services**:
- `com.theyawns.ecommerce.account.*`
- `com.theyawns.ecommerce.inventory.*`
- `com.theyawns.ecommerce.order.*`
- `com.theyawns.ecommerce.common.*` - Shared

### Naming Conventions
- **Events**: `{Action}{Entity}Event` (e.g., `CustomerCreatedEvent`, `StockReservedEvent`)
- **Domain Objects**: Simple nouns (e.g., `Customer`, `Product`, `Order`)
- **Services**: `{Entity}Service` (e.g., `AccountService`, `InventoryService`)
- **Controllers**: `{Entity}Controller` (e.g., `AccountController`)
- **Tests**: `{ClassName}Test` for unit, `{ClassName}IntegrationTest` for integration

### Code Style
- **Line length**: 120 characters max
- **Indentation**: 4 spaces (no tabs)
- **Braces**: Always use, even for single-line blocks
- **Imports**: No wildcards, organize by: java, javax, org, com
- **Final**: Use `final` for parameters and local variables when possible

---

## Documentation Requirements

### Every Public Class/Interface Must Have:
```java
/**
 * Brief description of what this class does.
 * 
 * <p>More detailed explanation if needed, including:
 * <ul>
 *   <li>Key responsibilities</li>
 *   <li>Usage examples</li>
 *   <li>Important constraints</li>
 * </ul>
 * 
 * @param <T> Type parameter description
 * @author Generated by Claude Code
 * @since 1.0
 */
```

### Every Public Method Must Have:
```java
/**
 * Brief description of what this method does.
 * 
 * <p>Additional details if behavior is complex.
 * 
 * @param paramName Description of parameter and constraints
 * @return Description of return value
 * @throws ExceptionType When this exception occurs
 */
```

### Field Documentation:
```java
/**
 * Brief description of field purpose.
 */
private final String fieldName;
```

---

## Testing Requirements

### Unit Tests (>80% Coverage Required)
- **Location**: `src/test/java` mirroring `src/main/java` structure
- **Framework**: JUnit 5, Mockito
- **Naming**: `{ClassName}Test.java`
- **Structure**:
  ```java
  @DisplayName("ClassName - Description")
  class ClassNameTest {
      
      @BeforeEach
      void setUp() {
          // Test setup
      }
      
      @Test
      @DisplayName("should do something when condition")
      void shouldDoSomethingWhenCondition() {
          // Arrange
          
          // Act
          
          // Assert
      }
  }
  ```

### Integration Tests
- **Location**: `src/test/java` with `IntegrationTest` suffix
- **Framework**: Spring Boot Test, Testcontainers
- **Annotations**:
  ```java
  @SpringBootTest
  @Testcontainers
  class ServiceIntegrationTest {
      @Container
      static GenericContainer<?> hazelcast = 
          new GenericContainer<>("hazelcast/hazelcast:5.6.0")
              .withExposedPorts(5701);
  }
  ```

### Test Principles
- **Arrange-Act-Assert**: Clear three-part structure
- **One assertion per test**: Focus on single behavior
- **Descriptive names**: Test name explains what's being tested
- **No production dependencies**: Use mocks/stubs for external dependencies
- **Fast**: Unit tests should run in milliseconds

---

## Event Sourcing Patterns

### Event Design
```java
public class CustomerCreatedEvent extends DomainEvent<Customer, String> {
    
    // Event-specific fields
    private String email;
    private String name;
    private String address;
    
    // Constructor sets event type
    public CustomerCreatedEvent(String customerId, String email, String name, String address) {
        super();
        this.key = customerId;
        this.eventType = "CustomerCreated";
        this.email = email;
        this.name = name;
        this.address = address;
    }
    
    // Apply event to domain object
    @Override
    public GenericRecord apply(GenericRecord customerRecord) {
        // Create or update customer record
        return GenericRecordBuilder.compact("Customer")
            .setString("customerId", key)
            .setString("email", email)
            .setString("name", name)
            .setString("address", address)
            .setString("status", "ACTIVE")
            .build();
    }
    
    // Serialize to GenericRecord for storage
    @Override
    public GenericRecord toGenericRecord() {
        return GenericRecordBuilder.compact("CustomerCreatedEvent")
            .setString("eventId", eventId)
            .setString("eventType", eventType)
            .setString("key", key)
            .setString("email", email)
            .setString("name", name)
            .setString("address", address)
            // Include all metadata
            .setString("correlationId", correlationId)
            .setLong("timestamp", timestamp.toEpochMilli())
            .build();
    }
}
```

### Service Pattern
```java
@Service
public class AccountService {
    
    private final EventSourcingController<Customer, String, DomainEvent<Customer, String>> controller;
    
    @Autowired
    public AccountService(EventSourcingController<Customer, String, DomainEvent<Customer, String>> controller) {
        this.controller = controller;
    }
    
    public CompletableFuture<Customer> createCustomer(CustomerDTO dto) {
        // Create event
        CustomerCreatedEvent event = new CustomerCreatedEvent(
            UUID.randomUUID().toString(),
            dto.getEmail(),
            dto.getName(),
            dto.getAddress()
        );
        
        // Handle event (triggers pipeline)
        return controller.handleEvent(event, UUID.randomUUID())
            .thenApply(completion -> {
                // Retrieve from materialized view
                return getCustomer(event.getKey()).orElseThrow();
            });
    }
    
    public Optional<Customer> getCustomer(String customerId) {
        // Read from materialized view (fast!)
        GenericRecord gr = controller.getViewMap().get(customerId);
        if (gr == null) return Optional.empty();
        
        return Optional.of(Customer.fromGenericRecord(gr));
    }
}
```

### REST Controller Pattern
```java
@RestController
@RequestMapping("/api/customers")
@Tag(name = "Customer Management")
public class AccountController {
    
    private final AccountService accountService;
    
    @PostMapping
    @Operation(summary = "Create customer")
    public CompletableFuture<ResponseEntity<CustomerDTO>> createCustomer(
        @Valid @RequestBody CustomerDTO dto
    ) {
        return accountService.createCustomer(dto)
            .thenApply(customer -> ResponseEntity
                .status(HttpStatus.CREATED)
                .body(customer.toDTO())
            );
    }
    
    @GetMapping("/{customerId}")
    @Operation(summary = "Get customer by ID")
    public ResponseEntity<CustomerDTO> getCustomer(
        @PathVariable String customerId
    ) {
        return accountService.getCustomer(customerId)
            .map(customer -> ResponseEntity.ok(customer.toDTO()))
            .orElse(ResponseEntity.notFound().build());
    }
}
```

---

## Configuration Patterns

### Spring Boot Application
```java
@SpringBootApplication
@EnableHazelcastRepositories  // If using Spring Data Hazelcast
public class AccountServiceApplication {
    
    public static void main(String[] args) {
        SpringApplication.run(AccountServiceApplication.class, args);
    }
    
    @Bean
    public HazelcastInstance hazelcastInstance() {
        Config config = new Config();
        config.setClusterName("ecommerce-demo");
        
        // Enable event journal for pending events
        config.getMapConfig("*_PENDING")
            .getEventJournalConfig()
            .setEnabled(true)
            .setCapacity(10000);
        
        return Hazelcast.newHazelcastInstance(config);
    }
}
```

### application.yml Pattern
```yaml
spring:
  application:
    name: account-service

server:
  port: 8081

management:
  endpoints:
    web:
      exposure:
        include: health,prometheus,metrics
  metrics:
    export:
      prometheus:
        enabled: true

logging:
  level:
    com.theyawns: DEBUG
    com.hazelcast: INFO
```

---

## Error Handling

### Exception Hierarchy
```java
// Framework exceptions
public class EventProcessingException extends RuntimeException {
    private final String eventId;
    private final String eventType;
    
    public EventProcessingException(String message, String eventId, String eventType) {
        super(message);
        this.eventId = eventId;
        this.eventType = eventType;
    }
}

// Service exceptions
public class CustomerNotFoundException extends RuntimeException {
    private final String customerId;
    
    public CustomerNotFoundException(String customerId) {
        super("Customer not found: " + customerId);
        this.customerId = customerId;
    }
}
```

### Global Exception Handler
```java
@RestControllerAdvice
public class GlobalExceptionHandler {
    
    @ExceptionHandler(CustomerNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleCustomerNotFound(CustomerNotFoundException ex) {
        return ResponseEntity
            .status(HttpStatus.NOT_FOUND)
            .body(new ErrorResponse(ex.getMessage(), "CUSTOMER_NOT_FOUND"));
    }
    
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleGeneral(Exception ex) {
        logger.error("Unexpected error", ex);
        return ResponseEntity
            .status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(new ErrorResponse("Internal server error", "INTERNAL_ERROR"));
    }
}
```

---

## Logging Standards

### Use SLF4J with Logback
```java
private static final Logger logger = LoggerFactory.getLogger(ClassName.class);

// Log levels:
logger.trace("Detailed trace information"); // Very verbose
logger.debug("Debug information");          // Development
logger.info("Informational messages");      // Important events
logger.warn("Warning messages");            // Potential issues
logger.error("Error messages", exception);  // Actual errors
```

### Structured Logging
```java
// Include correlation ID in MDC
MDC.put("correlationId", correlationId);
try {
    logger.info("Processing event: {} for key: {}", eventType, key);
    // ... processing
} finally {
    MDC.remove("correlationId");
}
```

### Log Message Guidelines
- ✅ DO: Use parameterized messages: `logger.info("Customer created: {}", customerId)`
- ❌ DON'T: Use string concatenation: `logger.info("Customer created: " + customerId)`
- ✅ DO: Log exceptions with context: `logger.error("Failed to create customer: {}", customerId, exception)`
- ❌ DON'T: Log and rethrow: Log OR rethrow, not both

---

## Performance Guidelines

### Hazelcast Best Practices
1. **Partition Key**: Always use partition key for IMap operations
   ```java
   // Good: Partitioned by customer ID
   viewMap.executeOnKey(customerId, new UpdateViewEntryProcessor(event));
   
   // Bad: No partition key (broadcasts to all nodes)
   viewMap.executeOnEntries(new UpdateAllProcessor());
   ```

2. **Batch Operations**: Use batch operations when possible
   ```java
   // Good: Batch read
   Map<String, Customer> customers = viewMap.getAll(customerIds);
   
   // Bad: Multiple individual reads
   for (String id : customerIds) {
       Customer c = viewMap.get(id);
   }
   ```

3. **Entry Processor**: Use for atomic updates
   ```java
   viewMap.executeOnKey(key, new UpdateViewEntryProcessor(event));
   ```

### Jet Pipeline Performance
- Keep pipeline stages stateless when possible
- Use `ServiceFactory.sharedService()` for expensive resources
- Avoid blocking operations in pipeline stages
- Use appropriate parallelism settings

---

## Common Pitfalls to Avoid

### ❌ DON'T
1. **Use blocking operations in Jet pipeline**
   ```java
   // BAD
   .map(event -> {
       Thread.sleep(1000); // NEVER block pipeline!
       return event;
   })
   ```

2. **Mutate events after creation**
   ```java
   // BAD
   event.setTimestamp(newTime); // Events should be immutable!
   ```

3. **Catch and swallow exceptions**
   ```java
   // BAD
   try {
       process(event);
   } catch (Exception e) {
       // Silent failure - bad!
   }
   ```

4. **Use synchronous service calls in event handlers**
   ```java
   // BAD - defeats purpose of materialized views!
   Customer customer = restTemplate.getForObject(accountServiceUrl + customerId, Customer.class);
   ```

5. **Forget to set event metadata**
   ```java
   // BAD
   DomainEvent event = new OrderCreatedEvent(...);
   controller.handleEvent(event); // Missing correlation ID!
   ```

### ✅ DO
1. **Use async operations**
2. **Make events immutable**
3. **Log errors and propagate exceptions**
4. **Use materialized views, not service calls**
5. **Always set correlation IDs**

---

## Code Review Checklist

Before committing, verify:

### Functionality
- [ ] Code compiles without warnings
- [ ] All tests pass
- [ ] New tests written (>80% coverage)
- [ ] Edge cases handled
- [ ] Error handling implemented

### Documentation
- [ ] JavaDoc on all public classes/methods
- [ ] Inline comments for complex logic
- [ ] README updated if needed
- [ ] API documentation updated

### Code Quality
- [ ] No code duplication
- [ ] Methods are focused (single responsibility)
- [ ] No magic numbers or strings (use constants)
- [ ] Consistent naming conventions
- [ ] Proper exception handling

### Hazelcast Specific
- [ ] Works with Community Edition (default config)
- [ ] Enterprise features are optional with graceful fallback
- [ ] Partition keys used correctly
- [ ] Event journal enabled for pending maps
- [ ] No blocking in pipeline stages

### Testing
- [ ] Unit tests cover happy path
- [ ] Unit tests cover error cases
- [ ] Integration tests for key scenarios
- [ ] Tests use descriptive names
- [ ] No test dependencies on other tests

---

## Git Commit Messages

### Format
```
<type>(<scope>): <subject>

<body>

<footer>
```

### Types
- `feat`: New feature
- `fix`: Bug fix
- `docs`: Documentation changes
- `test`: Test additions/changes
- `refactor`: Code refactoring
- `style`: Code style changes (formatting)
- `chore`: Build/dependency updates

### Examples
```
feat(framework): implement EventSourcingController with handleEvent method

- Add correlation ID support
- Add saga metadata fields
- Add metrics collection
- Implement CompletableFuture for async responses

Closes #15
```

```
test(account): add integration tests for customer creation flow

- Test happy path
- Test validation errors
- Test event publication
- Test view updates

Coverage now at 85%
```

---

## Implementation Order

### Day 1: Core Abstractions
Focus on interfaces and base classes without implementation complexity.

### Day 2-3: Event Store & Views
Implement storage layer, ensure tests pass before moving on.

### Day 4: Pipeline
Most complex component - take time to get it right.

### Day 5: Controller & Config
Wire everything together with Spring Boot.

### Week 2: Services
One service at a time, with full tests before moving to next.

### Week 3: Integration
Docker, end-to-end tests, documentation.

---

## Questions to Ask Before Implementation

When starting a new component:
1. What interfaces does this implement?
2. What are the dependencies?
3. What are the failure modes?
4. How will this be tested?
5. What metrics should be collected?

---

## Success Criteria

A component is complete when:
- [ ] Code compiles
- [ ] All tests pass (>80% coverage)
- [ ] Documentation complete
- [ ] Code reviewed against checklist
- [ ] Committed with proper message
- [ ] Integration tested with dependent components

---

## Reference Implementation Plan

See: `docs/implementation/phase1-implementation-plan.md`

This provides day-by-day breakdown, code templates, and detailed requirements.

---

## Getting Help

If uncertain about:
- **Architecture decisions**: Refer to `docs/architecture/`
- **Requirements**: Refer to `docs/requirements/`
- **Design patterns**: Refer to `docs/design/`
- **Hazelcast APIs**: Check Hazelcast 5.6 documentation
- **Spring Boot**: Check Spring Boot 3.2 documentation

---

Last updated: 2026-01-24
Version: 1.1
