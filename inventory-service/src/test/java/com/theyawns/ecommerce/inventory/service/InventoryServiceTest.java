package com.theyawns.ecommerce.inventory.service;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.common.events.ProductCreatedEvent;
import com.theyawns.ecommerce.common.events.StockReleasedEvent;
import com.theyawns.ecommerce.common.events.StockReservedEvent;
import com.theyawns.ecommerce.inventory.domain.ProductViewUpdater;
import com.theyawns.framework.view.HazelcastViewStore;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.math.BigDecimal;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Unit tests for InventoryService.
 * Tests the view updater logic directly without the full pipeline.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@DisplayName("InventoryService - View Updater Logic")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class InventoryServiceTest {

    private static final String DOMAIN_NAME = "ProductTest";

    private HazelcastInstance hazelcast;
    private HazelcastViewStore<String> viewStore;
    private ProductViewUpdater viewUpdater;

    @BeforeAll
    void setUpHazelcast() {
        Config config = new Config();
        config.setClusterName("inventory-service-test-" + System.currentTimeMillis());
        hazelcast = Hazelcast.newHazelcastInstance(config);
        viewStore = new HazelcastViewStore<>(hazelcast, DOMAIN_NAME);
        viewUpdater = new ProductViewUpdater(viewStore);
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void clearView() {
        viewStore.clear();
    }

    @Nested
    @DisplayName("Create product flow")
    class CreateProductTests {

        @Test
        @DisplayName("should create product view from event")
        void shouldCreateProductViewFromEvent() {
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent event = new ProductCreatedEvent(
                    productId,
                    "SKU-001",
                    "Test Product",
                    new BigDecimal("29.99"),
                    100
            );
            event.setDescription("A test product");
            event.setCategory("Electronics");

            GenericRecord eventRecord = event.toGenericRecord();
            GenericRecord result = viewUpdater.update(eventRecord);

            assertNotNull(result);
            assertEquals(productId, result.getString("productId"));
            assertEquals("SKU-001", result.getString("sku"));
            assertEquals("Test Product", result.getString("name"));
            assertEquals("29.99", result.getString("price"));
            assertEquals(100, result.getInt32("quantityOnHand"));
            assertEquals(0, result.getInt32("quantityReserved"));
            assertEquals(Product.Status.ACTIVE.name(), result.getString("status"));

            // Verify stored in view
            Optional<GenericRecord> stored = viewStore.get(productId);
            assertTrue(stored.isPresent());
            assertEquals("SKU-001", stored.get().getString("sku"));
        }

        @Test
        @DisplayName("should create product with zero initial quantity")
        void shouldCreateProductWithZeroInitialQuantity() {
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent event = new ProductCreatedEvent(
                    productId,
                    "SKU-ZERO",
                    "Zero Stock Product",
                    new BigDecimal("9.99"),
                    0
            );

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertNotNull(result);
            assertEquals(0, result.getInt32("quantityOnHand"));
            assertEquals(0, result.getInt32("quantityReserved"));
        }
    }

    @Nested
    @DisplayName("Stock reservation flow")
    class StockReservationTests {

        @Test
        @DisplayName("should reserve stock from event")
        void shouldReserveStockFromEvent() {
            // First create a product
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent createEvent = new ProductCreatedEvent(
                    productId,
                    "SKU-RES",
                    "Reservable Product",
                    new BigDecimal("19.99"),
                    50
            );
            viewUpdater.update(createEvent.toGenericRecord());

            // Now reserve stock
            StockReservedEvent reserveEvent = new StockReservedEvent(
                    productId,
                    10,
                    "ORDER-001"
            );
            GenericRecord result = viewUpdater.update(reserveEvent.toGenericRecord());

            assertNotNull(result);
            assertEquals(50, result.getInt32("quantityOnHand"));
            assertEquals(10, result.getInt32("quantityReserved"));
        }

        @Test
        @DisplayName("should accumulate multiple reservations")
        void shouldAccumulateMultipleReservations() {
            // Create a product
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent createEvent = new ProductCreatedEvent(
                    productId,
                    "SKU-MULTI",
                    "Multi Reserve Product",
                    new BigDecimal("49.99"),
                    100
            );
            viewUpdater.update(createEvent.toGenericRecord());

            // Reserve stock multiple times
            StockReservedEvent reserveEvent1 = new StockReservedEvent(productId, 20, "ORDER-001");
            viewUpdater.update(reserveEvent1.toGenericRecord());

            StockReservedEvent reserveEvent2 = new StockReservedEvent(productId, 30, "ORDER-002");
            GenericRecord result = viewUpdater.update(reserveEvent2.toGenericRecord());

            assertNotNull(result);
            assertEquals(100, result.getInt32("quantityOnHand"));
            assertEquals(50, result.getInt32("quantityReserved"));
        }

        @Test
        @DisplayName("should fail to reserve stock for non-existent product")
        void shouldFailToReserveStockForNonExistentProduct() {
            String productId = UUID.randomUUID().toString();
            StockReservedEvent reserveEvent = new StockReservedEvent(
                    productId,
                    10,
                    "ORDER-001"
            );

            // Should return null for non-existent product
            GenericRecord result = viewUpdater.update(reserveEvent.toGenericRecord());

            // Update returns null, and view should not have entry
            Optional<GenericRecord> stored = viewStore.get(productId);
            assertFalse(stored.isPresent());
        }
    }

    @Nested
    @DisplayName("Stock release flow")
    class StockReleaseTests {

        @Test
        @DisplayName("should release stock from event")
        void shouldReleaseStockFromEvent() {
            // Create a product and reserve stock
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent createEvent = new ProductCreatedEvent(
                    productId,
                    "SKU-REL",
                    "Releasable Product",
                    new BigDecimal("39.99"),
                    50
            );
            viewUpdater.update(createEvent.toGenericRecord());

            StockReservedEvent reserveEvent = new StockReservedEvent(productId, 20, "ORDER-001");
            viewUpdater.update(reserveEvent.toGenericRecord());

            // Now release stock
            StockReleasedEvent releaseEvent = new StockReleasedEvent(
                    productId,
                    15,
                    "ORDER-001",
                    "Order cancelled"
            );
            GenericRecord result = viewUpdater.update(releaseEvent.toGenericRecord());

            assertNotNull(result);
            assertEquals(50, result.getInt32("quantityOnHand"));
            assertEquals(5, result.getInt32("quantityReserved"));
        }

        @Test
        @DisplayName("should not go below zero when releasing more than reserved")
        void shouldNotGoBelowZeroWhenReleasingMoreThanReserved() {
            // Create a product and reserve stock
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent createEvent = new ProductCreatedEvent(
                    productId,
                    "SKU-OVER",
                    "Over Release Product",
                    new BigDecimal("29.99"),
                    30
            );
            viewUpdater.update(createEvent.toGenericRecord());

            StockReservedEvent reserveEvent = new StockReservedEvent(productId, 10, "ORDER-001");
            viewUpdater.update(reserveEvent.toGenericRecord());

            // Release more than reserved
            StockReleasedEvent releaseEvent = new StockReleasedEvent(
                    productId,
                    25,
                    "ORDER-001",
                    "Full cancellation"
            );
            GenericRecord result = viewUpdater.update(releaseEvent.toGenericRecord());

            assertNotNull(result);
            assertEquals(30, result.getInt32("quantityOnHand"));
            assertEquals(0, result.getInt32("quantityReserved"));
        }

        @Test
        @DisplayName("should fail to release stock for non-existent product")
        void shouldFailToReleaseStockForNonExistentProduct() {
            String productId = UUID.randomUUID().toString();
            StockReleasedEvent releaseEvent = new StockReleasedEvent(
                    productId,
                    10,
                    "ORDER-001",
                    "Cancellation"
            );

            // Should return null for non-existent product
            GenericRecord result = viewUpdater.update(releaseEvent.toGenericRecord());

            // View should not have entry
            Optional<GenericRecord> stored = viewStore.get(productId);
            assertFalse(stored.isPresent());
        }
    }

    @Nested
    @DisplayName("Get product from view")
    class GetProductTests {

        @Test
        @DisplayName("should return product from view")
        void shouldReturnProductFromView() {
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent createEvent = new ProductCreatedEvent(
                    productId,
                    "SKU-GET",
                    "Get Test Product",
                    new BigDecimal("15.99"),
                    25
            );
            viewUpdater.update(createEvent.toGenericRecord());

            Optional<GenericRecord> result = viewStore.get(productId);

            assertTrue(result.isPresent());
            assertEquals("SKU-GET", result.get().getString("sku"));
            assertEquals("Get Test Product", result.get().getString("name"));
            assertEquals(25, result.get().getInt32("quantityOnHand"));
        }

        @Test
        @DisplayName("should return empty for non-existent product")
        void shouldReturnEmptyForNonExistentProduct() {
            Optional<GenericRecord> result = viewStore.get("nonexistent");
            assertFalse(result.isPresent());
        }
    }

    @Nested
    @DisplayName("Product exists check")
    class ProductExistsTests {

        @Test
        @DisplayName("should return true when product exists")
        void shouldReturnTrueWhenProductExists() {
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent createEvent = new ProductCreatedEvent(
                    productId,
                    "SKU-EXISTS",
                    "Exists Product",
                    new BigDecimal("9.99"),
                    10
            );
            viewUpdater.update(createEvent.toGenericRecord());

            assertTrue(viewStore.containsKey(productId));
        }

        @Test
        @DisplayName("should return false when product does not exist")
        void shouldReturnFalseWhenProductDoesNotExist() {
            assertFalse(viewStore.containsKey("nonexistent"));
        }
    }

    @Nested
    @DisplayName("Available quantity calculation")
    class AvailableQuantityTests {

        @Test
        @DisplayName("should calculate available quantity correctly")
        void shouldCalculateAvailableQuantityCorrectly() {
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent createEvent = new ProductCreatedEvent(
                    productId,
                    "SKU-AVAIL",
                    "Available Product",
                    new BigDecimal("59.99"),
                    100
            );
            viewUpdater.update(createEvent.toGenericRecord());

            // Reserve some stock
            StockReservedEvent reserveEvent = new StockReservedEvent(productId, 35, "ORDER-001");
            viewUpdater.update(reserveEvent.toGenericRecord());

            Optional<GenericRecord> result = viewStore.get(productId);
            assertTrue(result.isPresent());

            int onHand = result.get().getInt32("quantityOnHand");
            int reserved = result.get().getInt32("quantityReserved");
            int available = onHand - reserved;

            assertEquals(100, onHand);
            assertEquals(35, reserved);
            assertEquals(65, available);
        }
    }
}
