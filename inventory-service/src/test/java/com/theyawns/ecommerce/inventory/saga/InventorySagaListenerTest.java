package com.theyawns.ecommerce.inventory.saga;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.Message;
import com.theyawns.ecommerce.common.domain.OrderLineItem;
import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.inventory.service.InventoryService;
import com.theyawns.ecommerce.inventory.service.ProductService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Unit tests for InventorySagaListener.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("InventorySagaListener")
@ExtendWith(MockitoExtension.class)
class InventorySagaListenerTest {

    @Mock
    private ProductService inventoryService;

    @Mock
    private HazelcastInstance hazelcast;

    private InventorySagaListener listener;

    @BeforeEach
    void setUp() {
        listener = new InventorySagaListener(inventoryService, hazelcast);
    }

    @Nested
    @DisplayName("OrderCreated event handling")
    class OrderCreatedTests {

        @Test
        @DisplayName("should reserve stock when OrderCreated saga event is received")
        void shouldReserveStockForSagaEvent() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();
            String customerId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();
            String productId = "prod-1";

            GenericRecord lineItem = GenericRecordBuilder.compact("OrderLineItem")
                    .setString("productId", productId)
                    .setString("productName", "Widget A")
                    .setString("sku", "SKU-001")
                    .setInt32("quantity", 2)
                    .setString("unitPrice", "10.00")
                    .setString("lineTotal", "20.00")
                    .build();

            GenericRecord orderCreatedRecord = GenericRecordBuilder.compact("OrderCreatedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "OrderCreated")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Order")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", orderId)
                    .setString("correlationId", correlationId)
                    .setString("sagaId", sagaId)
                    .setString("sagaType", "OrderFulfillment")
                    .setInt32("stepNumber", 0)
                    .setBoolean("isCompensating", false)
                    .setString("customerId", customerId)
                    .setString("customerName", "John Doe")
                    .setString("customerEmail", "john@example.com")
                    .setArrayOfGenericRecord("lineItems", new GenericRecord[]{lineItem})
                    .setString("shippingAddress", "123 Main St")
                    .setString("subtotal", "20.00")
                    .setString("tax", "2.00")
                    .setString("total", "22.00")
                    .build();

            Product mockProduct = new Product("prod-1", "SKU-001", "Widget A",
                    new BigDecimal("10.00"), 100);
            when(inventoryService.reserveStockForSaga(
                    anyString(), anyInt(), anyString(), anyString(), anyString(),
                    anyString(), anyString(), anyString(), anyString()))
                    .thenReturn(CompletableFuture.completedFuture(mockProduct));

            // Act - simulate message delivery
            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(orderCreatedRecord);

            // Get the listener via reflection and invoke it
            // Since the inner class is private, we test through registerListeners
            // Instead, we'll test the listener behavior by extracting and invoking
            listener.new OrderCreatedListener().onMessage(message);

            // Assert
            verify(inventoryService).reserveStockForSaga(
                    eq(productId),
                    eq(2),
                    eq(orderId),
                    eq(sagaId),
                    eq(correlationId),
                    eq(customerId),
                    eq("22.00"),
                    eq("USD"),
                    eq("CREDIT_CARD")
            );
        }

        @Test
        @DisplayName("should ignore OrderCreated events without sagaId")
        void shouldIgnoreNonSagaEvents() {
            // Arrange
            GenericRecord lineItem = GenericRecordBuilder.compact("OrderLineItem")
                    .setString("productId", "prod-1")
                    .setString("productName", "Widget")
                    .setString("sku", "SKU-001")
                    .setInt32("quantity", 1)
                    .setString("unitPrice", "10.00")
                    .setString("lineTotal", "10.00")
                    .build();

            GenericRecord record = GenericRecordBuilder.compact("OrderCreatedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "OrderCreated")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Order")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", UUID.randomUUID().toString())
                    .setString("correlationId", UUID.randomUUID().toString())
                    .setString("sagaId", null)
                    .setString("sagaType", null)
                    .setInt32("stepNumber", 0)
                    .setBoolean("isCompensating", false)
                    .setString("customerId", "cust-1")
                    .setString("customerName", "Jane Doe")
                    .setString("customerEmail", "jane@example.com")
                    .setArrayOfGenericRecord("lineItems", new GenericRecord[]{lineItem})
                    .setString("shippingAddress", "456 Oak Ave")
                    .setString("subtotal", "10.00")
                    .setString("tax", "1.00")
                    .setString("total", "11.00")
                    .build();

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(record);

            // Act
            listener.new OrderCreatedListener().onMessage(message);

            // Assert - should not call any service method
            verify(inventoryService, never()).reserveStockForSaga(
                    anyString(), anyInt(), anyString(), anyString(), anyString(),
                    anyString(), anyString(), anyString(), anyString());
        }

        @Test
        @DisplayName("should handle multiple line items")
        void shouldHandleMultipleLineItems() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord lineItem1 = GenericRecordBuilder.compact("OrderLineItem")
                    .setString("productId", "prod-1")
                    .setString("productName", "Widget A")
                    .setString("sku", "SKU-001")
                    .setInt32("quantity", 2)
                    .setString("unitPrice", "10.00")
                    .setString("lineTotal", "20.00")
                    .build();

            GenericRecord lineItem2 = GenericRecordBuilder.compact("OrderLineItem")
                    .setString("productId", "prod-2")
                    .setString("productName", "Widget B")
                    .setString("sku", "SKU-002")
                    .setInt32("quantity", 3)
                    .setString("unitPrice", "15.00")
                    .setString("lineTotal", "45.00")
                    .build();

            GenericRecord record = GenericRecordBuilder.compact("OrderCreatedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "OrderCreated")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Order")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", orderId)
                    .setString("correlationId", correlationId)
                    .setString("sagaId", sagaId)
                    .setString("sagaType", "OrderFulfillment")
                    .setInt32("stepNumber", 0)
                    .setBoolean("isCompensating", false)
                    .setString("customerId", "cust-1")
                    .setString("customerName", "John Doe")
                    .setString("customerEmail", "john@example.com")
                    .setArrayOfGenericRecord("lineItems", new GenericRecord[]{lineItem1, lineItem2})
                    .setString("shippingAddress", "123 Main St")
                    .setString("subtotal", "65.00")
                    .setString("tax", "6.50")
                    .setString("total", "71.50")
                    .build();

            Product mockProduct = new Product("prod-1", "SKU-001", "Widget A",
                    new BigDecimal("10.00"), 100);
            when(inventoryService.reserveStockForSaga(
                    anyString(), anyInt(), anyString(), anyString(), anyString(),
                    anyString(), anyString(), anyString(), anyString()))
                    .thenReturn(CompletableFuture.completedFuture(mockProduct));

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(record);

            // Act
            listener.new OrderCreatedListener().onMessage(message);

            // Assert - should call reserveStockForSaga twice (once per line item)
            ArgumentCaptor<String> productCaptor = ArgumentCaptor.forClass(String.class);
            ArgumentCaptor<Integer> quantityCaptor = ArgumentCaptor.forClass(Integer.class);

            verify(inventoryService, org.mockito.Mockito.times(2)).reserveStockForSaga(
                    productCaptor.capture(), quantityCaptor.capture(),
                    eq(orderId), eq(sagaId), eq(correlationId),
                    anyString(), anyString(), anyString(), anyString());

            assertEquals("prod-1", productCaptor.getAllValues().get(0));
            assertEquals(2, quantityCaptor.getAllValues().get(0));
            assertEquals("prod-2", productCaptor.getAllValues().get(1));
            assertEquals(3, quantityCaptor.getAllValues().get(1));
        }
    }
}
