package com.theyawns.ecommerce.inventory.controller;

import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.common.dto.ProductDTO;
import com.theyawns.ecommerce.inventory.exception.GlobalExceptionHandler;
import com.theyawns.ecommerce.inventory.exception.InsufficientStockException;
import com.theyawns.ecommerce.inventory.exception.ProductNotFoundException;
import com.theyawns.ecommerce.inventory.service.ProductService;
import com.theyawns.framework.vectorstore.VectorStoreService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import java.math.BigDecimal;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.asyncDispatch;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.request;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Integration tests for InventoryController REST endpoints.
 * Uses standalone MockMvc setup with interface mocking.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("InventoryController Integration Tests")
class InventoryControllerIntegrationTest {

    private MockMvc mockMvc;

    @Mock
    private ProductService productService;

    @Mock
    private VectorStoreService vectorStoreService;

    @BeforeEach
    void setUp() {
        InventoryController inventoryController = new InventoryController(productService, vectorStoreService);
        mockMvc = MockMvcBuilders.standaloneSetup(inventoryController)
                .setControllerAdvice(new GlobalExceptionHandler())
                .build();
    }

    @Nested
    @DisplayName("POST /api/products")
    class CreateProductEndpointTests {

        @Test
        @DisplayName("should create product and return 201")
        void shouldCreateProductAndReturn201() throws Exception {
            Product product = new Product("prod-123", "SKU-001", "Test Widget",
                    new BigDecimal("29.99"), 100);
            product.setDescription("A test widget");
            product.setCategory("Widgets");

            when(productService.createProduct(any(ProductDTO.class)))
                    .thenReturn(CompletableFuture.completedFuture(product));

            MvcResult mvcResult = mockMvc.perform(post("/api/products")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "sku": "SKU-001",
                                        "name": "Test Widget",
                                        "description": "A test widget",
                                        "price": 29.99,
                                        "quantityOnHand": 100,
                                        "category": "Widgets"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isCreated())
                    .andExpect(jsonPath("$.productId").value("prod-123"))
                    .andExpect(jsonPath("$.sku").value("SKU-001"))
                    .andExpect(jsonPath("$.name").value("Test Widget"))
                    .andExpect(jsonPath("$.price").value(29.99))
                    .andExpect(jsonPath("$.quantityOnHand").value(100));
        }

        @Test
        @DisplayName("should return 400 for invalid product data")
        void shouldReturn400ForInvalidProductData() throws Exception {
            mockMvc.perform(post("/api/products")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "sku": "",
                                        "name": "",
                                        "price": -1,
                                        "quantityOnHand": -5
                                    }
                                    """))
                    .andExpect(status().isBadRequest());
        }
    }

    @Nested
    @DisplayName("GET /api/products/{id}")
    class GetProductEndpointTests {

        @Test
        @DisplayName("should return product when found")
        void shouldReturnProductWhenFound() throws Exception {
            Product product = new Product("prod-123", "SKU-001", "Test Widget",
                    new BigDecimal("29.99"), 50);
            product.setQuantityReserved(10);

            when(productService.getProduct("prod-123")).thenReturn(Optional.of(product));

            mockMvc.perform(get("/api/products/prod-123"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.productId").value("prod-123"))
                    .andExpect(jsonPath("$.sku").value("SKU-001"))
                    .andExpect(jsonPath("$.name").value("Test Widget"))
                    .andExpect(jsonPath("$.quantityOnHand").value(50))
                    .andExpect(jsonPath("$.quantityReserved").value(10))
                    .andExpect(jsonPath("$.availableQuantity").value(40));
        }

        @Test
        @DisplayName("should return 404 when product not found")
        void shouldReturn404WhenProductNotFound() throws Exception {
            when(productService.getProduct("nonexistent")).thenReturn(Optional.empty());

            mockMvc.perform(get("/api/products/nonexistent"))
                    .andExpect(status().isNotFound());
        }
    }

    @Nested
    @DisplayName("POST /api/products/{id}/stock/reserve")
    class ReserveStockEndpointTests {

        @Test
        @DisplayName("should reserve stock and return 200")
        void shouldReserveStockAndReturn200() throws Exception {
            Product product = new Product("prod-123", "SKU-001", "Test Widget",
                    new BigDecimal("29.99"), 100);
            product.setQuantityReserved(25);

            when(productService.reserveStock(eq("prod-123"), eq(25), eq("ORDER-001")))
                    .thenReturn(CompletableFuture.completedFuture(product));

            MvcResult mvcResult = mockMvc.perform(post("/api/products/prod-123/stock/reserve")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "quantity": 25,
                                        "orderId": "ORDER-001"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.quantityReserved").value(25))
                    .andExpect(jsonPath("$.availableQuantity").value(75));
        }

        @Test
        @DisplayName("should return 404 when product not found")
        void shouldReturn404WhenProductNotFound() throws Exception {
            // Exception thrown synchronously before async processing starts
            when(productService.reserveStock(eq("nonexistent"), anyInt(), anyString()))
                    .thenThrow(new ProductNotFoundException("nonexistent"));

            mockMvc.perform(post("/api/products/nonexistent/stock/reserve")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "quantity": 10,
                                        "orderId": "ORDER-001"
                                    }
                                    """))
                    .andExpect(status().isNotFound())
                    .andExpect(jsonPath("$.errorCode").value("PRODUCT_NOT_FOUND"));
        }

        @Test
        @DisplayName("should return 409 when insufficient stock")
        void shouldReturn409WhenInsufficientStock() throws Exception {
            // Exception thrown synchronously before async processing starts
            when(productService.reserveStock(eq("prod-123"), eq(150), anyString()))
                    .thenThrow(new InsufficientStockException("prod-123", 150, 100));

            mockMvc.perform(post("/api/products/prod-123/stock/reserve")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "quantity": 150,
                                        "orderId": "ORDER-001"
                                    }
                                    """))
                    .andExpect(status().isConflict())
                    .andExpect(jsonPath("$.errorCode").value("INSUFFICIENT_STOCK"))
                    .andExpect(jsonPath("$.details.requestedQuantity").value("150"))
                    .andExpect(jsonPath("$.details.availableQuantity").value("100"));
        }

        @Test
        @DisplayName("should return 400 for invalid reservation request")
        void shouldReturn400ForInvalidReservationRequest() throws Exception {
            mockMvc.perform(post("/api/products/prod-123/stock/reserve")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "quantity": 0,
                                        "orderId": ""
                                    }
                                    """))
                    .andExpect(status().isBadRequest());
        }
    }

    @Nested
    @DisplayName("POST /api/products/{id}/stock/release")
    class ReleaseStockEndpointTests {

        @Test
        @DisplayName("should release stock and return 200")
        void shouldReleaseStockAndReturn200() throws Exception {
            Product product = new Product("prod-123", "SKU-001", "Test Widget",
                    new BigDecimal("29.99"), 100);
            product.setQuantityReserved(10);

            when(productService.releaseStock(eq("prod-123"), eq(15), eq("ORDER-001"), eq("Order cancelled")))
                    .thenReturn(CompletableFuture.completedFuture(product));

            MvcResult mvcResult = mockMvc.perform(post("/api/products/prod-123/stock/release")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "quantity": 15,
                                        "orderId": "ORDER-001",
                                        "reason": "Order cancelled"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.quantityReserved").value(10))
                    .andExpect(jsonPath("$.availableQuantity").value(90));
        }

        @Test
        @DisplayName("should return 404 when product not found")
        void shouldReturn404WhenProductNotFound() throws Exception {
            // Exception thrown synchronously before async processing starts
            when(productService.releaseStock(eq("nonexistent"), anyInt(), anyString(), anyString()))
                    .thenThrow(new ProductNotFoundException("nonexistent"));

            mockMvc.perform(post("/api/products/nonexistent/stock/release")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "quantity": 10,
                                        "orderId": "ORDER-001",
                                        "reason": "Cancelled"
                                    }
                                    """))
                    .andExpect(status().isNotFound())
                    .andExpect(jsonPath("$.errorCode").value("PRODUCT_NOT_FOUND"));
        }

        @Test
        @DisplayName("should return 400 for invalid release request")
        void shouldReturn400ForInvalidReleaseRequest() throws Exception {
            mockMvc.perform(post("/api/products/prod-123/stock/release")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "quantity": -1,
                                        "orderId": "",
                                        "reason": ""
                                    }
                                    """))
                    .andExpect(status().isBadRequest());
        }
    }
}
