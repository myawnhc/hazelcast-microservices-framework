package com.theyawns.ecommerce.inventory.controller;

import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.inventory.exception.GlobalExceptionHandler;
import com.theyawns.ecommerce.inventory.exception.InsufficientStockException;
import com.theyawns.ecommerce.inventory.service.InventoryService;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import java.math.BigDecimal;
import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.anyInt;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.asyncDispatch;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.request;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Tests for {@link OrchestratedInventoryController}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("OrchestratedInventoryController - REST endpoints")
class OrchestratedInventoryControllerTest {

    private MockMvc mockMvc;

    @Mock
    private InventoryService inventoryService;

    @BeforeEach
    void setUp() {
        OrchestratedInventoryController controller =
                new OrchestratedInventoryController(inventoryService);
        mockMvc = MockMvcBuilders.standaloneSetup(controller)
                .setControllerAdvice(new GlobalExceptionHandler())
                .build();
    }

    @Nested
    @DisplayName("POST /api/saga/inventory/reserve-stock")
    class ReserveStock {

        @Test
        @DisplayName("should return success response on successful reservation")
        void shouldReturnSuccessOnReservation() throws Exception {
            Product product = createTestProduct(100, 5);
            when(inventoryService.reserveStockOrchestrated(eq("prod-1"), eq(5), eq("order-1")))
                    .thenReturn(CompletableFuture.completedFuture(product));

            MvcResult mvcResult = mockMvc.perform(post("/api/saga/inventory/reserve-stock")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "productId": "prod-1",
                                        "quantity": 5,
                                        "orderId": "order-1"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.success").value(true));

            verify(inventoryService).reserveStockOrchestrated("prod-1", 5, "order-1");
        }

        @Test
        @DisplayName("should return failure response on insufficient stock")
        void shouldReturnFailureOnInsufficientStock() throws Exception {
            when(inventoryService.reserveStockOrchestrated(eq("prod-1"), eq(100), eq("order-1")))
                    .thenThrow(new InsufficientStockException("prod-1", 100, 5));

            MvcResult mvcResult = mockMvc.perform(post("/api/saga/inventory/reserve-stock")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "productId": "prod-1",
                                        "quantity": 100,
                                        "orderId": "order-1"
                                    }
                                    """))
                    .andReturn();

            // When the exception is thrown synchronously (before the future),
            // the catch block returns a completed future with failure
            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.success").value(false))
                    .andExpect(jsonPath("$.errorMessage").exists());
        }
    }

    @Nested
    @DisplayName("POST /api/saga/inventory/release-stock")
    class ReleaseStock {

        @Test
        @DisplayName("should return success response on stock release")
        void shouldReturnSuccessOnRelease() throws Exception {
            Product product = createTestProduct(100, 0);
            when(inventoryService.releaseStockOrchestrated(eq("order-1"), eq("compensation")))
                    .thenReturn(CompletableFuture.completedFuture(product));

            MvcResult mvcResult = mockMvc.perform(post("/api/saga/inventory/release-stock")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "orderId": "order-1",
                                        "reason": "compensation"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.success").value(true));

            verify(inventoryService).releaseStockOrchestrated("order-1", "compensation");
        }
    }

    private Product createTestProduct(int onHand, int reserved) {
        Product product = new Product();
        product.setProductId("prod-1");
        product.setName("Widget");
        product.setSku("WDG-001");
        product.setPrice(new BigDecimal("29.99"));
        product.setQuantityOnHand(onHand);
        product.setQuantityReserved(reserved);
        product.setStatus(Product.Status.ACTIVE);
        return product;
    }
}
