package com.theyawns.ecommerce.inventory.service;

import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.inventory.config.StockReplenishmentProperties;
import io.micrometer.core.instrument.Counter;
import io.micrometer.core.instrument.MeterRegistry;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Component;

import java.util.List;

/**
 * Background monitor that automatically replenishes stock when levels drop
 * below the configured reorder point.
 *
 * <p>This component runs on a fixed-delay schedule and checks all products
 * in the materialized view. When a product's available quantity (on hand minus
 * reserved) falls below {@code reorderPoint}, it triggers a replenishment
 * of {@code reorderQuantity} units through the event sourcing pipeline.
 *
 * <p>This prevents stock exhaustion during sustained load testing (trade show
 * demos, multi-hour performance tests) and models real-world automatic
 * reorder behavior.
 *
 * <p>Enabled by default. Disable with:
 * <pre>
 * framework.inventory.replenishment.enabled=false
 * </pre>
 *
 * @author Generated by Claude Code
 * @since 3.1
 * @see StockReplenishmentProperties
 */
@Component
@ConditionalOnProperty(name = "framework.inventory.replenishment.enabled", matchIfMissing = true)
@EnableConfigurationProperties(StockReplenishmentProperties.class)
public class StockReplenishmentMonitor {

    private static final Logger logger = LoggerFactory.getLogger(StockReplenishmentMonitor.class);

    private final ProductService productService;
    private final StockReplenishmentProperties properties;
    private final Counter replenishedCounter;

    /**
     * Creates a new StockReplenishmentMonitor.
     *
     * @param productService the product service for stock operations
     * @param properties the replenishment configuration properties
     * @param meterRegistry the Micrometer meter registry for metrics
     */
    public StockReplenishmentMonitor(ProductService productService,
                                      StockReplenishmentProperties properties,
                                      MeterRegistry meterRegistry) {
        this.productService = productService;
        this.properties = properties;
        this.replenishedCounter = Counter.builder("inventory.stock.replenished")
                .description("Number of automatic stock replenishment events")
                .register(meterRegistry);
        logger.info("Stock replenishment monitor initialized: reorderPoint={}, reorderQuantity={}, " +
                        "checkIntervalMs={}", properties.getReorderPoint(),
                properties.getReorderQuantity(), properties.getCheckIntervalMs());
    }

    /**
     * Periodically checks all product stock levels and triggers replenishment
     * when available quantity drops below the reorder point.
     */
    @Scheduled(fixedDelayString = "${framework.inventory.replenishment.check-interval-ms:10000}")
    public void checkAndReplenish() {
        final int reorderPoint = properties.getReorderPoint();
        final int reorderQuantity = properties.getReorderQuantity();

        // List all products â€” use a high limit to cover the full catalog
        List<Product> products = productService.listAll(10000);

        for (Product product : products) {
            int available = product.getAvailableQuantity();
            if (available < reorderPoint) {
                logger.info("Stock below reorder point for product {}: available={}, reorderPoint={}, " +
                                "replenishing {} units",
                        product.getProductId(), available, reorderPoint, reorderQuantity);
                try {
                    productService.replenishStock(
                            product.getProductId(), reorderQuantity, "AUTO_REORDER");
                    replenishedCounter.increment();
                } catch (Exception e) {
                    logger.warn("Failed to replenish stock for product {}: {}",
                            product.getProductId(), e.getMessage());
                }
            }
        }
    }
}
