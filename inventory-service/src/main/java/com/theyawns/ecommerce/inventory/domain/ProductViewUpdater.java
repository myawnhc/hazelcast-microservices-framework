package com.theyawns.ecommerce.inventory.domain;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.common.events.ProductCreatedEvent;
import com.theyawns.ecommerce.common.events.StockReleasedEvent;
import com.theyawns.ecommerce.common.events.StockReplenishedEvent;
import com.theyawns.ecommerce.common.events.StockReservedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import com.theyawns.framework.view.ViewUpdater;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;

/**
 * ViewUpdater implementation for the Product domain.
 * Handles applying product events to the materialized view.
 *
 * <p>Supported events:
 * <ul>
 *   <li>{@link ProductCreatedEvent} - Creates new product entry</li>
 *   <li>{@link StockReservedEvent} - Increases reserved quantity</li>
 *   <li>{@link StockReleasedEvent} - Decreases reserved quantity</li>
 *   <li>{@link StockReplenishedEvent} - Increases quantity on hand</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
public class ProductViewUpdater extends ViewUpdater<String> {

    private static final Logger logger = LoggerFactory.getLogger(ProductViewUpdater.class);

    /**
     * Creates a new ProductViewUpdater.
     *
     * @param viewStore the view store to update
     */
    public ProductViewUpdater(HazelcastViewStore<String> viewStore) {
        super(viewStore);
    }

    @Override
    protected String extractKey(GenericRecord eventRecord) {
        return getStringField(eventRecord, "key");
    }

    @Override
    protected GenericRecord applyEvent(GenericRecord eventRecord, GenericRecord currentState) {
        String eventType = getEventType(eventRecord);

        logger.debug("Applying event type: {} to product view", eventType);

        return switch (eventType) {
            case ProductCreatedEvent.EVENT_TYPE -> applyProductCreated(eventRecord);
            case StockReservedEvent.EVENT_TYPE -> applyStockReserved(eventRecord, currentState);
            case StockReleasedEvent.EVENT_TYPE -> applyStockReleased(eventRecord, currentState);
            case StockReplenishedEvent.EVENT_TYPE -> applyStockReplenished(eventRecord, currentState);
            default -> {
                logger.warn("Unknown event type: {}", eventType);
                yield currentState;
            }
        };
    }

    /**
     * Applies a ProductCreatedEvent to create a new product view entry.
     *
     * @param eventRecord the event record
     * @return the new product view state
     */
    private GenericRecord applyProductCreated(GenericRecord eventRecord) {
        Instant now = Instant.now();
        return GenericRecordBuilder.compact(Product.SCHEMA_NAME)
                .setString("productId", getStringField(eventRecord, "key"))
                .setString("sku", getStringField(eventRecord, "sku"))
                .setString("name", getStringField(eventRecord, "name"))
                .setString("description", getStringField(eventRecord, "description"))
                .setString("price", getStringField(eventRecord, "price"))
                .setInt32("quantityOnHand", eventRecord.getInt32("initialQuantity"))
                .setInt32("quantityReserved", 0)
                .setString("category", getStringField(eventRecord, "category"))
                .setString("status", Product.Status.ACTIVE.name())
                .setInt64("createdAt", now.toEpochMilli())
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a StockReservedEvent to increase reserved quantity.
     *
     * @param eventRecord the event record
     * @param currentState the current product state
     * @return the updated product view state
     */
    private GenericRecord applyStockReserved(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.error("Cannot reserve stock for non-existent product: {}",
                    getStringField(eventRecord, "key"));
            return null;
        }

        int currentReserved = currentState.getInt32("quantityReserved");
        int quantityToReserve = eventRecord.getInt32("quantity");
        int newReserved = currentReserved + quantityToReserve;

        Instant now = Instant.now();
        return GenericRecordBuilder.compact(Product.SCHEMA_NAME)
                .setString("productId", currentState.getString("productId"))
                .setString("sku", currentState.getString("sku"))
                .setString("name", currentState.getString("name"))
                .setString("description", currentState.getString("description"))
                .setString("price", currentState.getString("price"))
                .setInt32("quantityOnHand", currentState.getInt32("quantityOnHand"))
                .setInt32("quantityReserved", newReserved)
                .setString("category", currentState.getString("category"))
                .setString("status", currentState.getString("status"))
                .setInt64("createdAt", currentState.getInt64("createdAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a StockReleasedEvent to decrease reserved quantity.
     *
     * @param eventRecord the event record
     * @param currentState the current product state
     * @return the updated product view state
     */
    private GenericRecord applyStockReleased(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.error("Cannot release stock for non-existent product: {}",
                    getStringField(eventRecord, "key"));
            return null;
        }

        int currentReserved = currentState.getInt32("quantityReserved");
        int quantityToRelease = eventRecord.getInt32("quantity");
        int newReserved = Math.max(0, currentReserved - quantityToRelease);

        Instant now = Instant.now();
        return GenericRecordBuilder.compact(Product.SCHEMA_NAME)
                .setString("productId", currentState.getString("productId"))
                .setString("sku", currentState.getString("sku"))
                .setString("name", currentState.getString("name"))
                .setString("description", currentState.getString("description"))
                .setString("price", currentState.getString("price"))
                .setInt32("quantityOnHand", currentState.getInt32("quantityOnHand"))
                .setInt32("quantityReserved", newReserved)
                .setString("category", currentState.getString("category"))
                .setString("status", currentState.getString("status"))
                .setInt64("createdAt", currentState.getInt64("createdAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a StockReplenishedEvent to increase quantity on hand.
     *
     * @param eventRecord the event record
     * @param currentState the current product state
     * @return the updated product view state
     */
    private GenericRecord applyStockReplenished(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.error("Cannot replenish stock for non-existent product: {}",
                    getStringField(eventRecord, "key"));
            return null;
        }

        int currentOnHand = currentState.getInt32("quantityOnHand");
        int quantityAdded = eventRecord.getInt32("quantityAdded");
        int newOnHand = currentOnHand + quantityAdded;

        Instant now = Instant.now();
        return GenericRecordBuilder.compact(Product.SCHEMA_NAME)
                .setString("productId", currentState.getString("productId"))
                .setString("sku", currentState.getString("sku"))
                .setString("name", currentState.getString("name"))
                .setString("description", currentState.getString("description"))
                .setString("price", currentState.getString("price"))
                .setInt32("quantityOnHand", newOnHand)
                .setInt32("quantityReserved", currentState.getInt32("quantityReserved"))
                .setString("category", currentState.getString("category"))
                .setString("status", currentState.getString("status"))
                .setInt64("createdAt", currentState.getInt64("createdAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }
}
