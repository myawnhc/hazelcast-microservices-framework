package com.theyawns.ecommerce.inventory.saga;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.Message;
import com.hazelcast.topic.MessageListener;
import com.theyawns.ecommerce.common.events.OrderCancelledEvent;
import com.theyawns.ecommerce.common.events.OrderCreatedEvent;
import com.theyawns.ecommerce.common.events.PaymentFailedEvent;
import com.theyawns.ecommerce.inventory.service.ProductService;
import com.theyawns.framework.dlq.DeadLetterEntry;
import com.theyawns.framework.dlq.DeadLetterQueueOperations;
import com.theyawns.framework.idempotency.IdempotencyGuard;
import com.theyawns.framework.resilience.ResilienceException;
import com.theyawns.framework.resilience.ResilientOperations;
import com.theyawns.framework.tracing.EventSpanDecorator;
import io.micrometer.tracing.Span;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

import java.util.concurrent.CompletableFuture;
import java.util.function.Supplier;

/**
 * Saga event listener for the Inventory Service.
 *
 * <p>Listens for saga-related events that trigger inventory actions:
 * <ul>
 *   <li>{@link OrderCreatedEvent} - Triggers stock reservation (saga step 1)</li>
 *   <li>{@link OrderCancelledEvent} - Triggers stock release on order cancellation</li>
 *   <li>{@link PaymentFailedEvent} - Triggers stock release compensation</li>
 * </ul>
 *
 * <p>This component connects the Inventory Service to the choreographed saga
 * for order fulfillment. When an order is created (step 0), the inventory
 * service automatically reserves stock for the order's line items (step 1).
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@Component
public class InventorySagaListener {

    private static final Logger logger = LoggerFactory.getLogger(InventorySagaListener.class);

    private final ProductService inventoryService;
    private final HazelcastInstance hazelcast;
    private EventSpanDecorator eventSpanDecorator;
    private ResilientOperations resilientServiceInvoker;
    private IdempotencyGuard idempotencyGuard;
    private DeadLetterQueueOperations deadLetterQueue;

    /**
     * Creates a new InventorySagaListener.
     *
     * @param inventoryService the inventory service for stock operations
     * @param hazelcast the shared Hazelcast client for cross-service topic subscriptions
     */
    public InventorySagaListener(ProductService inventoryService,
                                 @Qualifier("hazelcastClient") HazelcastInstance hazelcast) {
        this.inventoryService = inventoryService;
        this.hazelcast = hazelcast;
    }

    /**
     * Sets the event span decorator for distributed tracing (optional).
     *
     * @param eventSpanDecorator the span decorator
     */
    @Autowired(required = false)
    public void setEventSpanDecorator(EventSpanDecorator eventSpanDecorator) {
        this.eventSpanDecorator = eventSpanDecorator;
    }

    /**
     * Sets the resilient service invoker for circuit breaker protection (optional).
     *
     * <p>When set, all saga service calls are wrapped with circuit breaker and retry
     * decoration. When not set (e.g., resilience disabled), calls delegate directly.
     *
     * @param resilientServiceInvoker the resilient service invoker
     */
    @Autowired(required = false)
    public void setResilientOperations(ResilientOperations resilientServiceInvoker) {
        this.resilientServiceInvoker = resilientServiceInvoker;
    }

    /**
     * Sets the idempotency guard for duplicate event detection (optional).
     *
     * @param idempotencyGuard the idempotency guard
     */
    @Autowired(required = false)
    public void setIdempotencyGuard(IdempotencyGuard idempotencyGuard) {
        this.idempotencyGuard = idempotencyGuard;
    }

    /**
     * Sets the dead letter queue for failed event capture (optional).
     *
     * @param deadLetterQueue the DLQ operations
     */
    @Autowired(required = false)
    public void setDeadLetterQueue(DeadLetterQueueOperations deadLetterQueue) {
        this.deadLetterQueue = deadLetterQueue;
    }

    /**
     * Executes an async operation with circuit breaker protection if available.
     *
     * @param name the circuit breaker instance name
     * @param operation the async operation to execute
     * @param <T> the return type
     * @return the CompletableFuture result
     */
    private <T> CompletableFuture<T> executeWithResilience(
            final String name, final Supplier<CompletableFuture<T>> operation) {
        if (resilientServiceInvoker != null) {
            return resilientServiceInvoker.executeAsync(name, operation);
        }
        return operation.get();
    }

    /**
     * Registers listeners for saga-related topics on startup.
     */
    @PostConstruct
    public void registerListeners() {
        logger.info("Registering inventory saga event listeners");

        ITopic<GenericRecord> orderCreatedTopic = hazelcast.getTopic("OrderCreated");
        orderCreatedTopic.addMessageListener(new OrderCreatedListener());

        ITopic<GenericRecord> orderCancelledTopic = hazelcast.getTopic("OrderCancelled");
        orderCancelledTopic.addMessageListener(new OrderCancelledListener());

        ITopic<GenericRecord> paymentFailedTopic = hazelcast.getTopic("PaymentFailed");
        paymentFailedTopic.addMessageListener(new PaymentFailedListener());

        logger.info("Inventory saga listeners registered successfully");
    }

    /**
     * Sends a failed event to the dead letter queue if available,
     * otherwise falls back to logging.
     *
     * @param record the event record that failed processing
     * @param topicName the ITopic name
     * @param error the failure cause
     */
    private void sendToDeadLetterQueue(GenericRecord record, String topicName, Throwable error) {
        String eventId = record.getString("eventId");
        if (deadLetterQueue != null) {
            try {
                deadLetterQueue.add(DeadLetterEntry.builder()
                        .originalEventId(eventId)
                        .eventType(record.getString("eventType"))
                        .topicName(topicName)
                        .eventRecord(record)
                        .failureReason(error.getMessage())
                        .sourceService("inventory-service")
                        .sagaId(record.getString("sagaId"))
                        .correlationId(record.getString("correlationId"))
                        .build());
                logger.warn("Event {} sent to DLQ after failure: {}", eventId, error.getMessage());
            } catch (Exception dlqError) {
                logger.error("Failed to send event {} to DLQ: {}", eventId, dlqError.getMessage());
            }
        } else {
            if (error instanceof ResilienceException) {
                logger.warn("Circuit breaker open, saga step deferred: eventId={}", eventId);
            } else {
                logger.error("Failed to process event: {}", eventId, error);
            }
        }
    }

    /**
     * Listener for OrderCreated events.
     *
     * <p>When an order is created as part of a saga, reserves stock for each
     * line item. The saga context (sagaId, correlationId) and payment context
     * (customerId, amount, currency) are propagated to the StockReservedEvent
     * for downstream processing by the Payment Service.
     */
    class OrderCreatedListener implements MessageListener<GenericRecord> {

        @Override
        public void onMessage(Message<GenericRecord> message) {
            GenericRecord record = message.getMessageObject();

            String eventId = record.getString("eventId");
            if (idempotencyGuard != null && eventId != null && !idempotencyGuard.tryProcess(eventId)) {
                logger.debug("Duplicate event {} already processed, skipping", eventId);
                return;
            }

            String sagaId = record.getString("sagaId");
            if (sagaId == null || sagaId.isEmpty()) {
                logger.debug("OrderCreated event without sagaId - not a saga event, ignoring");
                return;
            }

            String orderId = record.getString("key");
            String correlationId = record.getString("correlationId");
            String customerId = record.getString("customerId");

            logger.info("Received OrderCreated saga event: orderId={}, sagaId={}", orderId, sagaId);

            Span span = null;
            if (eventSpanDecorator != null) {
                span = eventSpanDecorator.startSagaSpan("OrderCreated", sagaId,
                        "OrderFulfillment", 1);
            }
            final Span currentSpan = span;

            // Extract order total and payment context for downstream payment processing
            String total = record.getString("total");
            String currency = "USD"; // Default currency

            // Reserve stock for each line item
            // For the happy path, we reserve the first line item and propagate payment context
            GenericRecord[] lineItems = record.getArrayOfGenericRecord("lineItems");
            if (lineItems == null || lineItems.length == 0) {
                logger.warn("OrderCreated event has no line items: orderId={}, sagaId={}", orderId, sagaId);
                if (eventSpanDecorator != null) {
                    eventSpanDecorator.endSpan(currentSpan);
                }
                return;
            }

            // Reserve stock for each line item in the order
            for (GenericRecord lineItem : lineItems) {
                String productId = lineItem.getString("productId");
                int quantity = lineItem.getInt32("quantity");

                try {
                    executeWithResilience("inventory-stock-reservation",
                            () -> inventoryService.reserveStockForSaga(
                                    productId,
                                    quantity,
                                    orderId,
                                    sagaId,
                                    correlationId,
                                    customerId,
                                    total,
                                    currency,
                                    "CREDIT_CARD" // Default payment method
                            )
                    ).whenComplete((product, error) -> {
                        if (error != null) {
                            sendToDeadLetterQueue(record, "OrderCreated", error);
                            if (eventSpanDecorator != null) {
                                eventSpanDecorator.recordError(currentSpan, error);
                            }
                        } else {
                            logger.info("Stock reserved for saga: productId={}, quantity={}, orderId={}, sagaId={}",
                                    productId, quantity, orderId, sagaId);
                        }
                        if (eventSpanDecorator != null) {
                            eventSpanDecorator.endSpan(currentSpan);
                        }
                    });
                } catch (Exception e) {
                    logger.error("Error initiating stock reservation for product {} in saga: {} (orderId: {})",
                            productId, sagaId, orderId, e);
                    if (eventSpanDecorator != null) {
                        eventSpanDecorator.recordError(currentSpan, e);
                        eventSpanDecorator.endSpan(currentSpan);
                    }
                }
            }
        }
    }

    /**
     * Listener for OrderCancelled events.
     *
     * <p>When an order is cancelled (either directly by the customer or by the
     * system), releases all stock that was previously reserved for that order.
     * Handles both saga and non-saga cancellations.
     */
    class OrderCancelledListener implements MessageListener<GenericRecord> {

        @Override
        public void onMessage(Message<GenericRecord> message) {
            GenericRecord record = message.getMessageObject();

            String eventId = record.getString("eventId");
            if (idempotencyGuard != null && eventId != null && !idempotencyGuard.tryProcess(eventId)) {
                logger.debug("Duplicate event {} already processed, skipping", eventId);
                return;
            }

            String orderId = record.getString("key");
            String sagaId = record.getString("sagaId");
            String correlationId = record.getString("correlationId");
            String reason = record.getString("reason");

            logger.info("Received OrderCancelled event: orderId={}, sagaId={}", orderId,
                    sagaId != null ? sagaId : "none");

            Span span = null;
            if (eventSpanDecorator != null) {
                span = eventSpanDecorator.startSagaSpan("OrderCancelled",
                        sagaId != null ? sagaId : "direct", "OrderFulfillment", 1);
            }
            final Span currentSpan = span;

            String releaseReason = "Order cancelled" + (reason != null ? ": " + reason : "");

            try {
                if (sagaId != null && !sagaId.isEmpty()) {
                    // Saga cancellation path - records compensation steps
                    executeWithResilience("inventory-stock-release",
                            () -> inventoryService.releaseStockForSaga(orderId, sagaId, correlationId, releaseReason)
                    ).whenComplete((product, error) -> {
                        if (error != null) {
                            sendToDeadLetterQueue(record, "OrderCancelled", error);
                            if (eventSpanDecorator != null) {
                                eventSpanDecorator.recordError(currentSpan, error);
                            }
                        } else {
                            logger.info("Stock released for cancelled order: orderId={}, sagaId={}",
                                    orderId, sagaId);
                        }
                        if (eventSpanDecorator != null) {
                            eventSpanDecorator.endSpan(currentSpan);
                        }
                    });
                } else {
                    // Direct cancellation path - no saga tracking, no circuit breaker needed
                    inventoryService.releaseReservedStockForOrder(orderId, releaseReason)
                            .whenComplete((product, error) -> {
                                if (error != null) {
                                    logger.error("Failed to release stock for cancelled order: orderId={}",
                                            orderId, error);
                                    if (eventSpanDecorator != null) {
                                        eventSpanDecorator.recordError(currentSpan, error);
                                    }
                                } else {
                                    logger.info("Stock released for cancelled order: orderId={}", orderId);
                                }
                                if (eventSpanDecorator != null) {
                                    eventSpanDecorator.endSpan(currentSpan);
                                }
                            });
                }
            } catch (Exception e) {
                logger.error("Error initiating stock release for cancelled order: orderId={}", orderId, e);
                if (eventSpanDecorator != null) {
                    eventSpanDecorator.recordError(currentSpan, e);
                    eventSpanDecorator.endSpan(currentSpan);
                }
            }
        }
    }

    /**
     * Listener for PaymentFailed events.
     *
     * <p>When payment fails as part of a saga, releases stock that was
     * previously reserved for the order. This compensates step 1 (StockReserved).
     *
     * <p>Reservations are tracked by orderId in the OrderStockReservations IMap
     * during the reservation step. This listener looks up those reservations
     * and releases each one.
     */
    class PaymentFailedListener implements MessageListener<GenericRecord> {

        @Override
        public void onMessage(Message<GenericRecord> message) {
            GenericRecord record = message.getMessageObject();

            String eventId = record.getString("eventId");
            if (idempotencyGuard != null && eventId != null && !idempotencyGuard.tryProcess(eventId)) {
                logger.debug("Duplicate event {} already processed, skipping", eventId);
                return;
            }

            String sagaId = record.getString("sagaId");
            if (sagaId == null || sagaId.isEmpty()) {
                logger.debug("PaymentFailed event without sagaId - not a saga event, ignoring");
                return;
            }

            String orderId = record.getString("orderId");
            String correlationId = record.getString("correlationId");
            String failureReason = record.getString("failureReason");

            logger.info("Received PaymentFailed saga event: orderId={}, sagaId={}, reason={}",
                    orderId, sagaId, failureReason);

            Span span = null;
            if (eventSpanDecorator != null) {
                span = eventSpanDecorator.startSagaSpan("PaymentFailed", sagaId,
                        "OrderFulfillment", 1);
            }
            final Span currentSpan = span;

            String reason = "Payment failed: " + failureReason;

            try {
                executeWithResilience("inventory-stock-release",
                        () -> inventoryService.releaseStockForSaga(
                                orderId,
                                sagaId,
                                correlationId,
                                reason
                        )
                ).whenComplete((product, error) -> {
                    if (error != null) {
                        sendToDeadLetterQueue(record, "PaymentFailed", error);
                        if (eventSpanDecorator != null) {
                            eventSpanDecorator.recordError(currentSpan, error);
                        }
                    } else {
                        logger.info("Stock released for saga compensation: orderId={}, sagaId={}",
                                orderId, sagaId);
                    }
                    if (eventSpanDecorator != null) {
                        eventSpanDecorator.endSpan(currentSpan);
                    }
                });
            } catch (Exception e) {
                logger.error("Error initiating stock release for saga compensation: orderId={}, sagaId={}",
                        orderId, sagaId, e);
                if (eventSpanDecorator != null) {
                    eventSpanDecorator.recordError(currentSpan, e);
                    eventSpanDecorator.endSpan(currentSpan);
                }
            }
        }
    }
}
