package com.theyawns.ecommerce.inventory.service;

import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.common.dto.ProductDTO;
import com.theyawns.ecommerce.common.events.ProductCreatedEvent;
import com.theyawns.ecommerce.common.events.StockReleasedEvent;
import com.theyawns.ecommerce.common.events.StockReservedEvent;
import com.theyawns.ecommerce.inventory.exception.InsufficientStockException;
import com.theyawns.ecommerce.inventory.exception.ProductNotFoundException;
import com.theyawns.framework.controller.EventSourcingController;
import com.theyawns.framework.controller.SagaMetadata;
import com.theyawns.framework.event.DomainEvent;
import com.theyawns.framework.saga.SagaCompensationConfig;
import com.theyawns.framework.saga.SagaStateStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

/**
 * Business logic service for product inventory management.
 *
 * <p>All operations use the event sourcing controller to:
 * <ul>
 *   <li>Publish domain events</li>
 *   <li>Update the materialized view</li>
 *   <li>Return async completion futures</li>
 * </ul>
 *
 * <p>Read operations use the materialized view for fast lookups.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Service
public class InventoryService implements ProductService {

    private static final Logger logger = LoggerFactory.getLogger(InventoryService.class);

    private final EventSourcingController<Product, String, DomainEvent<Product, String>> controller;
    private final SagaStateStore sagaStateStore;

    /**
     * Creates a new InventoryService.
     *
     * @param controller the event sourcing controller for product events
     * @param sagaStateStore the saga state store for tracking distributed transactions
     */
    public InventoryService(
            EventSourcingController<Product, String, DomainEvent<Product, String>> controller,
            SagaStateStore sagaStateStore) {
        this.controller = controller;
        this.sagaStateStore = sagaStateStore;
    }

    /**
     * Creates a new product.
     *
     * @param dto the product data
     * @return a future that completes with the created product
     */
    @Override
    public CompletableFuture<Product> createProduct(ProductDTO dto) {
        String productId = UUID.randomUUID().toString();
        logger.info("Creating product with ID: {}", productId);

        ProductCreatedEvent event = new ProductCreatedEvent(
                productId,
                dto.getSku(),
                dto.getName(),
                dto.getPrice(),
                dto.getQuantityOnHand()
        );
        event.setDescription(dto.getDescription());
        event.setCategory(dto.getCategory());

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Product created event processed: {}", completionInfo.getEventId());
                    return getProductOrThrow(productId);
                });
    }

    /**
     * Retrieves a product by ID from the materialized view.
     *
     * @param productId the product ID
     * @return the product, or empty if not found
     */
    @Override
    public Optional<Product> getProduct(String productId) {
        logger.debug("Getting product: {}", productId);
        return controller.getViewState(productId)
                .map(Product::fromGenericRecord);
    }

    /**
     * Reserves stock for an order.
     *
     * @param productId the product ID
     * @param quantity the quantity to reserve
     * @param orderId the order ID requesting the reservation
     * @return a future that completes with the updated product
     * @throws ProductNotFoundException if product does not exist
     * @throws InsufficientStockException if insufficient stock available
     */
    @Override
    public CompletableFuture<Product> reserveStock(String productId, int quantity, String orderId) {
        logger.info("Reserving {} units of product {} for order {}", quantity, productId, orderId);

        Product product = getProductOrThrow(productId);

        // Check available stock
        int available = product.getAvailableQuantity();
        if (available < quantity) {
            throw new InsufficientStockException(productId, quantity, available);
        }

        StockReservedEvent event = new StockReservedEvent(productId, quantity, orderId);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Stock reserved event processed: {}", completionInfo.getEventId());
                    return getProductOrThrow(productId);
                });
    }

    /**
     * Reserves stock for an order as part of a saga.
     *
     * <p>This method propagates saga context (sagaId, correlationId) through
     * the StockReservedEvent and records step 1 completion in the SagaStateStore.
     * It also sets payment context fields on the event so the downstream
     * PaymentService can process payment.
     *
     * @param productId the product ID
     * @param quantity the quantity to reserve
     * @param orderId the order ID
     * @param sagaId the saga instance ID
     * @param correlationId the correlation ID
     * @param customerId the customer ID (propagated for payment)
     * @param amount the order amount (propagated for payment)
     * @param currency the currency code (propagated for payment)
     * @param method the payment method (propagated for payment)
     * @return a future that completes with the updated product
     * @throws ProductNotFoundException if product does not exist
     * @throws InsufficientStockException if insufficient stock available
     */
    public CompletableFuture<Product> reserveStockForSaga(
            final String productId, final int quantity, final String orderId,
            final String sagaId, final String correlationId,
            final String customerId, final String amount,
            final String currency, final String method) {

        logger.info("Reserving {} units of product {} for order {} (sagaId: {})",
                quantity, productId, orderId, sagaId);

        Product product = getProductOrThrow(productId);

        int available = product.getAvailableQuantity();
        if (available < quantity) {
            throw new InsufficientStockException(productId, quantity, available);
        }

        StockReservedEvent event = new StockReservedEvent(productId, quantity, orderId);

        // Set saga context fields for downstream payment processing
        event.setCustomerId(customerId);
        event.setAmount(amount);
        event.setCurrency(currency);
        event.setMethod(method);

        SagaMetadata sagaMetadata = SagaMetadata.builder()
                .sagaId(sagaId)
                .sagaType(SagaCompensationConfig.ORDER_FULFILLMENT_SAGA)
                .stepNumber(SagaCompensationConfig.STEP_STOCK_RESERVED)
                .build();

        return controller.handleEvent(event, UUID.fromString(correlationId), sagaMetadata)
                .thenApply(completionInfo -> {
                    logger.debug("Stock reserved event processed for saga: {} (sagaId: {})",
                            completionInfo.getEventId(), sagaId);

                    // Record step 1 completed
                    sagaStateStore.recordStepCompleted(
                            sagaId,
                            SagaCompensationConfig.STEP_STOCK_RESERVED,
                            SagaCompensationConfig.STOCK_RESERVED,
                            SagaCompensationConfig.INVENTORY_SERVICE,
                            completionInfo.getEventId()
                    );

                    return getProductOrThrow(productId);
                });
    }

    /**
     * Releases previously reserved stock.
     *
     * @param productId the product ID
     * @param quantity the quantity to release
     * @param orderId the order ID releasing the stock
     * @param reason the reason for releasing
     * @return a future that completes with the updated product
     * @throws ProductNotFoundException if product does not exist
     */
    @Override
    public CompletableFuture<Product> releaseStock(String productId, int quantity, String orderId, String reason) {
        logger.info("Releasing {} units of product {} for order {} (reason: {})",
                quantity, productId, orderId, reason);

        if (!productExists(productId)) {
            throw new ProductNotFoundException(productId);
        }

        StockReleasedEvent event = new StockReleasedEvent(productId, quantity, orderId, reason);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Stock released event processed: {}", completionInfo.getEventId());
                    return getProductOrThrow(productId);
                });
    }

    /**
     * Checks if a product exists in the materialized view.
     *
     * @param productId the product ID
     * @return true if the product exists
     */
    @Override
    public boolean productExists(String productId) {
        return controller.getViewStore().containsKey(productId);
    }

    /**
     * Gets a product or throws an exception if not found.
     *
     * @param productId the product ID
     * @return the product
     * @throws ProductNotFoundException if product does not exist
     */
    private Product getProductOrThrow(String productId) {
        return getProduct(productId)
                .orElseThrow(() -> new ProductNotFoundException(productId));
    }

    /**
     * Rebuilds the product view from the event store.
     * Use with caution - this can be expensive for large event stores.
     *
     * @return the number of events replayed
     */
    public long rebuildView() {
        logger.info("Rebuilding product view");
        return controller.rebuildView();
    }

    /**
     * Returns the event sourcing controller for advanced operations.
     *
     * @return the controller
     */
    public EventSourcingController<Product, String, DomainEvent<Product, String>> getController() {
        return controller;
    }
}
