package com.theyawns.ecommerce.inventory.service;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.common.dto.ProductDTO;
import com.theyawns.ecommerce.common.events.ProductCreatedEvent;
import com.theyawns.ecommerce.common.events.StockReleasedEvent;
import com.theyawns.ecommerce.common.events.StockReplenishedEvent;
import com.theyawns.ecommerce.common.events.StockReservedEvent;
import com.theyawns.ecommerce.common.util.GenericRecordConverter;
import com.theyawns.ecommerce.inventory.exception.InsufficientStockException;
import com.theyawns.ecommerce.inventory.exception.ProductNotFoundException;
import com.theyawns.framework.controller.EventSourcingController;
import com.theyawns.framework.controller.SagaMetadata;
import com.theyawns.framework.event.DomainEvent;
import com.theyawns.framework.saga.SagaCompensationConfig;
import com.theyawns.framework.saga.SagaStateStore;
import com.theyawns.framework.vectorstore.TextEmbeddingGenerator;
import com.theyawns.framework.vectorstore.VectorStoreProperties;
import com.theyawns.framework.vectorstore.VectorStoreService;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Business logic service for product inventory management.
 *
 * <p>All operations use the event sourcing controller to:
 * <ul>
 *   <li>Publish domain events</li>
 *   <li>Update the materialized view</li>
 *   <li>Return async completion futures</li>
 * </ul>
 *
 * <p>Read operations use the materialized view for fast lookups.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Service
public class InventoryService implements ProductService {

    private static final Logger logger = LoggerFactory.getLogger(InventoryService.class);

    /**
     * IMap name for tracking stock reservations by orderId.
     * Used during saga compensation to know which products/quantities to release.
     */
    private static final String ORDER_RESERVATIONS_MAP = "OrderStockReservations";

    private final EventSourcingController<Product, String, DomainEvent<Product, String>> controller;
    private final SagaStateStore sagaStateStore;
    private final HazelcastInstance hazelcast;
    private final VectorStoreService vectorStoreService;
    private final VectorStoreProperties vectorStoreProperties;

    /**
     * Creates a new InventoryService.
     *
     * @param controller the event sourcing controller for product events
     * @param sagaStateStore the saga state store for tracking distributed transactions
     * @param hazelcast the Hazelcast instance
     * @param vectorStoreService the vector store service for product embeddings
     * @param vectorStoreProperties the vector store configuration properties
     */
    public InventoryService(
            EventSourcingController<Product, String, DomainEvent<Product, String>> controller,
            SagaStateStore sagaStateStore,
            HazelcastInstance hazelcast,
            VectorStoreService vectorStoreService,
            VectorStoreProperties vectorStoreProperties) {
        this.controller = controller;
        this.sagaStateStore = sagaStateStore;
        this.hazelcast = hazelcast;
        this.vectorStoreService = vectorStoreService;
        this.vectorStoreProperties = vectorStoreProperties;
    }

    /**
     * Creates a new product.
     *
     * @param dto the product data
     * @return a future that completes with the created product
     */
    @Override
    public CompletableFuture<Product> createProduct(ProductDTO dto) {
        String productId = UUID.randomUUID().toString();
        logger.info("Creating product with ID: {}", productId);

        ProductCreatedEvent event = new ProductCreatedEvent(
                productId,
                dto.getSku(),
                dto.getName(),
                dto.getPrice(),
                dto.getQuantityOnHand()
        );
        event.setDescription(dto.getDescription());
        event.setCategory(dto.getCategory());

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Product created event processed: {}", completionInfo.getEventId());
                    Product product = getProductOrThrow(productId);
                    storeProductEmbedding(product);
                    return product;
                });
    }

    /**
     * Retrieves a product by ID from the materialized view.
     *
     * @param productId the product ID
     * @return the product, or empty if not found
     */
    @Override
    public Optional<Product> getProduct(String productId) {
        logger.debug("Getting product: {}", productId);
        return controller.getViewState(productId)
                .map(Product::fromGenericRecord);
    }

    /**
     * Reserves stock for an order.
     *
     * @param productId the product ID
     * @param quantity the quantity to reserve
     * @param orderId the order ID requesting the reservation
     * @return a future that completes with the updated product
     * @throws ProductNotFoundException if product does not exist
     * @throws InsufficientStockException if insufficient stock available
     */
    @Override
    public CompletableFuture<Product> reserveStock(String productId, int quantity, String orderId) {
        logger.info("Reserving {} units of product {} for order {}", quantity, productId, orderId);

        Product product = getProductOrThrow(productId);

        // Check available stock
        int available = product.getAvailableQuantity();
        if (available < quantity) {
            throw new InsufficientStockException(productId, quantity, available);
        }

        StockReservedEvent event = new StockReservedEvent(productId, quantity, orderId);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Stock reserved event processed: {}", completionInfo.getEventId());
                    return getProductOrThrow(productId);
                });
    }

    /**
     * Reserves stock for an order as part of a saga.
     *
     * <p>This method propagates saga context (sagaId, correlationId) through
     * the StockReservedEvent and records step 1 completion in the SagaStateStore.
     * It also sets payment context fields on the event so the downstream
     * PaymentService can process payment.
     *
     * @param productId the product ID
     * @param quantity the quantity to reserve
     * @param orderId the order ID
     * @param sagaId the saga instance ID
     * @param correlationId the correlation ID
     * @param customerId the customer ID (propagated for payment)
     * @param amount the order amount (propagated for payment)
     * @param currency the currency code (propagated for payment)
     * @param method the payment method (propagated for payment)
     * @return a future that completes with the updated product
     * @throws ProductNotFoundException if product does not exist
     * @throws InsufficientStockException if insufficient stock available
     */
    public CompletableFuture<Product> reserveStockForSaga(
            final String productId, final int quantity, final String orderId,
            final String sagaId, final String correlationId,
            final String customerId, final String amount,
            final String currency, final String method) {

        logger.info("Reserving {} units of product {} for order {} (sagaId: {})",
                quantity, productId, orderId, sagaId);

        Product product = getProductOrThrow(productId);

        int available = product.getAvailableQuantity();
        if (available < quantity) {
            throw new InsufficientStockException(productId, quantity, available);
        }

        StockReservedEvent event = new StockReservedEvent(productId, quantity, orderId);

        // Set saga context fields for downstream payment processing
        event.setCustomerId(customerId);
        event.setAmount(amount);
        event.setCurrency(currency);
        event.setMethod(method);

        SagaMetadata sagaMetadata = SagaMetadata.builder()
                .sagaId(sagaId)
                .sagaType(SagaCompensationConfig.ORDER_FULFILLMENT_SAGA)
                .stepNumber(SagaCompensationConfig.STEP_STOCK_RESERVED)
                .build();

        return controller.handleEvent(event, UUID.fromString(correlationId), sagaMetadata)
                .thenApply(completionInfo -> {
                    logger.debug("Stock reserved event processed for saga: {} (sagaId: {})",
                            completionInfo.getEventId(), sagaId);

                    // Track the reservation for potential compensation
                    trackReservation(orderId, productId, quantity);

                    // Record step 1 completed
                    sagaStateStore.recordStepCompleted(
                            sagaId,
                            SagaCompensationConfig.STEP_STOCK_RESERVED,
                            SagaCompensationConfig.STOCK_RESERVED,
                            SagaCompensationConfig.INVENTORY_SERVICE,
                            completionInfo.getEventId()
                    );

                    return getProductOrThrow(productId);
                });
    }

    /**
     * Releases all previously reserved stock for an order as part of saga compensation.
     *
     * <p>Looks up tracked reservations by orderId and releases stock for each
     * product that was reserved during the saga's stock reservation step.
     * Records the compensation step in the SagaStateStore.
     *
     * @param orderId the order ID whose reservations should be released
     * @param sagaId the saga instance ID
     * @param correlationId the correlation ID
     * @param reason the reason for releasing
     * @return a future that completes with the last updated product (or completed with null if no reservations)
     */
    @Override
    public CompletableFuture<Product> releaseStockForSaga(
            final String orderId, final String sagaId,
            final String correlationId, final String reason) {

        logger.info("Releasing reserved stock for order {} (saga compensation, sagaId: {})", orderId, sagaId);

        List<String> reservationEntries = getReservations(orderId);
        if (reservationEntries.isEmpty()) {
            logger.warn("No tracked reservations found for order: {} (sagaId: {})", orderId, sagaId);
            // Still record compensation step even if no reservations found
            sagaStateStore.recordCompensationStep(
                    sagaId,
                    SagaCompensationConfig.STEP_STOCK_RESERVED,
                    SagaCompensationConfig.STOCK_RELEASED,
                    SagaCompensationConfig.INVENTORY_SERVICE
            );
            return CompletableFuture.completedFuture(null);
        }

        SagaMetadata sagaMetadata = SagaMetadata.builder()
                .sagaId(sagaId)
                .sagaType(SagaCompensationConfig.ORDER_FULFILLMENT_SAGA)
                .stepNumber(SagaCompensationConfig.STEP_STOCK_RESERVED)
                .compensating(true)
                .build();

        CompletableFuture<Product> lastFuture = CompletableFuture.completedFuture(null);

        for (String entry : reservationEntries) {
            String[] parts = entry.split(":");
            String productId = parts[0];
            int quantity = Integer.parseInt(parts[1]);

            logger.info("Releasing {} units of product {} for order {} (sagaId: {})",
                    quantity, productId, orderId, sagaId);

            StockReleasedEvent event = new StockReleasedEvent(productId, quantity, orderId, reason);
            event.setIsCompensating(true);

            lastFuture = controller.handleEvent(event, UUID.fromString(correlationId), sagaMetadata)
                    .thenApply(completionInfo -> {
                        logger.debug("Stock released for product {} in saga: {} (sagaId: {})",
                                productId, completionInfo.getEventId(), sagaId);
                        return getProductOrThrow(productId);
                    });
        }

        // Record compensation step after all releases
        return lastFuture.thenApply(product -> {
            sagaStateStore.recordCompensationStep(
                    sagaId,
                    SagaCompensationConfig.STEP_STOCK_RESERVED,
                    SagaCompensationConfig.STOCK_RELEASED,
                    SagaCompensationConfig.INVENTORY_SERVICE
            );
            return product;
        });
    }

    /**
     * Reserves stock for an order as part of an orchestrated saga.
     *
     * <p>Same business logic as {@link #reserveStockForSaga} but does not set
     * SagaMetadata on the event or record saga state. The orchestrator manages
     * all saga state externally. Still tracks the reservation for compensation.
     *
     * @param productId the product ID
     * @param quantity the quantity to reserve
     * @param orderId the order ID
     * @return a future that completes with the updated product
     * @throws ProductNotFoundException if product does not exist
     * @throws InsufficientStockException if insufficient stock available
     */
    public CompletableFuture<Product> reserveStockOrchestrated(
            final String productId, final int quantity, final String orderId) {

        logger.info("Reserving {} units of product {} for order {} (orchestrated)", quantity, productId, orderId);

        Product product = getProductOrThrow(productId);

        int available = product.getAvailableQuantity();
        if (available < quantity) {
            throw new InsufficientStockException(productId, quantity, available);
        }

        StockReservedEvent event = new StockReservedEvent(productId, quantity, orderId);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Stock reserved event processed (orchestrated): {}", completionInfo.getEventId());

                    // Track the reservation for potential compensation
                    trackReservation(orderId, productId, quantity);

                    return getProductOrThrow(productId);
                });
    }

    /**
     * Releases all previously reserved stock for an order as part of an orchestrated saga.
     *
     * <p>Same business logic as {@link #releaseStockForSaga} but does not set
     * SagaMetadata or record saga state. The orchestrator handles compensation tracking.
     *
     * @param orderId the order ID whose reservations should be released
     * @param reason the reason for releasing
     * @return a future that completes with the last updated product (or null if no reservations)
     */
    public CompletableFuture<Product> releaseStockOrchestrated(
            final String orderId, final String reason) {

        logger.info("Releasing reserved stock for order {} (orchestrated compensation)", orderId);

        List<String> reservationEntries = getReservations(orderId);
        if (reservationEntries.isEmpty()) {
            logger.warn("No tracked reservations found for order: {} (orchestrated)", orderId);
            return CompletableFuture.completedFuture(null);
        }

        CompletableFuture<Product> lastFuture = CompletableFuture.completedFuture(null);

        for (String entry : reservationEntries) {
            String[] parts = entry.split(":");
            String productId = parts[0];
            int qty = Integer.parseInt(parts[1]);

            logger.info("Releasing {} units of product {} for order {} (orchestrated)", qty, productId, orderId);

            StockReleasedEvent releaseEvent = new StockReleasedEvent(productId, qty, orderId, reason);
            releaseEvent.setIsCompensating(true);

            lastFuture = controller.handleEvent(releaseEvent)
                    .thenApply(completionInfo -> {
                        logger.debug("Stock released for product {} (orchestrated, orderId: {})",
                                productId, orderId);
                        return getProductOrThrow(productId);
                    });
        }

        return lastFuture;
    }

    /**
     * Releases previously reserved stock.
     *
     * @param productId the product ID
     * @param quantity the quantity to release
     * @param orderId the order ID releasing the stock
     * @param reason the reason for releasing
     * @return a future that completes with the updated product
     * @throws ProductNotFoundException if product does not exist
     */
    @Override
    public CompletableFuture<Product> releaseStock(String productId, int quantity, String orderId, String reason) {
        logger.info("Releasing {} units of product {} for order {} (reason: {})",
                quantity, productId, orderId, reason);

        if (!productExists(productId)) {
            throw new ProductNotFoundException(productId);
        }

        StockReleasedEvent event = new StockReleasedEvent(productId, quantity, orderId, reason);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Stock released event processed: {}", completionInfo.getEventId());
                    return getProductOrThrow(productId);
                });
    }

    /**
     * Replenishes stock for a product.
     *
     * <p>Adds the specified quantity to the product's on-hand stock and
     * processes the event through the event sourcing pipeline.
     *
     * @param productId the product ID
     * @param quantity the quantity to add
     * @param reason the replenishment reason (e.g., "AUTO_REORDER", "MANUAL")
     * @return a future that completes with the updated product
     * @throws ProductNotFoundException if product does not exist
     */
    @Override
    public CompletableFuture<Product> replenishStock(String productId, int quantity, String reason) {
        logger.info("Replenishing {} units of product {} (reason: {})", quantity, productId, reason);

        Product product = getProductOrThrow(productId);

        int newQuantityOnHand = product.getQuantityOnHand() + quantity;
        StockReplenishedEvent event = new StockReplenishedEvent(
                productId, quantity, newQuantityOnHand, reason);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Stock replenished event processed: {}", completionInfo.getEventId());
                    return getProductOrThrow(productId);
                });
    }

    /**
     * Releases all reserved stock for an order (non-saga path).
     *
     * <p>Looks up tracked reservations by orderId and releases stock for each
     * product without recording saga compensation steps.
     *
     * @param orderId the order ID whose reservations should be released
     * @param reason the reason for releasing
     * @return a future that completes with the last updated product (or null if no reservations)
     */
    @Override
    public CompletableFuture<Product> releaseReservedStockForOrder(
            final String orderId, final String reason) {

        logger.info("Releasing reserved stock for order {} (direct cancellation)", orderId);

        List<String> reservationEntries = getReservations(orderId);
        if (reservationEntries.isEmpty()) {
            logger.warn("No tracked reservations found for order: {}", orderId);
            return CompletableFuture.completedFuture(null);
        }

        CompletableFuture<Product> lastFuture = CompletableFuture.completedFuture(null);

        for (String entry : reservationEntries) {
            String[] parts = entry.split(":");
            String productId = parts[0];
            int quantity = Integer.parseInt(parts[1]);

            logger.info("Releasing {} units of product {} for order {} (direct cancellation)",
                    quantity, productId, orderId);

            StockReleasedEvent event = new StockReleasedEvent(productId, quantity, orderId, reason);

            lastFuture = controller.handleEvent(event)
                    .thenApply(completionInfo -> {
                        logger.debug("Stock released for product {} (direct cancellation, orderId: {})",
                                productId, orderId);
                        return getProductOrThrow(productId);
                    });
        }

        return lastFuture;
    }

    /**
     * Checks if a product exists in the materialized view.
     *
     * @param productId the product ID
     * @return true if the product exists
     */
    @Override
    public boolean productExists(String productId) {
        return controller.getViewStore().containsKey(productId);
    }

    /**
     * Generates and stores a vector embedding for the given product.
     *
     * <p>Builds a text representation from the product's name, description, and category,
     * then generates a deterministic embedding and stores it in the vector store.
     * This is a best-effort operation â€” failures are logged but do not prevent
     * product creation from succeeding.
     *
     * @param product the product to generate an embedding for
     */
    private void storeProductEmbedding(final Product product) {
        try {
            StringBuilder text = new StringBuilder();
            text.append(product.getName());
            if (product.getDescription() != null) {
                text.append(" ").append(product.getDescription());
            }
            if (product.getCategory() != null) {
                text.append(" ").append(product.getCategory());
            }

            float[] embedding = TextEmbeddingGenerator.generateEmbedding(
                    text.toString(), vectorStoreProperties.getDimension());

            Map<String, Object> metadata = new HashMap<>();
            metadata.put("name", product.getName());
            metadata.put("category", product.getCategory());

            vectorStoreService.storeEmbedding(product.getProductId(), embedding, metadata);
            logger.debug("Stored embedding for product: {}", product.getProductId());
        } catch (Exception e) {
            logger.warn("Failed to store embedding for product: {} (non-fatal)", product.getProductId(), e);
        }
    }

    /**
     * Gets a product or throws an exception if not found.
     *
     * @param productId the product ID
     * @return the product
     * @throws ProductNotFoundException if product does not exist
     */
    private Product getProductOrThrow(String productId) {
        return getProduct(productId)
                .orElseThrow(() -> new ProductNotFoundException(productId));
    }

    /**
     * Tracks a stock reservation by orderId for potential compensation.
     * Stored as "productId:quantity" entries in a list per orderId.
     *
     * @param orderId the order ID
     * @param productId the product ID
     * @param quantity the quantity reserved
     */
    @SuppressWarnings("unchecked")
    private void trackReservation(String orderId, String productId, int quantity) {
        IMap<String, List<String>> reservations = hazelcast.getMap(ORDER_RESERVATIONS_MAP);
        reservations.executeOnKey(orderId, entry -> {
            List<String> items = entry.getValue();
            if (items == null) {
                items = new ArrayList<>();
            }
            items.add(productId + ":" + quantity);
            entry.setValue(items);
            return null;
        });
    }

    /**
     * Looks up tracked reservations for an orderId.
     *
     * @param orderId the order ID
     * @return list of "productId:quantity" entries, or empty list
     */
    List<String> getReservations(String orderId) {
        IMap<String, List<String>> reservations = hazelcast.getMap(ORDER_RESERVATIONS_MAP);
        List<String> items = reservations.get(orderId);
        return items != null ? items : new ArrayList<>();
    }

    /**
     * Lists all products from the materialized view, up to the specified limit.
     *
     * @param limit the maximum number of products to return
     * @return list of products
     */
    @Override
    public List<Product> listAll(int limit) {
        logger.debug("Listing products (limit: {})", limit);
        return controller.getViewStore().values().stream()
                .limit(limit)
                .map(Product::fromGenericRecord)
                .collect(Collectors.toList());
    }

    /**
     * Retrieves the event history for a product.
     *
     * @param productId the product ID
     * @param limit the maximum number of events to return
     * @return list of events as maps
     */
    @Override
    public List<Map<String, Object>> getEventHistory(String productId, int limit) {
        logger.debug("Getting event history for product: {} (limit: {})", productId, limit);
        List<GenericRecord> events = controller.getEventStore().getEventsByKey(productId);
        return events.stream()
                .limit(limit)
                .map(GenericRecordConverter::toMap)
                .collect(Collectors.toList());
    }

    /**
     * Rebuilds the product view from the event store.
     * Use with caution - this can be expensive for large event stores.
     *
     * @return the number of events replayed
     */
    public long rebuildView() {
        logger.info("Rebuilding product view");
        return controller.rebuildView();
    }

    /**
     * Returns the event sourcing controller for advanced operations.
     *
     * @return the controller
     */
    public EventSourcingController<Product, String, DomainEvent<Product, String>> getController() {
        return controller;
    }
}
