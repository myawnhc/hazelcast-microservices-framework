package com.theyawns.ecommerce.inventory.controller;

import com.theyawns.ecommerce.common.dto.ProductDTO;
import com.theyawns.ecommerce.inventory.dto.SimilarProductsResponse;
import com.theyawns.ecommerce.inventory.service.ProductService;
import com.theyawns.framework.vectorstore.SimilarityResult;
import com.theyawns.framework.vectorstore.VectorStoreService;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import jakarta.validation.constraints.Min;
import jakarta.validation.constraints.NotBlank;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * REST controller for product inventory management.
 *
 * <p>Endpoints:
 * <ul>
 *   <li>POST /api/products - Create a new product</li>
 *   <li>GET /api/products/{id} - Get product by ID</li>
 *   <li>POST /api/products/{id}/stock/reserve - Reserve stock for an order</li>
 *   <li>POST /api/products/{id}/stock/release - Release reserved stock</li>
 *   <li>GET /api/products/{id}/similar - Find similar products (Enterprise feature)</li>
 *   <li>GET /api/products - List all products</li>
 *   <li>GET /api/products/{id}/events - Get product event history</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@RestController
@RequestMapping("/api/products")
@Tag(name = "Product Inventory", description = "APIs for managing products and stock levels")
public class InventoryController {

    private static final Logger logger = LoggerFactory.getLogger(InventoryController.class);

    private final ProductService productService;
    private final VectorStoreService vectorStoreService;

    /**
     * Creates a new InventoryController.
     *
     * @param productService the product service
     * @param vectorStoreService the vector store service for similarity search
     */
    public InventoryController(ProductService productService, VectorStoreService vectorStoreService) {
        this.productService = productService;
        this.vectorStoreService = vectorStoreService;
    }

    /**
     * Creates a new product.
     *
     * @param dto the product data
     * @return the created product
     */
    @PostMapping
    @Operation(summary = "Create a new product", description = "Adds a new product to the catalog")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Product created successfully",
                    content = @Content(schema = @Schema(implementation = ProductDTO.class))),
            @ApiResponse(responseCode = "400", description = "Invalid product data")
    })
    public CompletableFuture<ResponseEntity<ProductDTO>> createProduct(@Valid @RequestBody ProductDTO dto) {
        logger.info("REST: Creating product with SKU: {}", dto.getSku());

        return productService.createProduct(dto)
                .thenApply(product -> {
                    ProductDTO response = product.toDTO();
                    logger.info("REST: Product created with ID: {}", response.getProductId());
                    return ResponseEntity.status(HttpStatus.CREATED).body(response);
                });
    }

    /**
     * Retrieves a product by ID.
     *
     * @param productId the product ID
     * @return the product, or 404 if not found
     */
    @GetMapping("/{productId}")
    @Operation(summary = "Get product by ID", description = "Retrieves product details including stock levels")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Product found",
                    content = @Content(schema = @Schema(implementation = ProductDTO.class))),
            @ApiResponse(responseCode = "404", description = "Product not found")
    })
    public ResponseEntity<ProductDTO> getProduct(
            @Parameter(description = "Product ID", required = true) @PathVariable String productId) {
        logger.debug("REST: Getting product: {}", productId);

        return productService.getProduct(productId)
                .map(product -> {
                    ProductDTO dto = product.toDTO();
                    return ResponseEntity.ok(dto);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * Reserves stock for an order.
     *
     * @param productId the product ID
     * @param request the reservation request
     * @return the updated product
     */
    @PostMapping("/{productId}/stock/reserve")
    @Operation(summary = "Reserve stock", description = "Reserves product stock for an order")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Stock reserved successfully",
                    content = @Content(schema = @Schema(implementation = ProductDTO.class))),
            @ApiResponse(responseCode = "400", description = "Insufficient stock or invalid request"),
            @ApiResponse(responseCode = "404", description = "Product not found")
    })
    public CompletableFuture<ResponseEntity<ProductDTO>> reserveStock(
            @Parameter(description = "Product ID", required = true) @PathVariable String productId,
            @Valid @RequestBody StockReservationRequest request) {
        logger.info("REST: Reserving {} units of product {} for order {}",
                request.quantity(), productId, request.orderId());

        return productService.reserveStock(productId, request.quantity(), request.orderId())
                .thenApply(product -> {
                    ProductDTO response = product.toDTO();
                    logger.info("REST: Stock reserved for product {}, available: {}",
                            productId, response.getAvailableQuantity());
                    return ResponseEntity.ok(response);
                });
    }

    /**
     * Releases previously reserved stock.
     *
     * @param productId the product ID
     * @param request the release request
     * @return the updated product
     */
    @PostMapping("/{productId}/stock/release")
    @Operation(summary = "Release stock", description = "Releases previously reserved stock back to available inventory")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Stock released successfully",
                    content = @Content(schema = @Schema(implementation = ProductDTO.class))),
            @ApiResponse(responseCode = "400", description = "Invalid request"),
            @ApiResponse(responseCode = "404", description = "Product not found")
    })
    public CompletableFuture<ResponseEntity<ProductDTO>> releaseStock(
            @Parameter(description = "Product ID", required = true) @PathVariable String productId,
            @Valid @RequestBody StockReleaseRequest request) {
        logger.info("REST: Releasing {} units of product {} for order {} (reason: {})",
                request.quantity(), productId, request.orderId(), request.reason());

        return productService.releaseStock(productId, request.quantity(), request.orderId(), request.reason())
                .thenApply(product -> {
                    ProductDTO response = product.toDTO();
                    logger.info("REST: Stock released for product {}, available: {}",
                            productId, response.getAvailableQuantity());
                    return ResponseEntity.ok(response);
                });
    }

    /**
     * Finds products similar to the given product.
     *
     * <p>Requires Enterprise Edition with Vector Store enabled. On Community Edition,
     * returns an empty list with an informational message.
     *
     * @param productId the product ID to find similar products for
     * @param limit the maximum number of similar products to return (default 5)
     * @return similar products response
     */
    @GetMapping("/{productId}/similar")
    @Operation(summary = "Find similar products",
            description = "Returns products similar to the given product using vector similarity search. " +
                    "Requires Enterprise Edition; returns empty results on Community Edition.")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Similar products (may be empty on Community Edition)",
                    content = @Content(schema = @Schema(implementation = SimilarProductsResponse.class))),
            @ApiResponse(responseCode = "404", description = "Product not found")
    })
    public ResponseEntity<SimilarProductsResponse> findSimilarProducts(
            @Parameter(description = "Product ID", required = true) @PathVariable String productId,
            @Parameter(description = "Maximum number of results") @RequestParam(defaultValue = "5") int limit) {

        logger.debug("REST: Finding products similar to: {} (limit={})", productId, limit);

        // Verify the product exists
        if (!productService.productExists(productId)) {
            return ResponseEntity.notFound().build();
        }

        if (!vectorStoreService.isAvailable()) {
            logger.debug("Vector store not available; returning empty results for product: {}", productId);
            SimilarProductsResponse response = new SimilarProductsResponse(
                    productId,
                    false,
                    vectorStoreService.getImplementationType(),
                    "Vector similarity search requires Enterprise Edition. " +
                            "Running on Community Edition â€” no similar products available.",
                    List.of()
            );
            return ResponseEntity.ok(response);
        }

        List<SimilarityResult> results = vectorStoreService.findSimilarById(productId, limit);

        // Convert similarity results to ProductDTOs
        List<ProductDTO> similarProducts = new ArrayList<>();
        for (SimilarityResult result : results) {
            productService.getProduct(result.id())
                    .ifPresent(product -> similarProducts.add(product.toDTO()));
        }

        SimilarProductsResponse response = new SimilarProductsResponse(
                productId,
                true,
                vectorStoreService.getImplementationType(),
                "Found " + similarProducts.size() + " similar products",
                similarProducts
        );
        return ResponseEntity.ok(response);
    }

    /**
     * Lists all products, up to the specified limit.
     *
     * @param limit the maximum number of products to return (default: 10)
     * @return list of products
     */
    @GetMapping
    @Operation(summary = "List products", description = "Lists all products from the materialized view")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Products retrieved")
    })
    public ResponseEntity<List<ProductDTO>> listProducts(
            @Parameter(description = "Maximum number of results") @RequestParam(defaultValue = "10") int limit) {
        logger.debug("REST: Listing products (limit: {})", limit);

        List<ProductDTO> products = productService.listAll(limit).stream()
                .map(product -> product.toDTO())
                .collect(Collectors.toList());

        return ResponseEntity.ok(products);
    }

    /**
     * Retrieves event history for a product.
     *
     * @param productId the product ID
     * @param limit the maximum number of events to return (default: 20)
     * @return list of events
     */
    @GetMapping("/{productId}/events")
    @Operation(summary = "Get product event history",
            description = "Retrieves the event history for a product from the event store")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Event history retrieved")
    })
    public ResponseEntity<List<Map<String, Object>>> getEventHistory(
            @Parameter(description = "Product ID", required = true) @PathVariable String productId,
            @Parameter(description = "Maximum number of events") @RequestParam(defaultValue = "20") int limit) {
        logger.debug("REST: Getting event history for product: {} (limit: {})", productId, limit);

        List<Map<String, Object>> events = productService.getEventHistory(productId, limit);
        return ResponseEntity.ok(events);
    }

    /**
     * Request body for stock reservation.
     *
     * @param quantity the quantity to reserve
     * @param orderId the order ID requesting the reservation
     */
    public record StockReservationRequest(
            @Min(value = 1, message = "Quantity must be at least 1")
            int quantity,

            @NotBlank(message = "Order ID is required")
            String orderId
    ) {
    }

    /**
     * Request body for stock release.
     *
     * @param quantity the quantity to release
     * @param orderId the order ID releasing the stock
     * @param reason the reason for releasing
     */
    public record StockReleaseRequest(
            @Min(value = 1, message = "Quantity must be at least 1")
            int quantity,

            @NotBlank(message = "Order ID is required")
            String orderId,

            @NotBlank(message = "Reason is required")
            String reason
    ) {
    }
}
