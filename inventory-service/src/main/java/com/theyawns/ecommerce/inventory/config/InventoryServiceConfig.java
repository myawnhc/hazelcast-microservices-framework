package com.theyawns.ecommerce.inventory.config;

import com.hazelcast.config.Config;
import com.hazelcast.config.EventJournalConfig;
import com.hazelcast.config.MapConfig;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.inventory.domain.ProductViewUpdater;
import com.theyawns.framework.controller.EventSourcingController;
import com.theyawns.framework.event.DomainEvent;
import com.theyawns.framework.store.HazelcastEventStore;
import com.theyawns.framework.view.HazelcastViewStore;
import io.micrometer.core.instrument.MeterRegistry;
import jakarta.annotation.PostConstruct;
import jakarta.annotation.PreDestroy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

/**
 * Spring configuration for the Inventory Service.
 *
 * <p>Configures:
 * <ul>
 *   <li>Hazelcast instance with event journal</li>
 *   <li>Event store for product events</li>
 *   <li>View store and updater for product materialized view</li>
 *   <li>Event sourcing controller</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Configuration
public class InventoryServiceConfig {

    private static final Logger logger = LoggerFactory.getLogger(InventoryServiceConfig.class);

    private static final String DOMAIN_NAME = "Product";

    @Value("${hazelcast.cluster.name:ecommerce-cluster}")
    private String clusterName;

    @Value("${hazelcast.event-journal.capacity:10000}")
    private int eventJournalCapacity;

    private EventSourcingController<Product, String, DomainEvent<Product, String>> controller;

    /**
     * Creates the Hazelcast instance for the Inventory Service.
     *
     * @return the configured Hazelcast instance
     */
    @Bean
    public HazelcastInstance hazelcastInstance() {
        Config config = new Config();
        String effectiveClusterName = (clusterName != null && !clusterName.isEmpty())
                ? clusterName
                : "ecommerce-cluster";
        logger.info("Cluster name from config: '{}', effective: '{}'", clusterName, effectiveClusterName);
        config.setClusterName(effectiveClusterName);

        // Enable event journal for pending events map (required for Jet streaming)
        int effectiveCapacity = eventJournalCapacity > 0 ? eventJournalCapacity : 10000;
        EventJournalConfig journalConfig = new EventJournalConfig()
                .setEnabled(true)
                .setCapacity(effectiveCapacity);

        MapConfig pendingMapConfig = new MapConfig(DOMAIN_NAME + "_PENDING")
                .setEventJournalConfig(journalConfig);
        config.addMapConfig(pendingMapConfig);

        // Configure view map
        MapConfig viewMapConfig = new MapConfig(DOMAIN_NAME + "_VIEW");
        config.addMapConfig(viewMapConfig);

        // Configure event store map
        MapConfig eventStoreMapConfig = new MapConfig(DOMAIN_NAME + "_ES");
        config.addMapConfig(eventStoreMapConfig);

        logger.info("Creating Hazelcast instance for cluster: {}", clusterName);
        return Hazelcast.newHazelcastInstance(config);
    }

    /**
     * Creates the event store for product events.
     *
     * @param hazelcast the Hazelcast instance
     * @return the event store
     */
    @Bean
    public HazelcastEventStore<Product, String, DomainEvent<Product, String>> productEventStore(
            HazelcastInstance hazelcast) {
        return new HazelcastEventStore<>(hazelcast, DOMAIN_NAME);
    }

    /**
     * Creates the view store for the product materialized view.
     *
     * @param hazelcast the Hazelcast instance
     * @return the view store
     */
    @Bean
    public HazelcastViewStore<String> productViewStore(HazelcastInstance hazelcast) {
        return new HazelcastViewStore<>(hazelcast, DOMAIN_NAME);
    }

    /**
     * Creates the view updater that applies product events to the view.
     *
     * @param viewStore the view store
     * @return the view updater
     */
    @Bean
    public ProductViewUpdater productViewUpdater(HazelcastViewStore<String> viewStore) {
        return new ProductViewUpdater(viewStore);
    }

    /**
     * Creates the event sourcing controller for product operations.
     *
     * @param hazelcast the Hazelcast instance
     * @param eventStore the event store
     * @param viewUpdater the view updater
     * @param meterRegistry the metrics registry
     * @return the event sourcing controller
     */
    @Bean
    public EventSourcingController<Product, String, DomainEvent<Product, String>> productController(
            HazelcastInstance hazelcast,
            HazelcastEventStore<Product, String, DomainEvent<Product, String>> eventStore,
            ProductViewUpdater viewUpdater,
            MeterRegistry meterRegistry) {

        controller = EventSourcingController.<Product, String, DomainEvent<Product, String>>builder()
                .hazelcast(hazelcast)
                .domainName(DOMAIN_NAME)
                .eventStore(eventStore)
                .viewUpdater(viewUpdater)
                .meterRegistry(meterRegistry)
                .build();

        return controller;
    }

    /**
     * Starts the event sourcing pipeline after the controller is created.
     */
    @PostConstruct
    public void startPipeline() {
        if (controller != null) {
            logger.info("Starting Product event sourcing pipeline");
            controller.start();
        }
    }

    /**
     * Stops the event sourcing pipeline on shutdown.
     */
    @PreDestroy
    public void stopPipeline() {
        if (controller != null && controller.isRunning()) {
            logger.info("Stopping Product event sourcing pipeline");
            controller.stop();
        }
    }
}
