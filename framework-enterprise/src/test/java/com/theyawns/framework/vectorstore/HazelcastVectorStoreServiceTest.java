package com.theyawns.framework.vectorstore;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.condition.EnabledIf;

import java.util.List;
import java.util.Map;

import static org.assertj.core.api.Assertions.assertThat;

/**
 * Tests for {@link HazelcastVectorStoreService}.
 *
 * <p>Uses a real embedded Hazelcast Enterprise instance. These tests are skipped
 * if the {@code VectorCollection} class is not available on the classpath (i.e.,
 * Hazelcast Enterprise is not present or functional).
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("HazelcastVectorStoreService - VectorCollection-based vector store")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@EnabledIf("isVectorCollectionAvailable")
class HazelcastVectorStoreServiceTest {

    private HazelcastInstance hazelcast;
    private HazelcastVectorStoreService service;
    private int testRun;

    static boolean isVectorCollectionAvailable() {
        try {
            Class.forName("com.hazelcast.vector.VectorCollection");
            return true;
        } catch (ClassNotFoundException e) {
            return false;
        }
    }

    @BeforeAll
    void setUpHazelcast() {
        Config config = new Config();
        config.setClusterName("vector-collection-test-" + System.currentTimeMillis());
        config.getNetworkConfig().getJoin().getMulticastConfig().setEnabled(false);
        config.getNetworkConfig().getJoin().getAutoDetectionConfig().setEnabled(false);
        hazelcast = Hazelcast.newHazelcastInstance(config);
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void setUp() {
        // Use unique collection name per test to avoid collisions
        testRun++;
        VectorStoreProperties properties = new VectorStoreProperties();
        properties.setCollectionName("test-vectors-" + testRun);
        properties.setDimension(4);
        properties.setMetric("COSINE");
        properties.setIndexName("default");
        properties.setMaxConnections(16);
        properties.setEfConstruction(200);

        service = new HazelcastVectorStoreService(hazelcast, properties);
    }

    @Nested
    @DisplayName("Availability")
    class AvailabilityTests {

        @Test
        @DisplayName("should always report as available")
        void shouldBeAvailable() {
            assertThat(service.isAvailable()).isTrue();
        }

        @Test
        @DisplayName("should report correct implementation type")
        void shouldReportImplementationType() {
            assertThat(service.getImplementationType())
                    .isEqualTo("Hazelcast VectorCollection (Enterprise)");
        }
    }

    @Nested
    @DisplayName("storeEmbedding and retrieval")
    class StoreAndRetrieveTests {

        @Test
        @DisplayName("should store and retrieve embeddings")
        void shouldStoreAndRetrieve() {
            float[] embedding = {1.0f, 0.0f, 0.0f, 0.0f};
            service.storeEmbedding("item-1", embedding, Map.of("name", "Test Item"));

            List<SimilarityResult> results = service.findSimilar(embedding, 5);
            assertThat(results).isNotEmpty();
            assertThat(results.get(0).id()).isEqualTo("item-1");
            assertThat(results.get(0).metadata()).containsEntry("name", "Test Item");
        }

        @Test
        @DisplayName("should store embedding with null metadata")
        void shouldStoreWithNullMetadata() {
            float[] embedding = {0.0f, 1.0f, 0.0f, 0.0f};
            service.storeEmbedding("item-2", embedding, null);

            List<SimilarityResult> results = service.findSimilar(embedding, 5);
            assertThat(results).isNotEmpty();
            assertThat(results.get(0).id()).isEqualTo("item-2");
        }

        @Test
        @DisplayName("should store embedding with empty metadata")
        void shouldStoreWithEmptyMetadata() {
            float[] embedding = {0.0f, 0.0f, 1.0f, 0.0f};
            service.storeEmbedding("item-3", embedding, Map.of());

            List<SimilarityResult> results = service.findSimilar(embedding, 5);
            assertThat(results).isNotEmpty();
            assertThat(results.get(0).id()).isEqualTo("item-3");
        }
    }

    @Nested
    @DisplayName("findSimilar")
    class FindSimilarTests {

        @Test
        @DisplayName("should return results sorted by descending similarity")
        void shouldReturnSortedResults() {
            float[] query = {1.0f, 0.0f, 0.0f, 0.0f};

            service.storeEmbedding("a", new float[]{0.9f, 0.1f, 0.0f, 0.0f}, Map.of("name", "A"));
            service.storeEmbedding("b", new float[]{0.5f, 0.5f, 0.0f, 0.0f}, Map.of("name", "B"));
            service.storeEmbedding("c", new float[]{0.0f, 1.0f, 0.0f, 0.0f}, Map.of("name", "C"));

            List<SimilarityResult> results = service.findSimilar(query, 3);

            assertThat(results).hasSize(3);
            // First result should be most similar to query
            assertThat(results.get(0).id()).isEqualTo("a");
            assertThat(results.get(0).score()).isGreaterThan(results.get(1).score());
            assertThat(results.get(1).score()).isGreaterThan(results.get(2).score());
        }

        @Test
        @DisplayName("should respect the limit parameter")
        void shouldRespectLimit() {
            service.storeEmbedding("a", new float[]{1.0f, 0.0f, 0.0f, 0.0f}, Map.of());
            service.storeEmbedding("b", new float[]{0.5f, 0.5f, 0.0f, 0.0f}, Map.of());
            service.storeEmbedding("c", new float[]{0.0f, 1.0f, 0.0f, 0.0f}, Map.of());

            List<SimilarityResult> results = service.findSimilar(
                    new float[]{1.0f, 0.0f, 0.0f, 0.0f}, 2);

            assertThat(results).hasSize(2);
        }

        @Test
        @DisplayName("should include metadata in results")
        void shouldIncludeMetadata() {
            service.storeEmbedding("x", new float[]{1.0f, 0.0f, 0.0f, 0.0f},
                    Map.of("name", "Product X", "category", "Electronics"));

            List<SimilarityResult> results = service.findSimilar(
                    new float[]{1.0f, 0.0f, 0.0f, 0.0f}, 5);

            assertThat(results).isNotEmpty();
            assertThat(results.get(0).metadata()).containsEntry("name", "Product X");
            assertThat(results.get(0).metadata()).containsEntry("category", "Electronics");
        }
    }

    @Nested
    @DisplayName("findSimilarById")
    class FindSimilarByIdTests {

        @Test
        @DisplayName("should return empty list when ID not found")
        void shouldReturnEmptyWhenIdNotFound() {
            List<SimilarityResult> results = service.findSimilarById("unknown", 5);
            assertThat(results).isEmpty();
        }

        @Test
        @DisplayName("should exclude the query item from results")
        void shouldExcludeQueryItem() {
            service.storeEmbedding("query-id", new float[]{1.0f, 0.0f, 0.0f, 0.0f}, Map.of());
            service.storeEmbedding("other", new float[]{0.9f, 0.1f, 0.0f, 0.0f}, Map.of());

            List<SimilarityResult> results = service.findSimilarById("query-id", 5);

            assertThat(results).noneMatch(r -> r.id().equals("query-id"));
            assertThat(results).hasSize(1);
            assertThat(results.get(0).id()).isEqualTo("other");
        }
    }
}
