package com.theyawns.ecommerce.account.service;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.ecommerce.account.domain.CustomerViewUpdater;
import com.theyawns.ecommerce.account.exception.CustomerNotFoundException;
import com.theyawns.ecommerce.common.domain.Customer;
import com.theyawns.ecommerce.common.dto.CustomerDTO;
import com.theyawns.ecommerce.common.events.CustomerCreatedEvent;
import com.theyawns.ecommerce.common.events.CustomerStatusChangedEvent;
import com.theyawns.ecommerce.common.events.CustomerUpdatedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.time.Instant;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertThrows;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Unit tests for AccountService.
 * Tests the view updater logic directly without the full pipeline.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@DisplayName("AccountService - View Updater Logic")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class AccountServiceTest {

    private static final String DOMAIN_NAME = "CustomerTest";

    private HazelcastInstance hazelcast;
    private HazelcastViewStore<String> viewStore;
    private CustomerViewUpdater viewUpdater;

    @BeforeAll
    void setUpHazelcast() {
        Config config = new Config();
        config.setClusterName("account-service-test-" + System.currentTimeMillis());
        hazelcast = Hazelcast.newHazelcastInstance(config);
        viewStore = new HazelcastViewStore<>(hazelcast, DOMAIN_NAME);
        viewUpdater = new CustomerViewUpdater(viewStore);
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void clearView() {
        viewStore.clear();
    }

    @Nested
    @DisplayName("Create customer flow")
    class CreateCustomerTests {

        @Test
        @DisplayName("should create customer view from event")
        void shouldCreateCustomerViewFromEvent() {
            String customerId = UUID.randomUUID().toString();
            CustomerCreatedEvent event = new CustomerCreatedEvent(
                    customerId,
                    "test@example.com",
                    "John Doe",
                    "123 Main St"
            );
            event.setPhone("555-1234");

            GenericRecord eventRecord = event.toGenericRecord();
            GenericRecord result = viewUpdater.update(eventRecord);

            assertNotNull(result);
            assertEquals(customerId, result.getString("customerId"));
            assertEquals("test@example.com", result.getString("email"));
            assertEquals("John Doe", result.getString("name"));
            assertEquals("555-1234", result.getString("phone"));
            assertEquals(Customer.Status.ACTIVE.name(), result.getString("status"));

            // Verify stored in view
            Optional<GenericRecord> stored = viewStore.get(customerId);
            assertTrue(stored.isPresent());
            assertEquals("test@example.com", stored.get().getString("email"));
        }
    }

    @Nested
    @DisplayName("Update customer flow")
    class UpdateCustomerTests {

        @Test
        @DisplayName("should update customer view from event")
        void shouldUpdateCustomerViewFromEvent() {
            // First create a customer
            String customerId = UUID.randomUUID().toString();
            CustomerCreatedEvent createEvent = new CustomerCreatedEvent(
                    customerId,
                    "test@example.com",
                    "John Doe",
                    "123 Main St"
            );
            viewUpdater.update(createEvent.toGenericRecord());

            // Now update
            CustomerUpdatedEvent updateEvent = new CustomerUpdatedEvent(
                    customerId,
                    "John Smith",
                    "456 Oak Ave",
                    "555-9999"
            );
            GenericRecord result = viewUpdater.update(updateEvent.toGenericRecord());

            assertNotNull(result);
            assertEquals("John Smith", result.getString("name"));
            assertEquals("456 Oak Ave", result.getString("address"));
            assertEquals("555-9999", result.getString("phone"));

            // Verify email unchanged
            assertEquals("test@example.com", result.getString("email"));
        }

        @Test
        @DisplayName("should fail to update non-existent customer")
        void shouldFailToUpdateNonExistentCustomer() {
            String customerId = UUID.randomUUID().toString();
            CustomerUpdatedEvent updateEvent = new CustomerUpdatedEvent(
                    customerId,
                    "John Smith",
                    "456 Oak Ave",
                    "555-9999"
            );

            // Should not throw, but return null
            GenericRecord result = viewUpdater.update(updateEvent.toGenericRecord());

            // Update returns the result of applyEvent, which is null for non-existent
            // But the update method stores the result, so check the view
            Optional<GenericRecord> stored = viewStore.get(customerId);
            assertFalse(stored.isPresent());
        }
    }

    @Nested
    @DisplayName("Change status flow")
    class ChangeStatusTests {

        @Test
        @DisplayName("should change customer status from event")
        void shouldChangeCustomerStatusFromEvent() {
            // First create a customer
            String customerId = UUID.randomUUID().toString();
            CustomerCreatedEvent createEvent = new CustomerCreatedEvent(
                    customerId,
                    "test@example.com",
                    "John Doe",
                    "123 Main St"
            );
            viewUpdater.update(createEvent.toGenericRecord());

            // Now change status
            CustomerStatusChangedEvent statusEvent = new CustomerStatusChangedEvent(
                    customerId,
                    "SUSPENDED",
                    "Payment overdue"
            );
            GenericRecord result = viewUpdater.update(statusEvent.toGenericRecord());

            assertNotNull(result);
            assertEquals("SUSPENDED", result.getString("status"));
            assertEquals("John Doe", result.getString("name"));
        }

        @Test
        @DisplayName("should change to CLOSED status")
        void shouldChangeToClosedStatus() {
            // First create a customer
            String customerId = UUID.randomUUID().toString();
            CustomerCreatedEvent createEvent = new CustomerCreatedEvent(
                    customerId,
                    "test@example.com",
                    "John Doe",
                    "123 Main St"
            );
            viewUpdater.update(createEvent.toGenericRecord());

            // Now close account
            CustomerStatusChangedEvent statusEvent = new CustomerStatusChangedEvent(
                    customerId,
                    "CLOSED",
                    "Account terminated"
            );
            GenericRecord result = viewUpdater.update(statusEvent.toGenericRecord());

            assertNotNull(result);
            assertEquals("CLOSED", result.getString("status"));
        }
    }

    @Nested
    @DisplayName("Get customer from view")
    class GetCustomerTests {

        @Test
        @DisplayName("should return customer from view")
        void shouldReturnCustomerFromView() {
            String customerId = UUID.randomUUID().toString();
            CustomerCreatedEvent createEvent = new CustomerCreatedEvent(
                    customerId,
                    "get-test@example.com",
                    "Jane Doe",
                    "789 Pine St"
            );
            viewUpdater.update(createEvent.toGenericRecord());

            Optional<GenericRecord> result = viewStore.get(customerId);

            assertTrue(result.isPresent());
            assertEquals("get-test@example.com", result.get().getString("email"));
            assertEquals("Jane Doe", result.get().getString("name"));
        }

        @Test
        @DisplayName("should return empty for non-existent customer")
        void shouldReturnEmptyForNonExistentCustomer() {
            Optional<GenericRecord> result = viewStore.get("nonexistent");
            assertFalse(result.isPresent());
        }
    }

    @Nested
    @DisplayName("Customer exists check")
    class CustomerExistsTests {

        @Test
        @DisplayName("should return true when customer exists")
        void shouldReturnTrueWhenCustomerExists() {
            String customerId = UUID.randomUUID().toString();
            CustomerCreatedEvent createEvent = new CustomerCreatedEvent(
                    customerId,
                    "exists@example.com",
                    "Exists User",
                    "123 Exists St"
            );
            viewUpdater.update(createEvent.toGenericRecord());

            assertTrue(viewStore.containsKey(customerId));
        }

        @Test
        @DisplayName("should return false when customer does not exist")
        void shouldReturnFalseWhenCustomerDoesNotExist() {
            assertFalse(viewStore.containsKey("nonexistent"));
        }
    }
}
