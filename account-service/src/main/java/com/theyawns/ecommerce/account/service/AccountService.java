package com.theyawns.ecommerce.account.service;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.ecommerce.account.exception.CustomerNotFoundException;
import com.theyawns.ecommerce.common.domain.Customer;
import com.theyawns.ecommerce.common.dto.CustomerDTO;
import com.theyawns.ecommerce.common.events.CustomerCreatedEvent;
import com.theyawns.ecommerce.common.events.CustomerStatusChangedEvent;
import com.theyawns.ecommerce.common.events.CustomerUpdatedEvent;
import com.theyawns.ecommerce.common.util.GenericRecordConverter;
import com.theyawns.framework.controller.CompletionInfo;
import com.theyawns.framework.controller.EventSourcingController;
import com.theyawns.framework.event.DomainEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Business logic service for customer account management.
 *
 * <p>All operations use the event sourcing controller to:
 * <ul>
 *   <li>Publish domain events</li>
 *   <li>Update the materialized view</li>
 *   <li>Return async completion futures</li>
 * </ul>
 *
 * <p>Read operations use the materialized view for fast lookups.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Service
public class AccountService implements CustomerService {

    private static final Logger logger = LoggerFactory.getLogger(AccountService.class);

    private final EventSourcingController<Customer, String, DomainEvent<Customer, String>> controller;

    /**
     * Creates a new AccountService.
     *
     * @param controller the event sourcing controller for customer events
     */
    public AccountService(EventSourcingController<Customer, String, DomainEvent<Customer, String>> controller) {
        this.controller = controller;
    }

    /**
     * Creates a new customer account.
     *
     * @param dto the customer data
     * @return a future that completes with the created customer
     */
    public CompletableFuture<Customer> createCustomer(CustomerDTO dto) {
        String customerId = UUID.randomUUID().toString();
        logger.info("Creating customer with ID: {}", customerId);

        CustomerCreatedEvent event = new CustomerCreatedEvent(
                customerId,
                dto.getEmail(),
                dto.getName(),
                dto.getAddress()
        );
        event.setPhone(dto.getPhone());

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Customer created event processed: {}", completionInfo.getEventId());
                    return getCustomerOrThrow(customerId);
                });
    }

    /**
     * Updates an existing customer's information.
     *
     * @param customerId the customer ID
     * @param dto the updated customer data
     * @return a future that completes with the updated customer
     * @throws CustomerNotFoundException if customer does not exist
     */
    public CompletableFuture<Customer> updateCustomer(String customerId, CustomerDTO dto) {
        logger.info("Updating customer: {}", customerId);

        if (!customerExists(customerId)) {
            throw new CustomerNotFoundException(customerId);
        }

        CustomerUpdatedEvent event = new CustomerUpdatedEvent(
                customerId,
                dto.getName(),
                dto.getAddress(),
                dto.getPhone()
        );

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Customer updated event processed: {}", completionInfo.getEventId());
                    return getCustomerOrThrow(customerId);
                });
    }

    /**
     * Changes a customer's account status.
     *
     * @param customerId the customer ID
     * @param newStatus the new status (ACTIVE, SUSPENDED, CLOSED)
     * @param reason the reason for the status change
     * @return a future that completes with the updated customer
     * @throws CustomerNotFoundException if customer does not exist
     * @throws IllegalArgumentException if status is invalid
     */
    public CompletableFuture<Customer> changeStatus(String customerId, String newStatus, String reason) {
        logger.info("Changing status for customer {} to {}", customerId, newStatus);

        if (!customerExists(customerId)) {
            throw new CustomerNotFoundException(customerId);
        }

        validateStatus(newStatus);

        CustomerStatusChangedEvent event = new CustomerStatusChangedEvent(
                customerId,
                newStatus,
                reason
        );

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Customer status changed event processed: {}", completionInfo.getEventId());
                    return getCustomerOrThrow(customerId);
                });
    }

    /**
     * Retrieves a customer by ID from the materialized view.
     *
     * @param customerId the customer ID
     * @return the customer, or empty if not found
     */
    public Optional<Customer> getCustomer(String customerId) {
        logger.debug("Getting customer: {}", customerId);
        return controller.getViewState(customerId)
                .map(Customer::fromGenericRecord);
    }

    /**
     * Checks if a customer exists in the materialized view.
     *
     * @param customerId the customer ID
     * @return true if the customer exists
     */
    public boolean customerExists(String customerId) {
        return controller.getViewStore().containsKey(customerId);
    }

    /**
     * Gets a customer or throws an exception if not found.
     *
     * @param customerId the customer ID
     * @return the customer
     * @throws CustomerNotFoundException if customer does not exist
     */
    private Customer getCustomerOrThrow(String customerId) {
        return getCustomer(customerId)
                .orElseThrow(() -> new CustomerNotFoundException(customerId));
    }

    /**
     * Validates that the status string is a valid Customer.Status value.
     *
     * @param status the status string to validate
     * @throws IllegalArgumentException if status is invalid
     */
    private void validateStatus(String status) {
        try {
            Customer.Status.valueOf(status);
        } catch (IllegalArgumentException e) {
            throw new IllegalArgumentException(
                    "Invalid status: " + status + ". Valid values are: ACTIVE, SUSPENDED, CLOSED");
        }
    }

    /**
     * Lists all customers from the materialized view, up to the specified limit.
     *
     * @param limit the maximum number of customers to return
     * @return list of customers
     */
    @Override
    public List<Customer> listAll(int limit) {
        logger.debug("Listing customers (limit: {})", limit);
        return controller.getViewStore().values().stream()
                .limit(limit)
                .map(Customer::fromGenericRecord)
                .collect(Collectors.toList());
    }

    /**
     * Retrieves the event history for a customer.
     *
     * @param customerId the customer ID
     * @param limit the maximum number of events to return
     * @return list of events as maps
     */
    @Override
    public List<Map<String, Object>> getEventHistory(String customerId, int limit) {
        logger.debug("Getting event history for customer: {} (limit: {})", customerId, limit);
        List<GenericRecord> events = controller.getEventStore().getEventsByKey(customerId);
        return events.stream()
                .limit(limit)
                .map(GenericRecordConverter::toMap)
                .collect(Collectors.toList());
    }

    /**
     * Rebuilds the customer view from the event store.
     * Use with caution - this can be expensive for large event stores.
     *
     * @return the number of events replayed
     */
    public long rebuildView() {
        logger.info("Rebuilding customer view");
        return controller.rebuildView();
    }

    /**
     * Returns the event sourcing controller for advanced operations.
     *
     * @return the controller
     */
    public EventSourcingController<Customer, String, DomainEvent<Customer, String>> getController() {
        return controller;
    }
}
