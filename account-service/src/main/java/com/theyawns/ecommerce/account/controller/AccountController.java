package com.theyawns.ecommerce.account.controller;

import com.theyawns.ecommerce.account.service.CustomerService;
import com.theyawns.ecommerce.common.domain.Customer;
import com.theyawns.ecommerce.common.dto.CustomerDTO;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.PutMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * REST controller for customer account management.
 *
 * <p>Endpoints:
 * <ul>
 *   <li>POST /api/customers - Create a new customer</li>
 *   <li>GET /api/customers/{id} - Get customer by ID</li>
 *   <li>PUT /api/customers/{id} - Update customer information</li>
 *   <li>PATCH /api/customers/{id}/status - Change customer status</li>
 *   <li>GET /api/customers - List all customers</li>
 *   <li>GET /api/customers/{id}/events - Get customer event history</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@RestController
@RequestMapping("/api/customers")
@Tag(name = "Customer Management", description = "APIs for managing customer accounts")
public class AccountController {

    private static final Logger logger = LoggerFactory.getLogger(AccountController.class);

    private final CustomerService customerService;

    /**
     * Creates a new AccountController.
     *
     * @param customerService the customer service
     */
    public AccountController(CustomerService customerService) {
        this.customerService = customerService;
    }

    /**
     * Creates a new customer account.
     *
     * @param dto the customer data
     * @return the created customer
     */
    @PostMapping
    @Operation(summary = "Create a new customer", description = "Registers a new customer account in the system")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Customer created successfully",
                    content = @Content(schema = @Schema(implementation = CustomerDTO.class))),
            @ApiResponse(responseCode = "400", description = "Invalid customer data")
    })
    public CompletableFuture<ResponseEntity<CustomerDTO>> createCustomer(
            @Valid @RequestBody @io.swagger.v3.oas.annotations.parameters.RequestBody(
                    description = "Customer data", required = true) CustomerDTO dto) {
        logger.info("REST: Creating customer with email: {}", dto.getEmail());

        return customerService.createCustomer(dto)
                .thenApply(customer -> {
                    CustomerDTO response = customer.toDTO();
                    logger.info("REST: Customer created with ID: {}", response.getCustomerId());
                    return ResponseEntity.status(HttpStatus.CREATED).body(response);
                });
    }

    /**
     * Retrieves a customer by ID.
     *
     * @param customerId the customer ID
     * @return the customer, or 404 if not found
     */
    @GetMapping("/{customerId}")
    @Operation(summary = "Get customer by ID", description = "Retrieves customer details from the materialized view")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Customer found",
                    content = @Content(schema = @Schema(implementation = CustomerDTO.class))),
            @ApiResponse(responseCode = "404", description = "Customer not found")
    })
    public ResponseEntity<CustomerDTO> getCustomer(
            @Parameter(description = "Customer ID", required = true) @PathVariable String customerId) {
        logger.debug("REST: Getting customer: {}", customerId);

        return customerService.getCustomer(customerId)
                .map(customer -> {
                    CustomerDTO dto = customer.toDTO();
                    return ResponseEntity.ok(dto);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * Updates an existing customer's information.
     *
     * @param customerId the customer ID
     * @param dto the updated customer data
     * @return the updated customer
     */
    @PutMapping("/{customerId}")
    @Operation(summary = "Update customer", description = "Updates customer profile information")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Customer updated successfully",
                    content = @Content(schema = @Schema(implementation = CustomerDTO.class))),
            @ApiResponse(responseCode = "400", description = "Invalid customer data"),
            @ApiResponse(responseCode = "404", description = "Customer not found")
    })
    public CompletableFuture<ResponseEntity<CustomerDTO>> updateCustomer(
            @Parameter(description = "Customer ID", required = true) @PathVariable String customerId,
            @Valid @RequestBody CustomerDTO dto) {
        logger.info("REST: Updating customer: {}", customerId);

        return customerService.updateCustomer(customerId, dto)
                .thenApply(customer -> {
                    CustomerDTO response = customer.toDTO();
                    logger.info("REST: Customer updated: {}", customerId);
                    return ResponseEntity.ok(response);
                });
    }

    /**
     * Changes a customer's account status.
     *
     * @param customerId the customer ID
     * @param request the status change request
     * @return the updated customer
     */
    @PatchMapping("/{customerId}/status")
    @Operation(summary = "Change customer status", description = "Changes account status (ACTIVE, SUSPENDED, CLOSED)")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Status changed successfully",
                    content = @Content(schema = @Schema(implementation = CustomerDTO.class))),
            @ApiResponse(responseCode = "400", description = "Invalid status"),
            @ApiResponse(responseCode = "404", description = "Customer not found")
    })
    public CompletableFuture<ResponseEntity<CustomerDTO>> changeStatus(
            @Parameter(description = "Customer ID", required = true) @PathVariable String customerId,
            @RequestBody StatusChangeRequest request) {
        logger.info("REST: Changing status for customer {} to {}", customerId, request.status());

        return customerService.changeStatus(customerId, request.status(), request.reason())
                .thenApply(customer -> {
                    CustomerDTO response = customer.toDTO();
                    logger.info("REST: Customer status changed: {} -> {}", customerId, request.status());
                    return ResponseEntity.ok(response);
                });
    }

    /**
     * Lists all customers, up to the specified limit.
     *
     * @param limit the maximum number of customers to return (default: 10)
     * @return list of customers
     */
    @GetMapping
    @Operation(summary = "List customers", description = "Lists all customers from the materialized view")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Customers retrieved")
    })
    public ResponseEntity<List<CustomerDTO>> listCustomers(
            @Parameter(description = "Maximum number of results") @RequestParam(defaultValue = "10") int limit) {
        logger.debug("REST: Listing customers (limit: {})", limit);

        List<CustomerDTO> customers = customerService.listAll(limit).stream()
                .map(customer -> customer.toDTO())
                .collect(Collectors.toList());

        return ResponseEntity.ok(customers);
    }

    /**
     * Retrieves event history for a customer.
     *
     * @param customerId the customer ID
     * @param limit the maximum number of events to return (default: 20)
     * @return list of events
     */
    @GetMapping("/{customerId}/events")
    @Operation(summary = "Get customer event history",
            description = "Retrieves the event history for a customer from the event store")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Event history retrieved")
    })
    public ResponseEntity<List<Map<String, Object>>> getEventHistory(
            @Parameter(description = "Customer ID", required = true) @PathVariable String customerId,
            @Parameter(description = "Maximum number of events") @RequestParam(defaultValue = "20") int limit) {
        logger.debug("REST: Getting event history for customer: {} (limit: {})", customerId, limit);

        List<Map<String, Object>> events = customerService.getEventHistory(customerId, limit);
        return ResponseEntity.ok(events);
    }

    /**
     * Request body for status change operations.
     *
     * @param status the new status (ACTIVE, SUSPENDED, CLOSED)
     * @param reason the reason for the change
     */
    public record StatusChangeRequest(String status, String reason) {
    }
}
