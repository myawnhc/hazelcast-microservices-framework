package com.theyawns.ecommerce.order.domain;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.ecommerce.common.events.OrderCancelledEvent;
import com.theyawns.ecommerce.common.events.OrderConfirmedEvent;
import com.theyawns.ecommerce.common.events.OrderCreatedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import com.theyawns.framework.view.ViewUpdater;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.time.Instant;

/**
 * ViewUpdater that maintains an aggregated summary of orders per customer.
 * Provides efficient customer order statistics without querying individual orders.
 *
 * <p>This view tracks:
 * <ul>
 *   <li>Total number of orders</li>
 *   <li>Total amount spent across all orders</li>
 *   <li>Count of orders by status (pending, confirmed, cancelled)</li>
 *   <li>Last order date</li>
 * </ul>
 *
 * <p>Note: This view is keyed by customerId, not orderId.
 *
 * <p>Supported events:
 * <ul>
 *   <li>{@link OrderCreatedEvent} - Increments order count, adds to total spent</li>
 *   <li>{@link OrderConfirmedEvent} - Updates status counts</li>
 *   <li>{@link OrderCancelledEvent} - Updates status counts</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
public class CustomerOrderSummaryViewUpdater extends ViewUpdater<String> {

    private static final Logger logger = LoggerFactory.getLogger(CustomerOrderSummaryViewUpdater.class);

    /**
     * Schema name for the customer order summary view.
     */
    public static final String VIEW_SCHEMA = "CustomerOrderSummary";

    /**
     * Creates a new CustomerOrderSummaryViewUpdater.
     *
     * @param viewStore the view store to update
     */
    public CustomerOrderSummaryViewUpdater(HazelcastViewStore<String> viewStore) {
        super(viewStore);
    }

    /**
     * Extracts the customer ID from the event record.
     * Note: This view is keyed by customerId, not orderId.
     *
     * @param eventRecord the event record
     * @return the customer ID
     */
    @Override
    protected String extractKey(GenericRecord eventRecord) {
        // For order events, extract customerId as the key
        String customerId = getStringField(eventRecord, "customerId");
        if (customerId != null) {
            return customerId;
        }
        // For confirmed/cancelled events, we need to look up the order
        // to get the customer ID - this is handled by storing customerId in the view
        return null;
    }

    @Override
    protected GenericRecord applyEvent(GenericRecord eventRecord, GenericRecord currentState) {
        String eventType = getEventType(eventRecord);

        logger.debug("Applying event type: {} to customer order summary", eventType);

        return switch (eventType) {
            case OrderCreatedEvent.EVENT_TYPE -> applyOrderCreated(eventRecord, currentState);
            case OrderConfirmedEvent.EVENT_TYPE -> applyOrderConfirmed(eventRecord, currentState);
            case OrderCancelledEvent.EVENT_TYPE -> applyOrderCancelled(eventRecord, currentState);
            default -> {
                logger.debug("Ignoring event type: {} (not relevant to customer order summary)", eventType);
                yield currentState;
            }
        };
    }

    /**
     * Applies an OrderCreatedEvent to update customer order summary.
     * Creates a new summary if this is the customer's first order.
     *
     * @param eventRecord the event record
     * @param currentState the current summary state (may be null)
     * @return the updated customer order summary
     */
    private GenericRecord applyOrderCreated(GenericRecord eventRecord, GenericRecord currentState) {
        Instant now = Instant.now();
        String customerId = getStringField(eventRecord, "customerId");
        String orderTotal = getStringField(eventRecord, "total");
        BigDecimal total = orderTotal != null ? new BigDecimal(orderTotal) : BigDecimal.ZERO;

        if (currentState == null) {
            // First order for this customer
            return GenericRecordBuilder.compact(VIEW_SCHEMA)
                    .setString("customerId", customerId)
                    .setInt32("totalOrders", 1)
                    .setString("totalSpent", total.toString())
                    .setInt32("pendingOrders", 1)
                    .setInt32("confirmedOrders", 0)
                    .setInt32("cancelledOrders", 0)
                    .setInt64("firstOrderAt", now.toEpochMilli())
                    .setInt64("lastOrderAt", now.toEpochMilli())
                    .setInt64("updatedAt", now.toEpochMilli())
                    .build();
        }

        // Update existing summary
        int totalOrders = currentState.getInt32("totalOrders") + 1;
        int pendingOrders = currentState.getInt32("pendingOrders") + 1;
        String currentTotalSpent = currentState.getString("totalSpent");
        BigDecimal totalSpent = currentTotalSpent != null
                ? new BigDecimal(currentTotalSpent).add(total)
                : total;

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("customerId", customerId)
                .setInt32("totalOrders", totalOrders)
                .setString("totalSpent", totalSpent.toString())
                .setInt32("pendingOrders", pendingOrders)
                .setInt32("confirmedOrders", currentState.getInt32("confirmedOrders"))
                .setInt32("cancelledOrders", currentState.getInt32("cancelledOrders"))
                .setInt64("firstOrderAt", currentState.getInt64("firstOrderAt"))
                .setInt64("lastOrderAt", now.toEpochMilli())
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies an OrderConfirmedEvent to update status counts.
     * Moves one order from pending to confirmed.
     *
     * @param eventRecord the event record
     * @param currentState the current summary state
     * @return the updated customer order summary
     */
    private GenericRecord applyOrderConfirmed(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.warn("Cannot confirm order for non-existent customer summary");
            return null;
        }

        Instant now = Instant.now();
        int pendingOrders = Math.max(0, currentState.getInt32("pendingOrders") - 1);
        int confirmedOrders = currentState.getInt32("confirmedOrders") + 1;

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("customerId", currentState.getString("customerId"))
                .setInt32("totalOrders", currentState.getInt32("totalOrders"))
                .setString("totalSpent", currentState.getString("totalSpent"))
                .setInt32("pendingOrders", pendingOrders)
                .setInt32("confirmedOrders", confirmedOrders)
                .setInt32("cancelledOrders", currentState.getInt32("cancelledOrders"))
                .setInt64("firstOrderAt", currentState.getInt64("firstOrderAt"))
                .setInt64("lastOrderAt", currentState.getInt64("lastOrderAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies an OrderCancelledEvent to update status counts.
     * Moves one order from pending/confirmed to cancelled.
     *
     * @param eventRecord the event record
     * @param currentState the current summary state
     * @return the updated customer order summary
     */
    private GenericRecord applyOrderCancelled(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.warn("Cannot cancel order for non-existent customer summary");
            return null;
        }

        Instant now = Instant.now();

        // Determine which count to decrement (pending or confirmed)
        // For simplicity, we assume cancellation comes from pending state
        // In a real system, we'd track the previous state
        int pendingOrders = currentState.getInt32("pendingOrders");
        int confirmedOrders = currentState.getInt32("confirmedOrders");
        int cancelledOrders = currentState.getInt32("cancelledOrders") + 1;

        // Decrement pending first, then confirmed if no pending
        if (pendingOrders > 0) {
            pendingOrders--;
        } else if (confirmedOrders > 0) {
            confirmedOrders--;
        }

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("customerId", currentState.getString("customerId"))
                .setInt32("totalOrders", currentState.getInt32("totalOrders"))
                .setString("totalSpent", currentState.getString("totalSpent"))
                .setInt32("pendingOrders", pendingOrders)
                .setInt32("confirmedOrders", confirmedOrders)
                .setInt32("cancelledOrders", cancelledOrders)
                .setInt64("firstOrderAt", currentState.getInt64("firstOrderAt"))
                .setInt64("lastOrderAt", currentState.getInt64("lastOrderAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }
}
