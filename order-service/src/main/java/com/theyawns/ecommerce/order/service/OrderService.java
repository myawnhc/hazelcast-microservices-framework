package com.theyawns.ecommerce.order.service;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.theyawns.ecommerce.common.domain.Order;
import com.theyawns.ecommerce.common.domain.OrderLineItem;
import com.theyawns.ecommerce.common.dto.OrderDTO;
import com.theyawns.ecommerce.common.dto.OrderLineItemDTO;
import com.theyawns.ecommerce.common.events.OrderCancelledEvent;
import com.theyawns.ecommerce.common.events.OrderConfirmedEvent;
import com.theyawns.ecommerce.common.events.OrderCreatedEvent;
import com.theyawns.ecommerce.order.exception.InvalidOrderStateException;
import com.theyawns.ecommerce.order.exception.OrderNotFoundException;
import com.theyawns.framework.controller.EventSourcingController;
import com.theyawns.framework.event.DomainEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.List;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Business logic service for order management.
 *
 * <p>All operations use the event sourcing controller to:
 * <ul>
 *   <li>Publish domain events</li>
 *   <li>Update the materialized view</li>
 *   <li>Return async completion futures</li>
 * </ul>
 *
 * <p>Read operations use the materialized view for fast lookups.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Service
public class OrderService implements OrderOperations {

    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);

    private final EventSourcingController<Order, String, DomainEvent<Order, String>> controller;
    private final HazelcastInstance hazelcast;

    /**
     * Creates a new OrderService.
     *
     * @param controller the event sourcing controller for order events
     * @param hazelcast the Hazelcast instance
     */
    public OrderService(
            EventSourcingController<Order, String, DomainEvent<Order, String>> controller,
            HazelcastInstance hazelcast) {
        this.controller = controller;
        this.hazelcast = hazelcast;
    }

    /**
     * Creates a new order.
     *
     * @param dto the order data
     * @return a future that completes with the created order
     */
    @Override
    public CompletableFuture<Order> createOrder(OrderDTO dto) {
        String orderId = UUID.randomUUID().toString();
        logger.info("Creating order with ID: {} for customer: {}", orderId, dto.getCustomerId());

        // Convert DTOs to domain objects
        List<OrderLineItem> lineItems = dto.getLineItems().stream()
                .map(this::toOrderLineItem)
                .collect(Collectors.toList());

        OrderCreatedEvent event = new OrderCreatedEvent(
                orderId,
                dto.getCustomerId(),
                lineItems,
                dto.getShippingAddress()
        );
        event.setCustomerName(dto.getCustomerName());
        event.setCustomerEmail(dto.getCustomerEmail());

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Order created event processed: {}", completionInfo.getEventId());

                    // Index order by customer for getOrdersByCustomer
                    indexOrderByCustomer(dto.getCustomerId(), orderId);

                    return getOrderOrThrow(orderId);
                });
    }

    /**
     * Retrieves an order by ID from the materialized view.
     *
     * @param orderId the order ID
     * @return the order, or empty if not found
     */
    @Override
    public Optional<Order> getOrder(String orderId) {
        logger.debug("Getting order: {}", orderId);
        return controller.getViewState(orderId)
                .map(Order::fromGenericRecord);
    }

    /**
     * Retrieves all orders for a customer.
     *
     * @param customerId the customer ID
     * @return list of orders for the customer
     */
    @Override
    public List<Order> getOrdersByCustomer(String customerId) {
        logger.debug("Getting orders for customer: {}", customerId);

        IMap<String, Set<String>> customerOrdersIndex = hazelcast.getMap("CustomerOrders");
        Set<String> orderIds = customerOrdersIndex.get(customerId);

        if (orderIds == null || orderIds.isEmpty()) {
            return new ArrayList<>();
        }

        return orderIds.stream()
                .map(this::getOrder)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());
    }

    /**
     * Confirms an order (stock reserved, payment verified).
     *
     * @param orderId the order ID
     * @return a future that completes with the confirmed order
     * @throws OrderNotFoundException if order does not exist
     * @throws InvalidOrderStateException if order cannot be confirmed
     */
    @Override
    public CompletableFuture<Order> confirmOrder(String orderId) {
        logger.info("Confirming order: {}", orderId);

        Order order = getOrderOrThrow(orderId);

        // Validate state transition
        if (order.getStatus() != Order.Status.PENDING) {
            throw new InvalidOrderStateException(orderId, order.getStatus().name(), "confirm");
        }

        String confirmationNumber = generateConfirmationNumber();
        OrderConfirmedEvent event = new OrderConfirmedEvent(orderId, confirmationNumber);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Order confirmed event processed: {}", completionInfo.getEventId());
                    return getOrderOrThrow(orderId);
                });
    }

    /**
     * Cancels an order.
     *
     * @param orderId the order ID
     * @param reason the cancellation reason
     * @param cancelledBy who cancelled (customer, system, admin)
     * @return a future that completes with the cancelled order
     * @throws OrderNotFoundException if order does not exist
     * @throws InvalidOrderStateException if order cannot be cancelled
     */
    @Override
    public CompletableFuture<Order> cancelOrder(String orderId, String reason, String cancelledBy) {
        logger.info("Cancelling order: {} (reason: {}, by: {})", orderId, reason, cancelledBy);

        Order order = getOrderOrThrow(orderId);

        // Validate state transition - can only cancel PENDING or CONFIRMED orders
        if (order.getStatus() != Order.Status.PENDING && order.getStatus() != Order.Status.CONFIRMED) {
            throw new InvalidOrderStateException(orderId, order.getStatus().name(), "cancel");
        }

        OrderCancelledEvent event = new OrderCancelledEvent(orderId, reason, cancelledBy);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Order cancelled event processed: {}", completionInfo.getEventId());
                    return getOrderOrThrow(orderId);
                });
    }

    /**
     * Checks if an order exists in the materialized view.
     *
     * @param orderId the order ID
     * @return true if the order exists
     */
    @Override
    public boolean orderExists(String orderId) {
        return controller.getViewStore().containsKey(orderId);
    }

    /**
     * Gets an order or throws an exception if not found.
     *
     * @param orderId the order ID
     * @return the order
     * @throws OrderNotFoundException if order does not exist
     */
    private Order getOrderOrThrow(String orderId) {
        return getOrder(orderId)
                .orElseThrow(() -> new OrderNotFoundException(orderId));
    }

    /**
     * Converts an OrderLineItemDTO to an OrderLineItem domain object.
     *
     * @param dto the DTO
     * @return the domain object
     */
    private OrderLineItem toOrderLineItem(OrderLineItemDTO dto) {
        return new OrderLineItem(
                dto.getProductId(),
                dto.getProductName(),
                dto.getSku(),
                dto.getQuantity(),
                dto.getUnitPrice()
        );
    }

    /**
     * Indexes an order by customer ID for efficient lookup.
     *
     * @param customerId the customer ID
     * @param orderId the order ID
     */
    private void indexOrderByCustomer(String customerId, String orderId) {
        IMap<String, Set<String>> customerOrdersIndex = hazelcast.getMap("CustomerOrders");
        customerOrdersIndex.executeOnKey(customerId, entry -> {
            Set<String> orderIds = entry.getValue();
            if (orderIds == null) {
                orderIds = new java.util.HashSet<>();
            }
            orderIds.add(orderId);
            entry.setValue(orderIds);
            return null;
        });
    }

    /**
     * Generates a unique confirmation number.
     *
     * @return the confirmation number
     */
    private String generateConfirmationNumber() {
        return "CONF-" + System.currentTimeMillis() + "-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }

    /**
     * Returns the event sourcing controller for advanced operations.
     *
     * @return the controller
     */
    public EventSourcingController<Order, String, DomainEvent<Order, String>> getController() {
        return controller;
    }
}
