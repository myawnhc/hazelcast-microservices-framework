package com.theyawns.ecommerce.order.service;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.ecommerce.common.domain.Order;
import com.theyawns.ecommerce.common.domain.OrderLineItem;
import com.theyawns.ecommerce.common.dto.OrderDTO;
import com.theyawns.ecommerce.common.dto.OrderLineItemDTO;
import com.theyawns.ecommerce.common.events.OrderCancelledEvent;
import com.theyawns.ecommerce.common.events.OrderConfirmedEvent;
import com.theyawns.ecommerce.common.events.OrderCreatedEvent;
import com.theyawns.ecommerce.common.util.GenericRecordConverter;
import com.theyawns.ecommerce.order.exception.InvalidOrderStateException;
import com.theyawns.ecommerce.order.exception.OrderNotFoundException;
import com.theyawns.framework.controller.EventSourcingController;
import com.theyawns.framework.controller.SagaMetadata;
import com.theyawns.framework.event.DomainEvent;
import com.theyawns.framework.saga.SagaCompensationConfig;
import com.theyawns.framework.saga.SagaStateStore;
import com.theyawns.framework.saga.SagaStatus;
import com.theyawns.framework.view.HazelcastViewStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.time.Duration;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Business logic service for order management.
 *
 * <p>All operations use the event sourcing controller to:
 * <ul>
 *   <li>Publish domain events</li>
 *   <li>Update the materialized view</li>
 *   <li>Return async completion futures</li>
 * </ul>
 *
 * <p>Read operations use the materialized view for fast lookups.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@Service
public class OrderService implements OrderOperations {

    private static final Logger logger = LoggerFactory.getLogger(OrderService.class);

    /**
     * Default saga timeout for Order Fulfillment sagas.
     */
    private static final Duration SAGA_TIMEOUT = Duration.ofSeconds(60);

    /**
     * Total number of steps in the Order Fulfillment saga.
     */
    private static final int SAGA_TOTAL_STEPS = 4;

    private final EventSourcingController<Order, String, DomainEvent<Order, String>> controller;
    private final HazelcastInstance hazelcast;
    private final SagaStateStore sagaStateStore;
    private final HazelcastViewStore<String> productAvailabilityViewStore;

    /**
     * Creates a new OrderService.
     *
     * @param controller the event sourcing controller for order events
     * @param hazelcast the Hazelcast instance
     * @param sagaStateStore the saga state store for tracking distributed transactions
     * @param productAvailabilityViewStore the product availability cache for price lookups
     */
    public OrderService(
            EventSourcingController<Order, String, DomainEvent<Order, String>> controller,
            HazelcastInstance hazelcast,
            SagaStateStore sagaStateStore,
            @Qualifier("productAvailabilityViewStore")
            HazelcastViewStore<String> productAvailabilityViewStore) {
        this.controller = controller;
        this.hazelcast = hazelcast;
        this.sagaStateStore = sagaStateStore;
        this.productAvailabilityViewStore = productAvailabilityViewStore;
    }

    /**
     * Creates a new order.
     *
     * @param dto the order data
     * @return a future that completes with the created order
     */
    @Override
    public CompletableFuture<Order> createOrder(OrderDTO dto) {
        String orderId = UUID.randomUUID().toString();
        String sagaId = UUID.randomUUID().toString();
        UUID correlationId = UUID.randomUUID();

        logger.info("Creating order with ID: {} for customer: {} (sagaId: {})",
                orderId, dto.getCustomerId(), sagaId);

        // Start the Order Fulfillment saga
        sagaStateStore.startSaga(
                sagaId,
                SagaCompensationConfig.ORDER_FULFILLMENT_SAGA,
                correlationId.toString(),
                SAGA_TOTAL_STEPS,
                SAGA_TIMEOUT
        );

        // Build saga metadata for step 0
        SagaMetadata sagaMetadata = SagaMetadata.builder()
                .sagaId(sagaId)
                .sagaType(SagaCompensationConfig.ORDER_FULFILLMENT_SAGA)
                .stepNumber(SagaCompensationConfig.STEP_ORDER_CREATED)
                .build();

        // Convert DTOs to domain objects
        List<OrderLineItem> lineItems = dto.getLineItems().stream()
                .map(this::toOrderLineItem)
                .collect(Collectors.toList());

        OrderCreatedEvent event = new OrderCreatedEvent(
                orderId,
                dto.getCustomerId(),
                lineItems,
                dto.getShippingAddress()
        );
        event.setCustomerName(dto.getCustomerName());
        event.setCustomerEmail(dto.getCustomerEmail());

        return controller.handleEvent(event, correlationId, sagaMetadata)
                .thenApply(completionInfo -> {
                    logger.debug("Order created event processed: {} (sagaId: {})",
                            completionInfo.getEventId(), sagaId);

                    // Record step 0 completed in saga state store
                    sagaStateStore.recordStepCompleted(
                            sagaId,
                            SagaCompensationConfig.STEP_ORDER_CREATED,
                            SagaCompensationConfig.ORDER_CREATED,
                            SagaCompensationConfig.ORDER_SERVICE,
                            completionInfo.getEventId()
                    );

                    // Index order by customer for getOrdersByCustomer
                    indexOrderByCustomer(dto.getCustomerId(), orderId);

                    return getOrderOrThrow(orderId);
                });
    }

    /**
     * Retrieves an order by ID from the materialized view.
     *
     * @param orderId the order ID
     * @return the order, or empty if not found
     */
    @Override
    public Optional<Order> getOrder(String orderId) {
        logger.debug("Getting order: {}", orderId);
        return controller.getViewState(orderId)
                .map(Order::fromGenericRecord);
    }

    /**
     * Retrieves all orders for a customer.
     *
     * @param customerId the customer ID
     * @return list of orders for the customer
     */
    @Override
    public List<Order> getOrdersByCustomer(String customerId) {
        logger.debug("Getting orders for customer: {}", customerId);

        IMap<String, Set<String>> customerOrdersIndex = hazelcast.getMap("CustomerOrders");
        Set<String> orderIds = customerOrdersIndex.get(customerId);

        if (orderIds == null || orderIds.isEmpty()) {
            return new ArrayList<>();
        }

        return orderIds.stream()
                .map(this::getOrder)
                .filter(Optional::isPresent)
                .map(Optional::get)
                .collect(Collectors.toList());
    }

    /**
     * Confirms an order (stock reserved, payment verified).
     *
     * @param orderId the order ID
     * @return a future that completes with the confirmed order
     * @throws OrderNotFoundException if order does not exist
     * @throws InvalidOrderStateException if order cannot be confirmed
     */
    @Override
    public CompletableFuture<Order> confirmOrder(String orderId) {
        logger.info("Confirming order: {}", orderId);

        Order order = getOrderOrThrow(orderId);

        // Validate state transition
        if (order.getStatus() != Order.Status.PENDING) {
            throw new InvalidOrderStateException(orderId, order.getStatus().name(), "confirm");
        }

        String confirmationNumber = generateConfirmationNumber();
        OrderConfirmedEvent event = new OrderConfirmedEvent(orderId, confirmationNumber);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Order confirmed event processed: {}", completionInfo.getEventId());
                    return getOrderOrThrow(orderId);
                });
    }

    /**
     * Confirms an order as part of a saga.
     *
     * <p>This method is called by the saga listener when a PaymentProcessed event
     * is received. It confirms the order and records the final saga step, then
     * marks the saga as COMPLETED.
     *
     * @param orderId the order ID
     * @param sagaId the saga instance ID
     * @param correlationId the correlation ID
     * @return a future that completes with the confirmed order
     * @throws OrderNotFoundException if order does not exist
     * @throws InvalidOrderStateException if order cannot be confirmed
     */
    public CompletableFuture<Order> confirmOrderForSaga(
            final String orderId, final String sagaId, final String correlationId) {
        logger.info("Confirming order for saga: orderId={}, sagaId={}", orderId, sagaId);

        Order order = getOrderOrThrow(orderId);

        if (order.getStatus() != Order.Status.PENDING) {
            throw new InvalidOrderStateException(orderId, order.getStatus().name(), "confirm");
        }

        String confirmationNumber = generateConfirmationNumber();
        OrderConfirmedEvent event = new OrderConfirmedEvent(orderId, confirmationNumber);

        SagaMetadata sagaMetadata = SagaMetadata.builder()
                .sagaId(sagaId)
                .sagaType(SagaCompensationConfig.ORDER_FULFILLMENT_SAGA)
                .stepNumber(SagaCompensationConfig.STEP_ORDER_CONFIRMED)
                .build();

        return controller.handleEvent(event, UUID.fromString(correlationId), sagaMetadata)
                .thenApply(completionInfo -> {
                    logger.debug("Order confirmed event processed for saga: {} (sagaId: {})",
                            completionInfo.getEventId(), sagaId);

                    // Record step 3 completed - this is the final step,
                    // so SagaState automatically transitions to COMPLETED
                    sagaStateStore.recordStepCompleted(
                            sagaId,
                            SagaCompensationConfig.STEP_ORDER_CONFIRMED,
                            SagaCompensationConfig.ORDER_CONFIRMED,
                            SagaCompensationConfig.ORDER_SERVICE,
                            completionInfo.getEventId()
                    );

                    logger.info("Order Fulfillment saga completed: sagaId={}, orderId={}",
                            sagaId, orderId);

                    return getOrderOrThrow(orderId);
                });
    }

    /**
     * Cancels an order as part of saga compensation.
     *
     * <p>This method is called by the saga listener when a PaymentFailed event
     * is received. It cancels the order, records the compensation step for
     * step 0 (OrderCreated), and marks the saga as COMPENSATED.
     *
     * @param orderId the order ID
     * @param reason the cancellation reason
     * @param sagaId the saga instance ID
     * @param correlationId the correlation ID
     * @return a future that completes with the cancelled order
     * @throws OrderNotFoundException if order does not exist
     * @throws InvalidOrderStateException if order cannot be cancelled
     */
    @Override
    public CompletableFuture<Order> cancelOrderForSaga(
            final String orderId, final String reason,
            final String sagaId, final String correlationId) {

        logger.info("Cancelling order for saga compensation: orderId={}, sagaId={}", orderId, sagaId);

        Order order = getOrderOrThrow(orderId);

        if (order.getStatus() != Order.Status.PENDING && order.getStatus() != Order.Status.CONFIRMED) {
            throw new InvalidOrderStateException(orderId, order.getStatus().name(), "cancel");
        }

        OrderCancelledEvent event = new OrderCancelledEvent(orderId, reason, "system");
        event.setIsCompensating(true);

        SagaMetadata sagaMetadata = SagaMetadata.builder()
                .sagaId(sagaId)
                .sagaType(SagaCompensationConfig.ORDER_FULFILLMENT_SAGA)
                .stepNumber(SagaCompensationConfig.STEP_ORDER_CREATED)
                .compensating(true)
                .build();

        return controller.handleEvent(event, UUID.fromString(correlationId), sagaMetadata)
                .thenApply(completionInfo -> {
                    logger.debug("Order cancelled event processed for saga: {} (sagaId: {})",
                            completionInfo.getEventId(), sagaId);

                    // Record compensation step for order creation (step 0)
                    sagaStateStore.recordCompensationStep(
                            sagaId,
                            SagaCompensationConfig.STEP_ORDER_CREATED,
                            SagaCompensationConfig.ORDER_CANCELLED,
                            SagaCompensationConfig.ORDER_SERVICE
                    );

                    // Mark the saga as COMPENSATED (all compensation steps done)
                    sagaStateStore.completeSaga(sagaId, SagaStatus.COMPENSATED);

                    logger.info("Order Fulfillment saga compensated: sagaId={}, orderId={}",
                            sagaId, orderId);

                    return getOrderOrThrow(orderId);
                });
    }

    /**
     * Cancels an order.
     *
     * @param orderId the order ID
     * @param reason the cancellation reason
     * @param cancelledBy who cancelled (customer, system, admin)
     * @return a future that completes with the cancelled order
     * @throws OrderNotFoundException if order does not exist
     * @throws InvalidOrderStateException if order cannot be cancelled
     */
    @Override
    public CompletableFuture<Order> cancelOrder(String orderId, String reason, String cancelledBy) {
        logger.info("Cancelling order: {} (reason: {}, by: {})", orderId, reason, cancelledBy);

        Order order = getOrderOrThrow(orderId);

        // Validate state transition - can only cancel PENDING or CONFIRMED orders
        if (order.getStatus() != Order.Status.PENDING && order.getStatus() != Order.Status.CONFIRMED) {
            throw new InvalidOrderStateException(orderId, order.getStatus().name(), "cancel");
        }

        OrderCancelledEvent event = new OrderCancelledEvent(orderId, reason, cancelledBy);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Order cancelled event processed: {}", completionInfo.getEventId());
                    return getOrderOrThrow(orderId);
                });
    }

    /**
     * Checks if an order exists in the materialized view.
     *
     * @param orderId the order ID
     * @return true if the order exists
     */
    @Override
    public boolean orderExists(String orderId) {
        return controller.getViewStore().containsKey(orderId);
    }

    /**
     * Gets an order or throws an exception if not found.
     *
     * @param orderId the order ID
     * @return the order
     * @throws OrderNotFoundException if order does not exist
     */
    private Order getOrderOrThrow(String orderId) {
        return getOrder(orderId)
                .orElseThrow(() -> new OrderNotFoundException(orderId));
    }

    /**
     * Converts an OrderLineItemDTO to an OrderLineItem domain object.
     * If unitPrice is not provided in the DTO, looks it up from the product availability cache.
     *
     * @param dto the DTO
     * @return the domain object
     * @throws IllegalArgumentException if product price cannot be determined
     */
    private OrderLineItem toOrderLineItem(OrderLineItemDTO dto) {
        BigDecimal unitPrice = dto.getUnitPrice();
        String productName = dto.getProductName();
        String sku = dto.getSku();

        // If price is missing, look it up from the product availability cache
        if (unitPrice == null) {
            Optional<GenericRecord> productOpt = productAvailabilityViewStore.get(dto.getProductId());
            if (productOpt.isPresent()) {
                GenericRecord product = productOpt.get();
                String priceStr = product.getString("price");
                if (priceStr != null && !priceStr.isEmpty()) {
                    unitPrice = new BigDecimal(priceStr);
                    logger.debug("Looked up price {} for product {} from cache", unitPrice, dto.getProductId());
                }
                // Also enrich product name and SKU if missing
                if (productName == null || productName.isEmpty()) {
                    productName = product.getString("name");
                }
                if (sku == null || sku.isEmpty()) {
                    sku = product.getString("sku");
                }
            } else {
                logger.warn("Product {} not found in availability cache, cannot determine price",
                        dto.getProductId());
            }
        }

        return new OrderLineItem(
                dto.getProductId(),
                productName,
                sku,
                dto.getQuantity(),
                unitPrice
        );
    }

    /**
     * Indexes an order by customer ID for efficient lookup.
     *
     * @param customerId the customer ID
     * @param orderId the order ID
     */
    private void indexOrderByCustomer(String customerId, String orderId) {
        IMap<String, Set<String>> customerOrdersIndex = hazelcast.getMap("CustomerOrders");
        customerOrdersIndex.executeOnKey(customerId, entry -> {
            Set<String> orderIds = entry.getValue();
            if (orderIds == null) {
                orderIds = new java.util.HashSet<>();
            }
            orderIds.add(orderId);
            entry.setValue(orderIds);
            return null;
        });
    }

    /**
     * Generates a unique confirmation number.
     *
     * @return the confirmation number
     */
    private String generateConfirmationNumber() {
        return "CONF-" + System.currentTimeMillis() + "-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }

    /**
     * Lists all orders from the materialized view, up to the specified limit.
     *
     * @param limit the maximum number of orders to return
     * @return list of orders
     */
    @Override
    public List<Order> listAll(int limit) {
        logger.debug("Listing orders (limit: {})", limit);
        return controller.getViewStore().values().stream()
                .limit(limit)
                .map(Order::fromGenericRecord)
                .collect(Collectors.toList());
    }

    /**
     * Retrieves the event history for an order.
     *
     * @param orderId the order ID
     * @param limit the maximum number of events to return
     * @return list of events as maps
     */
    @Override
    public List<Map<String, Object>> getEventHistory(String orderId, int limit) {
        logger.debug("Getting event history for order: {} (limit: {})", orderId, limit);
        List<GenericRecord> events = controller.getEventStore().getEventsByKey(orderId);
        return events.stream()
                .limit(limit)
                .map(GenericRecordConverter::toMap)
                .collect(Collectors.toList());
    }

    /**
     * Returns the event sourcing controller for advanced operations.
     *
     * @return the controller
     */
    public EventSourcingController<Order, String, DomainEvent<Order, String>> getController() {
        return controller;
    }
}
