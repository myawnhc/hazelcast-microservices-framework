package com.theyawns.ecommerce.order.controller;

import com.theyawns.ecommerce.common.dto.OrderDTO;
import com.theyawns.ecommerce.order.service.OrderOperations;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.ArraySchema;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * REST controller for order management.
 *
 * <p>Endpoints:
 * <ul>
 *   <li>POST /api/orders - Create a new order</li>
 *   <li>GET /api/orders/{id} - Get order by ID</li>
 *   <li>GET /api/orders/customer/{customerId} - Get all orders for a customer</li>
 *   <li>PATCH /api/orders/{id}/confirm - Confirm an order</li>
 *   <li>PATCH /api/orders/{id}/cancel - Cancel an order</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@RestController
@RequestMapping("/api/orders")
@Tag(name = "Order Management", description = "APIs for managing customer orders")
public class OrderController {

    private static final Logger logger = LoggerFactory.getLogger(OrderController.class);

    private final OrderOperations orderService;

    /**
     * Creates a new OrderController.
     *
     * @param orderService the order service
     */
    public OrderController(OrderOperations orderService) {
        this.orderService = orderService;
    }

    /**
     * Creates a new order.
     *
     * @param dto the order data
     * @return the created order
     */
    @PostMapping
    @Operation(summary = "Create a new order", description = "Places a new order for a customer")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Order created successfully",
                    content = @Content(schema = @Schema(implementation = OrderDTO.class))),
            @ApiResponse(responseCode = "400", description = "Invalid order data")
    })
    public CompletableFuture<ResponseEntity<OrderDTO>> createOrder(@Valid @RequestBody OrderDTO dto) {
        logger.info("REST: Creating order for customer: {}", dto.getCustomerId());

        return orderService.createOrder(dto)
                .thenApply(order -> {
                    OrderDTO response = order.toDTO();
                    logger.info("REST: Order created with ID: {}", response.getOrderId());
                    return ResponseEntity.status(HttpStatus.CREATED).body(response);
                });
    }

    /**
     * Retrieves an order by ID.
     *
     * @param orderId the order ID
     * @return the order, or 404 if not found
     */
    @GetMapping("/{orderId}")
    @Operation(summary = "Get order by ID", description = "Retrieves order details including enriched customer and product data")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Order found",
                    content = @Content(schema = @Schema(implementation = OrderDTO.class))),
            @ApiResponse(responseCode = "404", description = "Order not found")
    })
    public ResponseEntity<OrderDTO> getOrder(
            @Parameter(description = "Order ID", required = true) @PathVariable String orderId) {
        logger.debug("REST: Getting order: {}", orderId);

        return orderService.getOrder(orderId)
                .map(order -> {
                    OrderDTO dto = order.toDTO();
                    return ResponseEntity.ok(dto);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * Retrieves all orders for a customer.
     *
     * @param customerId the customer ID
     * @return list of orders for the customer
     */
    @GetMapping("/customer/{customerId}")
    @Operation(summary = "Get orders by customer", description = "Retrieves all orders for a specific customer")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Orders retrieved",
                    content = @Content(array = @ArraySchema(schema = @Schema(implementation = OrderDTO.class))))
    })
    public ResponseEntity<List<OrderDTO>> getOrdersByCustomer(
            @Parameter(description = "Customer ID", required = true) @PathVariable String customerId) {
        logger.debug("REST: Getting orders for customer: {}", customerId);

        List<OrderDTO> orders = orderService.getOrdersByCustomer(customerId).stream()
                .map(order -> order.toDTO())
                .collect(Collectors.toList());

        return ResponseEntity.ok(orders);
    }

    /**
     * Confirms an order.
     *
     * @param orderId the order ID
     * @return the confirmed order
     */
    @PatchMapping("/{orderId}/confirm")
    @Operation(summary = "Confirm order", description = "Confirms an order for fulfillment")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Order confirmed",
                    content = @Content(schema = @Schema(implementation = OrderDTO.class))),
            @ApiResponse(responseCode = "400", description = "Order cannot be confirmed"),
            @ApiResponse(responseCode = "404", description = "Order not found")
    })
    public CompletableFuture<ResponseEntity<OrderDTO>> confirmOrder(
            @Parameter(description = "Order ID", required = true) @PathVariable String orderId) {
        logger.info("REST: Confirming order: {}", orderId);

        return orderService.confirmOrder(orderId)
                .thenApply(order -> {
                    OrderDTO response = order.toDTO();
                    logger.info("REST: Order confirmed: {}, status: {}", orderId, response.getStatus());
                    return ResponseEntity.ok(response);
                });
    }

    /**
     * Cancels an order.
     *
     * @param orderId the order ID
     * @param request the cancellation request
     * @return the cancelled order
     */
    @PatchMapping("/{orderId}/cancel")
    @Operation(summary = "Cancel order", description = "Cancels an order and releases reserved stock")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Order cancelled",
                    content = @Content(schema = @Schema(implementation = OrderDTO.class))),
            @ApiResponse(responseCode = "400", description = "Order cannot be cancelled"),
            @ApiResponse(responseCode = "404", description = "Order not found")
    })
    public CompletableFuture<ResponseEntity<OrderDTO>> cancelOrder(
            @Parameter(description = "Order ID", required = true) @PathVariable String orderId,
            @Valid @RequestBody CancelOrderRequest request) {
        logger.info("REST: Cancelling order: {} (reason: {})", orderId, request.reason());

        return orderService.cancelOrder(orderId, request.reason(), request.cancelledBy())
                .thenApply(order -> {
                    OrderDTO response = order.toDTO();
                    logger.info("REST: Order cancelled: {}, status: {}", orderId, response.getStatus());
                    return ResponseEntity.ok(response);
                });
    }

    /**
     * Lists all orders, up to the specified limit.
     *
     * @param limit the maximum number of orders to return (default: 10)
     * @return list of orders
     */
    @GetMapping
    @Operation(summary = "List orders", description = "Lists all orders from the materialized view")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Orders retrieved")
    })
    public ResponseEntity<List<OrderDTO>> listOrders(
            @Parameter(description = "Maximum number of results") @RequestParam(defaultValue = "10") int limit) {
        logger.debug("REST: Listing orders (limit: {})", limit);

        List<OrderDTO> orders = orderService.listAll(limit).stream()
                .map(order -> order.toDTO())
                .collect(Collectors.toList());

        return ResponseEntity.ok(orders);
    }

    /**
     * Retrieves event history for an order.
     *
     * @param orderId the order ID
     * @param limit the maximum number of events to return (default: 20)
     * @return list of events
     */
    @GetMapping("/{orderId}/events")
    @Operation(summary = "Get order event history",
            description = "Retrieves the event history for an order from the event store")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Event history retrieved")
    })
    public ResponseEntity<List<Map<String, Object>>> getEventHistory(
            @Parameter(description = "Order ID", required = true) @PathVariable String orderId,
            @Parameter(description = "Maximum number of events") @RequestParam(defaultValue = "20") int limit) {
        logger.debug("REST: Getting event history for order: {} (limit: {})", orderId, limit);

        List<Map<String, Object>> events = orderService.getEventHistory(orderId, limit);
        return ResponseEntity.ok(events);
    }

    /**
     * Request body for order cancellation.
     *
     * @param reason the cancellation reason
     * @param cancelledBy who cancelled (customer, system, admin)
     */
    public record CancelOrderRequest(
            @NotBlank(message = "Reason is required")
            String reason,

            @NotBlank(message = "CancelledBy is required")
            String cancelledBy
    ) {
    }
}
