package com.theyawns.ecommerce.order.controller;

import com.theyawns.ecommerce.common.dto.OrderDTO;
import com.theyawns.ecommerce.order.service.OrderOperations;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PatchMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * REST controller for order management.
 *
 * <p>Endpoints:
 * <ul>
 *   <li>POST /api/orders - Create a new order</li>
 *   <li>GET /api/orders/{id} - Get order by ID</li>
 *   <li>GET /api/orders/customer/{customerId} - Get all orders for a customer</li>
 *   <li>PATCH /api/orders/{id}/confirm - Confirm an order</li>
 *   <li>PATCH /api/orders/{id}/cancel - Cancel an order</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@RestController
@RequestMapping("/api/orders")
public class OrderController {

    private static final Logger logger = LoggerFactory.getLogger(OrderController.class);

    private final OrderOperations orderService;

    /**
     * Creates a new OrderController.
     *
     * @param orderService the order service
     */
    public OrderController(OrderOperations orderService) {
        this.orderService = orderService;
    }

    /**
     * Creates a new order.
     *
     * @param dto the order data
     * @return the created order
     */
    @PostMapping
    public CompletableFuture<ResponseEntity<OrderDTO>> createOrder(@Valid @RequestBody OrderDTO dto) {
        logger.info("REST: Creating order for customer: {}", dto.getCustomerId());

        return orderService.createOrder(dto)
                .thenApply(order -> {
                    OrderDTO response = order.toDTO();
                    logger.info("REST: Order created with ID: {}", response.getOrderId());
                    return ResponseEntity.status(HttpStatus.CREATED).body(response);
                });
    }

    /**
     * Retrieves an order by ID.
     *
     * @param orderId the order ID
     * @return the order, or 404 if not found
     */
    @GetMapping("/{orderId}")
    public ResponseEntity<OrderDTO> getOrder(@PathVariable String orderId) {
        logger.debug("REST: Getting order: {}", orderId);

        return orderService.getOrder(orderId)
                .map(order -> {
                    OrderDTO dto = order.toDTO();
                    return ResponseEntity.ok(dto);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * Retrieves all orders for a customer.
     *
     * @param customerId the customer ID
     * @return list of orders for the customer
     */
    @GetMapping("/customer/{customerId}")
    public ResponseEntity<List<OrderDTO>> getOrdersByCustomer(@PathVariable String customerId) {
        logger.debug("REST: Getting orders for customer: {}", customerId);

        List<OrderDTO> orders = orderService.getOrdersByCustomer(customerId).stream()
                .map(order -> order.toDTO())
                .collect(Collectors.toList());

        return ResponseEntity.ok(orders);
    }

    /**
     * Confirms an order.
     *
     * @param orderId the order ID
     * @return the confirmed order
     */
    @PatchMapping("/{orderId}/confirm")
    public CompletableFuture<ResponseEntity<OrderDTO>> confirmOrder(@PathVariable String orderId) {
        logger.info("REST: Confirming order: {}", orderId);

        return orderService.confirmOrder(orderId)
                .thenApply(order -> {
                    OrderDTO response = order.toDTO();
                    logger.info("REST: Order confirmed: {}, status: {}", orderId, response.getStatus());
                    return ResponseEntity.ok(response);
                });
    }

    /**
     * Cancels an order.
     *
     * @param orderId the order ID
     * @param request the cancellation request
     * @return the cancelled order
     */
    @PatchMapping("/{orderId}/cancel")
    public CompletableFuture<ResponseEntity<OrderDTO>> cancelOrder(
            @PathVariable String orderId,
            @Valid @RequestBody CancelOrderRequest request) {
        logger.info("REST: Cancelling order: {} (reason: {})", orderId, request.reason());

        return orderService.cancelOrder(orderId, request.reason(), request.cancelledBy())
                .thenApply(order -> {
                    OrderDTO response = order.toDTO();
                    logger.info("REST: Order cancelled: {}, status: {}", orderId, response.getStatus());
                    return ResponseEntity.ok(response);
                });
    }

    /**
     * Request body for order cancellation.
     *
     * @param reason the cancellation reason
     * @param cancelledBy who cancelled (customer, system, admin)
     */
    public record CancelOrderRequest(
            @NotBlank(message = "Reason is required")
            String reason,

            @NotBlank(message = "CancelledBy is required")
            String cancelledBy
    ) {
    }
}
