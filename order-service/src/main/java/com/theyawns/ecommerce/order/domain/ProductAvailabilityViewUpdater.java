package com.theyawns.ecommerce.order.domain;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.common.events.ProductCreatedEvent;
import com.theyawns.ecommerce.common.events.StockReleasedEvent;
import com.theyawns.ecommerce.common.events.StockReservedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import com.theyawns.framework.view.ViewUpdater;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;

/**
 * ViewUpdater that maintains a local cache of product availability in the order-service.
 * Listens to product and stock events from the inventory-service to keep the cache synchronized.
 *
 * <p>This enables the order service to check product availability and enrich orders
 * with product information without making synchronous service calls, following the CQRS pattern.
 *
 * <p>Supported events:
 * <ul>
 *   <li>{@link ProductCreatedEvent} - Creates new product availability entry</li>
 *   <li>{@link StockReservedEvent} - Increases reserved quantity</li>
 *   <li>{@link StockReleasedEvent} - Decreases reserved quantity</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
public class ProductAvailabilityViewUpdater extends ViewUpdater<String> {

    private static final Logger logger = LoggerFactory.getLogger(ProductAvailabilityViewUpdater.class);

    /**
     * Schema name for the product availability view.
     */
    public static final String VIEW_SCHEMA = "ProductAvailability";

    /**
     * Creates a new ProductAvailabilityViewUpdater.
     *
     * @param viewStore the view store to update
     */
    public ProductAvailabilityViewUpdater(HazelcastViewStore<String> viewStore) {
        super(viewStore);
    }

    @Override
    protected String extractKey(GenericRecord eventRecord) {
        return getStringField(eventRecord, "key");
    }

    @Override
    protected GenericRecord applyEvent(GenericRecord eventRecord, GenericRecord currentState) {
        String eventType = getEventType(eventRecord);

        logger.debug("Applying event type: {} to product availability cache", eventType);

        return switch (eventType) {
            case ProductCreatedEvent.EVENT_TYPE -> applyProductCreated(eventRecord);
            case StockReservedEvent.EVENT_TYPE -> applyStockReserved(eventRecord, currentState);
            case StockReleasedEvent.EVENT_TYPE -> applyStockReleased(eventRecord, currentState);
            default -> {
                logger.debug("Ignoring event type: {} (not relevant to product availability)", eventType);
                yield currentState;
            }
        };
    }

    /**
     * Applies a ProductCreatedEvent to create a new product availability entry.
     *
     * @param eventRecord the event record
     * @return the new product availability entry
     */
    private GenericRecord applyProductCreated(GenericRecord eventRecord) {
        Instant now = Instant.now();

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("productId", getStringField(eventRecord, "key"))
                .setString("sku", getStringField(eventRecord, "sku"))
                .setString("name", getStringField(eventRecord, "name"))
                .setString("description", getStringField(eventRecord, "description"))
                .setString("price", getStringField(eventRecord, "price"))
                .setInt32("quantityOnHand", getIntField(eventRecord, "initialQuantity"))
                .setInt32("quantityReserved", 0)
                .setString("category", getStringField(eventRecord, "category"))
                .setString("status", Product.Status.ACTIVE.name())
                .setInt64("cachedAt", now.toEpochMilli())
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a StockReservedEvent to increase reserved quantity.
     *
     * @param eventRecord the event record
     * @param currentState the current cache state
     * @return the updated product availability entry
     */
    private GenericRecord applyStockReserved(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.warn("Cannot reserve stock for non-existent product availability entry: {}",
                    getStringField(eventRecord, "key"));
            return null;
        }

        Instant now = Instant.now();
        int quantity = getIntField(eventRecord, "quantity");
        int currentReserved = currentState.getInt32("quantityReserved");
        int newReserved = currentReserved + quantity;

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("productId", currentState.getString("productId"))
                .setString("sku", currentState.getString("sku"))
                .setString("name", currentState.getString("name"))
                .setString("description", currentState.getString("description"))
                .setString("price", currentState.getString("price"))
                .setInt32("quantityOnHand", currentState.getInt32("quantityOnHand"))
                .setInt32("quantityReserved", newReserved)
                .setString("category", currentState.getString("category"))
                .setString("status", currentState.getString("status"))
                .setInt64("cachedAt", currentState.getInt64("cachedAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a StockReleasedEvent to decrease reserved quantity.
     *
     * @param eventRecord the event record
     * @param currentState the current cache state
     * @return the updated product availability entry
     */
    private GenericRecord applyStockReleased(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.warn("Cannot release stock for non-existent product availability entry: {}",
                    getStringField(eventRecord, "key"));
            return null;
        }

        Instant now = Instant.now();
        int quantity = getIntField(eventRecord, "quantity");
        int currentReserved = currentState.getInt32("quantityReserved");
        int newReserved = Math.max(0, currentReserved - quantity);

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("productId", currentState.getString("productId"))
                .setString("sku", currentState.getString("sku"))
                .setString("name", currentState.getString("name"))
                .setString("description", currentState.getString("description"))
                .setString("price", currentState.getString("price"))
                .setInt32("quantityOnHand", currentState.getInt32("quantityOnHand"))
                .setInt32("quantityReserved", newReserved)
                .setString("category", currentState.getString("category"))
                .setString("status", currentState.getString("status"))
                .setInt64("cachedAt", currentState.getInt64("cachedAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Returns the available quantity for a product.
     *
     * @param productRecord the product record from the view
     * @return the available quantity (on hand minus reserved)
     */
    public static int getAvailableQuantity(GenericRecord productRecord) {
        if (productRecord == null) {
            return 0;
        }
        int onHand = productRecord.getInt32("quantityOnHand");
        int reserved = productRecord.getInt32("quantityReserved");
        return onHand - reserved;
    }
}
