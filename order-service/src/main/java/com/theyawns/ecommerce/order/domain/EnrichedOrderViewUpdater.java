package com.theyawns.ecommerce.order.domain;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.ecommerce.common.domain.Order;
import com.theyawns.ecommerce.common.events.OrderCancelledEvent;
import com.theyawns.ecommerce.common.events.OrderConfirmedEvent;
import com.theyawns.ecommerce.common.events.OrderCreatedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import com.theyawns.framework.view.ViewUpdater;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;
import java.util.Optional;

/**
 * ViewUpdater that creates an enriched order view combining order data with
 * denormalized customer and product information.
 *
 * <p>This view provides:
 * <ul>
 *   <li>Full order details (line items, totals, status)</li>
 *   <li>Denormalized customer info (name, email, address, status)</li>
 *   <li>Enriched line items with current product availability</li>
 * </ul>
 *
 * <p>The enriched view enables fast, complete queries without needing
 * to join data from multiple services at query time.
 *
 * <p>Supported events:
 * <ul>
 *   <li>{@link OrderCreatedEvent} - Creates enriched order entry</li>
 *   <li>{@link OrderConfirmedEvent} - Updates order status</li>
 *   <li>{@link OrderCancelledEvent} - Updates order status</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
public class EnrichedOrderViewUpdater extends ViewUpdater<String> {

    private static final Logger logger = LoggerFactory.getLogger(EnrichedOrderViewUpdater.class);

    /**
     * Schema name for the enriched order view.
     */
    public static final String VIEW_SCHEMA = "EnrichedOrder";

    private final HazelcastViewStore<String> customerCacheStore;
    private final HazelcastViewStore<String> productAvailabilityStore;

    /**
     * Creates a new EnrichedOrderViewUpdater.
     *
     * @param viewStore the view store to update
     * @param customerCacheStore the customer cache view store for customer data
     * @param productAvailabilityStore the product availability view store for product data
     */
    public EnrichedOrderViewUpdater(
            HazelcastViewStore<String> viewStore,
            HazelcastViewStore<String> customerCacheStore,
            HazelcastViewStore<String> productAvailabilityStore) {
        super(viewStore);
        this.customerCacheStore = customerCacheStore;
        this.productAvailabilityStore = productAvailabilityStore;
    }

    @Override
    protected String extractKey(GenericRecord eventRecord) {
        return getStringField(eventRecord, "key");
    }

    @Override
    protected GenericRecord applyEvent(GenericRecord eventRecord, GenericRecord currentState) {
        String eventType = getEventType(eventRecord);

        logger.debug("Applying event type: {} to enriched order view", eventType);

        return switch (eventType) {
            case OrderCreatedEvent.EVENT_TYPE -> applyOrderCreated(eventRecord, currentState);
            case OrderConfirmedEvent.EVENT_TYPE -> applyOrderConfirmed(eventRecord, currentState);
            case OrderCancelledEvent.EVENT_TYPE -> applyOrderCancelled(eventRecord, currentState);
            default -> {
                logger.debug("Ignoring event type: {} (not relevant to enriched order)", eventType);
                yield currentState;
            }
        };
    }

    /**
     * Overrides the update method to fetch external data before the update.
     * This avoids deadlocks from accessing other maps within an entry processor.
     * Uses updateDirect to avoid entry processor threading issues.
     *
     * @param eventRecord the event to process
     * @return the updated view state
     */
    @Override
    public GenericRecord update(GenericRecord eventRecord) {
        String eventType = getEventType(eventRecord);

        // For OrderCreatedEvent, pre-fetch customer and product data and use direct update
        if (OrderCreatedEvent.EVENT_TYPE.equals(eventType)) {
            return updateWithPrefetch(eventRecord);
        }

        // For other events, use the standard update (via updateDirect to be safe)
        return updateDirect(eventRecord);
    }

    /**
     * Updates the view after pre-fetching external data.
     * Uses updateDirect to avoid entry processor which runs on a different thread.
     *
     * @param eventRecord the event record
     * @return the updated view state
     */
    private GenericRecord updateWithPrefetch(GenericRecord eventRecord) {
        String orderId = extractKey(eventRecord);
        if (orderId == null) {
            logger.warn("Could not extract key from event: {}", eventRecord);
            return null;
        }

        // Pre-fetch customer data
        String customerId = getStringField(eventRecord, "customerId");
        GenericRecord customerData = null;
        if (customerId != null) {
            customerData = customerCacheStore.get(customerId).orElse(null);
        }

        // Pre-fetch product data for line items
        GenericRecord[] lineItems = eventRecord.getArrayOfGenericRecord("lineItems");
        GenericRecord[] productDataArray = null;
        if (lineItems != null) {
            productDataArray = new GenericRecord[lineItems.length];
            for (int i = 0; i < lineItems.length; i++) {
                String productId = lineItems[i].getString("productId");
                if (productId != null) {
                    productDataArray[i] = productAvailabilityStore.get(productId).orElse(null);
                }
            }
        }

        // Store pre-fetched data for use in applyEvent
        prefetchedCustomer.set(customerData);
        prefetchedProducts.set(productDataArray);

        try {
            // Use updateDirect which runs on the same thread
            return updateDirect(eventRecord);
        } finally {
            prefetchedCustomer.remove();
            prefetchedProducts.remove();
        }
    }

    // Thread-local storage for pre-fetched data (works with updateDirect on same thread)
    private static final ThreadLocal<GenericRecord> prefetchedCustomer = new ThreadLocal<>();
    private static final ThreadLocal<GenericRecord[]> prefetchedProducts = new ThreadLocal<>();

    /**
     * Applies an OrderCreatedEvent to create a new enriched order entry.
     * Uses pre-fetched customer and product data to avoid deadlocks.
     *
     * @param eventRecord the event record
     * @param currentState ignored for create events
     * @return the new enriched order entry
     */
    private GenericRecord applyOrderCreated(GenericRecord eventRecord, GenericRecord currentState) {
        Instant now = Instant.now();
        String orderId = getStringField(eventRecord, "key");
        String customerId = getStringField(eventRecord, "customerId");

        // Use pre-fetched customer data (avoids deadlock in entry processor)
        GenericRecord customer = prefetchedCustomer.get();
        String customerName = getStringField(eventRecord, "customerName");
        String customerEmail = getStringField(eventRecord, "customerEmail");
        String customerStatus = "UNKNOWN";

        if (customer != null) {
            // Use cached customer data if event data is missing
            if (customerName == null || customerName.isEmpty()) {
                customerName = customer.getString("name");
            }
            if (customerEmail == null || customerEmail.isEmpty()) {
                customerEmail = customer.getString("email");
            }
            customerStatus = customer.getString("status");
        }

        // Get line items and enrich with pre-fetched product data
        GenericRecord[] lineItems = eventRecord.getArrayOfGenericRecord("lineItems");
        GenericRecord[] enrichedLineItems = enrichLineItemsWithPrefetch(lineItems);

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("orderId", orderId)
                .setString("customerId", customerId)
                .setString("customerName", customerName)
                .setString("customerEmail", customerEmail)
                .setString("customerStatus", customerStatus)
                .setArrayOfGenericRecord("lineItems", enrichedLineItems)
                .setString("subtotal", getStringField(eventRecord, "subtotal"))
                .setString("tax", getStringField(eventRecord, "tax"))
                .setString("total", getStringField(eventRecord, "total"))
                .setString("shippingAddress", getStringField(eventRecord, "shippingAddress"))
                .setString("status", Order.Status.PENDING.name())
                .setInt64("createdAt", now.toEpochMilli())
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Enriches line items with pre-fetched product availability information.
     * Uses thread-local pre-fetched data to avoid deadlocks in entry processor.
     *
     * @param lineItems the original line items
     * @return enriched line items with product availability
     */
    private GenericRecord[] enrichLineItemsWithPrefetch(GenericRecord[] lineItems) {
        if (lineItems == null || lineItems.length == 0) {
            return new GenericRecord[0];
        }

        GenericRecord[] productDataArray = prefetchedProducts.get();
        GenericRecord[] enriched = new GenericRecord[lineItems.length];

        for (int i = 0; i < lineItems.length; i++) {
            GenericRecord item = lineItems[i];
            String productId = item.getString("productId");

            int availableQuantity = 0;
            String productStatus = "UNKNOWN";

            // Use pre-fetched product data
            if (productDataArray != null && i < productDataArray.length && productDataArray[i] != null) {
                GenericRecord product = productDataArray[i];
                availableQuantity = ProductAvailabilityViewUpdater.getAvailableQuantity(product);
                productStatus = product.getString("status");
            }

            // Create enriched line item with availability info
            enriched[i] = GenericRecordBuilder.compact("EnrichedOrderLineItem")
                    .setString("productId", productId)
                    .setString("productName", item.getString("productName"))
                    .setString("sku", item.getString("sku"))
                    .setInt32("quantity", item.getInt32("quantity"))
                    .setString("unitPrice", item.getString("unitPrice"))
                    .setString("lineTotal", item.getString("lineTotal"))
                    .setInt32("availableQuantity", availableQuantity)
                    .setString("productStatus", productStatus)
                    .build();
        }

        return enriched;
    }

    /**
     * Applies an OrderConfirmedEvent to update order status to CONFIRMED.
     *
     * @param eventRecord the event record
     * @param currentState the current enriched order state
     * @return the updated enriched order entry
     */
    private GenericRecord applyOrderConfirmed(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.error("Cannot confirm non-existent enriched order: {}",
                    getStringField(eventRecord, "key"));
            return null;
        }

        Instant now = Instant.now();

        // Re-enrich line items with current availability
        GenericRecord[] lineItems = currentState.getArrayOfGenericRecord("lineItems");

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("orderId", currentState.getString("orderId"))
                .setString("customerId", currentState.getString("customerId"))
                .setString("customerName", currentState.getString("customerName"))
                .setString("customerEmail", currentState.getString("customerEmail"))
                .setString("customerStatus", currentState.getString("customerStatus"))
                .setArrayOfGenericRecord("lineItems", lineItems)
                .setString("subtotal", currentState.getString("subtotal"))
                .setString("tax", currentState.getString("tax"))
                .setString("total", currentState.getString("total"))
                .setString("shippingAddress", currentState.getString("shippingAddress"))
                .setString("status", Order.Status.CONFIRMED.name())
                .setString("confirmationNumber", getStringField(eventRecord, "confirmationNumber"))
                .setInt64("createdAt", currentState.getInt64("createdAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies an OrderCancelledEvent to update order status to CANCELLED.
     *
     * @param eventRecord the event record
     * @param currentState the current enriched order state
     * @return the updated enriched order entry
     */
    private GenericRecord applyOrderCancelled(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.error("Cannot cancel non-existent enriched order: {}",
                    getStringField(eventRecord, "key"));
            return null;
        }

        Instant now = Instant.now();
        GenericRecord[] lineItems = currentState.getArrayOfGenericRecord("lineItems");

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("orderId", currentState.getString("orderId"))
                .setString("customerId", currentState.getString("customerId"))
                .setString("customerName", currentState.getString("customerName"))
                .setString("customerEmail", currentState.getString("customerEmail"))
                .setString("customerStatus", currentState.getString("customerStatus"))
                .setArrayOfGenericRecord("lineItems", lineItems)
                .setString("subtotal", currentState.getString("subtotal"))
                .setString("tax", currentState.getString("tax"))
                .setString("total", currentState.getString("total"))
                .setString("shippingAddress", currentState.getString("shippingAddress"))
                .setString("status", Order.Status.CANCELLED.name())
                .setString("cancellationReason", getStringField(eventRecord, "reason"))
                .setString("cancelledBy", getStringField(eventRecord, "cancelledBy"))
                .setInt64("createdAt", currentState.getInt64("createdAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }
}
