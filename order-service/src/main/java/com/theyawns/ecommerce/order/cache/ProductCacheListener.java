package com.theyawns.ecommerce.order.cache;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.topic.ITopic;
import com.hazelcast.topic.Message;
import com.hazelcast.topic.MessageListener;
import com.theyawns.ecommerce.common.events.ProductCreatedEvent;
import com.theyawns.ecommerce.common.events.StockReleasedEvent;
import com.theyawns.ecommerce.common.events.StockReservedEvent;
import com.theyawns.ecommerce.order.domain.ProductAvailabilityViewUpdater;
import jakarta.annotation.PostConstruct;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Qualifier;
import org.springframework.stereotype.Component;

/**
 * Listens for product-related events on the shared cluster and updates
 * the local product availability cache.
 *
 * <p>This enables the order service to have an up-to-date view of product
 * information (including prices) for order enrichment, without making
 * synchronous calls to the inventory service.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@Component
public class ProductCacheListener {

    private static final Logger logger = LoggerFactory.getLogger(ProductCacheListener.class);

    private final HazelcastInstance hazelcast;
    private final ProductAvailabilityViewUpdater viewUpdater;

    /**
     * Creates a new ProductCacheListener.
     *
     * @param hazelcast the shared Hazelcast client
     * @param viewUpdater the view updater for applying events
     */
    public ProductCacheListener(
            @Qualifier("hazelcastClient") HazelcastInstance hazelcast,
            ProductAvailabilityViewUpdater viewUpdater) {
        this.hazelcast = hazelcast;
        this.viewUpdater = viewUpdater;
    }

    /**
     * Registers listeners for product-related topics on startup.
     */
    @PostConstruct
    public void registerListeners() {
        if (hazelcast == null) {
            logger.warn("Shared Hazelcast client not available - product cache will not sync");
            return;
        }

        logger.info("Registering product cache event listeners");

        ITopic<GenericRecord> productCreatedTopic = hazelcast.getTopic(ProductCreatedEvent.EVENT_TYPE);
        productCreatedTopic.addMessageListener(new ProductEventListener());

        ITopic<GenericRecord> stockReservedTopic = hazelcast.getTopic(StockReservedEvent.EVENT_TYPE);
        stockReservedTopic.addMessageListener(new ProductEventListener());

        ITopic<GenericRecord> stockReleasedTopic = hazelcast.getTopic(StockReleasedEvent.EVENT_TYPE);
        stockReleasedTopic.addMessageListener(new ProductEventListener());

        logger.info("Product cache listeners registered successfully");
    }

    /**
     * Generic listener that applies product-related events to the cache.
     */
    class ProductEventListener implements MessageListener<GenericRecord> {

        @Override
        public void onMessage(Message<GenericRecord> message) {
            GenericRecord record = message.getMessageObject();
            String eventType = record.getString("eventType");

            logger.debug("Received {} event for product cache update", eventType);

            try {
                viewUpdater.updateDirect(record);
                logger.debug("Product cache updated for event: {}", eventType);
            } catch (Exception e) {
                logger.error("Failed to update product cache for event: {}", eventType, e);
            }
        }
    }
}
