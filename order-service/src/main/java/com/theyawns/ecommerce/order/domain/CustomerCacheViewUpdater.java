package com.theyawns.ecommerce.order.domain;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.ecommerce.common.domain.Customer;
import com.theyawns.ecommerce.common.events.CustomerCreatedEvent;
import com.theyawns.ecommerce.common.events.CustomerStatusChangedEvent;
import com.theyawns.ecommerce.common.events.CustomerUpdatedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import com.theyawns.framework.view.ViewUpdater;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;

/**
 * ViewUpdater that maintains a local cache of customer data in the order-service.
 * Listens to customer events from the account-service to keep the cache synchronized.
 *
 * <p>This enables the order service to enrich orders with customer information
 * without making synchronous service calls, following the CQRS pattern.
 *
 * <p>Supported events:
 * <ul>
 *   <li>{@link CustomerCreatedEvent} - Creates new customer cache entry</li>
 *   <li>{@link CustomerUpdatedEvent} - Updates customer details</li>
 *   <li>{@link CustomerStatusChangedEvent} - Updates customer status</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
public class CustomerCacheViewUpdater extends ViewUpdater<String> {

    private static final Logger logger = LoggerFactory.getLogger(CustomerCacheViewUpdater.class);

    /**
     * Schema name for the customer cache view.
     */
    public static final String VIEW_SCHEMA = "CustomerCache";

    /**
     * Creates a new CustomerCacheViewUpdater.
     *
     * @param viewStore the view store to update
     */
    public CustomerCacheViewUpdater(HazelcastViewStore<String> viewStore) {
        super(viewStore);
    }

    @Override
    protected String extractKey(GenericRecord eventRecord) {
        return getStringField(eventRecord, "key");
    }

    @Override
    protected GenericRecord applyEvent(GenericRecord eventRecord, GenericRecord currentState) {
        String eventType = getEventType(eventRecord);

        logger.debug("Applying event type: {} to customer cache", eventType);

        return switch (eventType) {
            case CustomerCreatedEvent.EVENT_TYPE -> applyCustomerCreated(eventRecord);
            case CustomerUpdatedEvent.EVENT_TYPE -> applyCustomerUpdated(eventRecord, currentState);
            case CustomerStatusChangedEvent.EVENT_TYPE -> applyCustomerStatusChanged(eventRecord, currentState);
            default -> {
                logger.debug("Ignoring event type: {} (not relevant to customer cache)", eventType);
                yield currentState;
            }
        };
    }

    /**
     * Applies a CustomerCreatedEvent to create a new customer cache entry.
     *
     * @param eventRecord the event record
     * @return the new customer cache entry
     */
    private GenericRecord applyCustomerCreated(GenericRecord eventRecord) {
        Instant now = Instant.now();

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("customerId", getStringField(eventRecord, "key"))
                .setString("email", getStringField(eventRecord, "email"))
                .setString("name", getStringField(eventRecord, "name"))
                .setString("address", getStringField(eventRecord, "address"))
                .setString("phone", getStringField(eventRecord, "phone"))
                .setString("status", Customer.Status.ACTIVE.name())
                .setInt64("cachedAt", now.toEpochMilli())
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a CustomerUpdatedEvent to update customer details.
     *
     * @param eventRecord the event record
     * @param currentState the current cache state
     * @return the updated customer cache entry
     */
    private GenericRecord applyCustomerUpdated(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.warn("Cannot update non-existent customer cache entry: {}",
                    getStringField(eventRecord, "key"));
            return null;
        }

        Instant now = Instant.now();

        // Apply updates, keeping existing values if not provided in event
        String name = getStringField(eventRecord, "name");
        String address = getStringField(eventRecord, "address");
        String phone = getStringField(eventRecord, "phone");

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("customerId", currentState.getString("customerId"))
                .setString("email", currentState.getString("email"))
                .setString("name", name != null ? name : currentState.getString("name"))
                .setString("address", address != null ? address : currentState.getString("address"))
                .setString("phone", phone != null ? phone : currentState.getString("phone"))
                .setString("status", currentState.getString("status"))
                .setInt64("cachedAt", currentState.getInt64("cachedAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a CustomerStatusChangedEvent to update customer status.
     *
     * @param eventRecord the event record
     * @param currentState the current cache state
     * @return the updated customer cache entry
     */
    private GenericRecord applyCustomerStatusChanged(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.warn("Cannot change status of non-existent customer cache entry: {}",
                    getStringField(eventRecord, "key"));
            return null;
        }

        Instant now = Instant.now();

        return GenericRecordBuilder.compact(VIEW_SCHEMA)
                .setString("customerId", currentState.getString("customerId"))
                .setString("email", currentState.getString("email"))
                .setString("name", currentState.getString("name"))
                .setString("address", currentState.getString("address"))
                .setString("phone", currentState.getString("phone"))
                .setString("status", getStringField(eventRecord, "newStatus"))
                .setInt64("cachedAt", currentState.getInt64("cachedAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }
}
