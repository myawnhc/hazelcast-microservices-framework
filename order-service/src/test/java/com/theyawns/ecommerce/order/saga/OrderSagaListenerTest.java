package com.theyawns.ecommerce.order.saga;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.hazelcast.topic.Message;
import com.theyawns.ecommerce.common.domain.Order;
import com.theyawns.ecommerce.order.service.OrderOperations;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.util.UUID;
import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Unit tests for OrderSagaListener.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("OrderSagaListener")
@ExtendWith(MockitoExtension.class)
class OrderSagaListenerTest {

    @Mock
    private OrderOperations orderService;

    @Mock
    private HazelcastInstance hazelcast;

    private OrderSagaListener listener;

    @BeforeEach
    void setUp() {
        listener = new OrderSagaListener(orderService, hazelcast);
    }

    @Nested
    @DisplayName("PaymentProcessed event handling")
    class PaymentProcessedTests {

        @Test
        @DisplayName("should confirm order when PaymentProcessed saga event is received")
        void shouldConfirmOrderForSagaEvent() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();
            String paymentId = UUID.randomUUID().toString();

            GenericRecord paymentProcessedRecord = GenericRecordBuilder.compact("PaymentProcessedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "PaymentProcessed")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Payment")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", paymentId)
                    .setString("correlationId", correlationId)
                    .setString("sagaId", sagaId)
                    .setString("sagaType", "OrderFulfillment")
                    .setInt32("stepNumber", 2)
                    .setBoolean("isCompensating", false)
                    .setString("orderId", orderId)
                    .setString("customerId", "cust-1")
                    .setString("amount", "22.00")
                    .setString("currency", "USD")
                    .setString("transactionId", "txn-123")
                    .setString("method", "CREDIT_CARD")
                    .build();

            Order mockOrder = mock(Order.class);
            when(mockOrder.getStatus()).thenReturn(Order.Status.CONFIRMED);
            when(orderService.confirmOrderForSaga(anyString(), anyString(), anyString()))
                    .thenReturn(CompletableFuture.completedFuture(mockOrder));

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(paymentProcessedRecord);

            // Act
            listener.new PaymentProcessedListener().onMessage(message);

            // Assert
            verify(orderService).confirmOrderForSaga(
                    eq(orderId),
                    eq(sagaId),
                    eq(correlationId)
            );
        }

        @Test
        @DisplayName("should ignore PaymentProcessed events without sagaId")
        void shouldIgnoreNonSagaEvents() {
            // Arrange
            GenericRecord record = GenericRecordBuilder.compact("PaymentProcessedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "PaymentProcessed")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Payment")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", UUID.randomUUID().toString())
                    .setString("correlationId", UUID.randomUUID().toString())
                    .setString("sagaId", null)
                    .setString("sagaType", null)
                    .setInt32("stepNumber", 0)
                    .setBoolean("isCompensating", false)
                    .setString("orderId", "order-1")
                    .setString("customerId", "cust-1")
                    .setString("amount", "10.00")
                    .setString("currency", "USD")
                    .setString("transactionId", "txn-456")
                    .setString("method", "CREDIT_CARD")
                    .build();

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(record);

            // Act
            listener.new PaymentProcessedListener().onMessage(message);

            // Assert
            verify(orderService, never()).confirmOrderForSaga(anyString(), anyString(), anyString());
        }

        @Test
        @DisplayName("should handle service exception gracefully")
        void shouldHandleServiceExceptionGracefully() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord record = GenericRecordBuilder.compact("PaymentProcessedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "PaymentProcessed")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Payment")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", UUID.randomUUID().toString())
                    .setString("correlationId", correlationId)
                    .setString("sagaId", sagaId)
                    .setString("sagaType", "OrderFulfillment")
                    .setInt32("stepNumber", 2)
                    .setBoolean("isCompensating", false)
                    .setString("orderId", orderId)
                    .setString("customerId", "cust-1")
                    .setString("amount", "10.00")
                    .setString("currency", "USD")
                    .setString("transactionId", "txn-789")
                    .setString("method", "CREDIT_CARD")
                    .build();

            when(orderService.confirmOrderForSaga(anyString(), anyString(), anyString()))
                    .thenThrow(new RuntimeException("Order not found"));

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(record);

            // Act - should not throw
            listener.new PaymentProcessedListener().onMessage(message);

            // Assert - exception was caught internally
            verify(orderService).confirmOrderForSaga(eq(orderId), eq(sagaId), eq(correlationId));
        }
    }
}
