package com.theyawns.ecommerce.order.saga;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.theyawns.framework.saga.CompensationRegistry;
import com.theyawns.framework.saga.DefaultSagaCompensator;
import com.theyawns.framework.saga.HazelcastSagaStateStore;
import com.theyawns.framework.saga.SagaCompensationConfig;
import com.theyawns.framework.saga.SagaCompensator;
import com.theyawns.framework.saga.SagaState;
import com.theyawns.framework.saga.SagaStateStore;
import com.theyawns.framework.saga.SagaStatus;
import com.theyawns.framework.saga.SagaTimeoutConfig;
import com.theyawns.framework.saga.SagaTimeoutDetector;
import io.micrometer.core.instrument.MeterRegistry;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestMethodOrder;

import java.time.Duration;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Integration test for the Order Fulfillment Saga timeout path.
 *
 * <p>Validates the timeout detection and compensation flow when a saga
 * gets stuck (e.g., inventory or payment service is unresponsive):
 * <ol>
 *   <li>OrderCreated (step 0) - Order service creates order and starts saga</li>
 *   <li>No further steps complete (simulating stuck service)</li>
 *   <li>Saga exceeds its deadline</li>
 *   <li>SagaTimeoutDetector detects the timeout</li>
 *   <li>Saga transitions to TIMED_OUT status</li>
 *   <li>Compensation is triggered automatically</li>
 * </ol>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("Order Fulfillment Saga - Timeout Path Integration")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class OrderFulfillmentSagaTimeoutTest {

    private HazelcastInstance hazelcast;
    private SagaStateStore sagaStateStore;
    private SagaTimeoutDetector timeoutDetector;
    private SagaTimeoutConfig timeoutConfig;
    private MeterRegistry meterRegistry;
    private CompensationRegistry compensationRegistry;

    // Test data
    private final String sagaId = UUID.randomUUID().toString();
    private final String correlationId = UUID.randomUUID().toString();

    @BeforeAll
    void setUp() {
        Config config = new Config();
        config.setClusterName("saga-timeout-test-" + System.currentTimeMillis());
        hazelcast = Hazelcast.newHazelcastInstance(config);

        meterRegistry = new SimpleMeterRegistry();
        sagaStateStore = new HazelcastSagaStateStore(hazelcast, meterRegistry);

        // Set up compensation registry with order fulfillment mappings
        compensationRegistry = new CompensationRegistry();
        compensationRegistry.register(
                SagaCompensationConfig.ORDER_CREATED,
                SagaCompensationConfig.ORDER_CANCELLED,
                SagaCompensationConfig.ORDER_SERVICE
        );
        compensationRegistry.register(
                SagaCompensationConfig.STOCK_RESERVED,
                SagaCompensationConfig.STOCK_RELEASED,
                SagaCompensationConfig.INVENTORY_SERVICE
        );
        compensationRegistry.register(
                SagaCompensationConfig.PAYMENT_PROCESSED,
                SagaCompensationConfig.PAYMENT_REFUNDED,
                SagaCompensationConfig.PAYMENT_SERVICE
        );

        // Configure timeout detection
        timeoutConfig = new SagaTimeoutConfig();
        timeoutConfig.setEnabled(true);
        timeoutConfig.setCheckInterval(Duration.ofMillis(100));
        timeoutConfig.setDefaultDeadline(Duration.ofSeconds(30));
        timeoutConfig.setAutoCompensate(true);
        timeoutConfig.setMaxBatchSize(100);

        // Create compensator and detector
        SagaCompensator compensator = new DefaultSagaCompensator(
                sagaStateStore,
                compensationRegistry,
                hazelcast,
                null, // no Spring event publisher in integration test
                meterRegistry
        );

        timeoutDetector = new SagaTimeoutDetector(
                sagaStateStore,
                compensator,
                timeoutConfig,
                hazelcast,
                null, // no Spring event publisher in integration test
                meterRegistry
        );
    }

    @AfterAll
    void tearDown() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @Test
    @DisplayName("should detect and handle timed-out saga")
    @org.junit.jupiter.api.Order(1)
    void shouldDetectAndHandleTimedOutSaga() throws InterruptedException {
        // ===== Start saga with a very short deadline (100ms) =====
        SagaState state = sagaStateStore.startSaga(
                sagaId,
                SagaCompensationConfig.ORDER_FULFILLMENT_SAGA,
                correlationId,
                4,
                Duration.ofMillis(100) // Very short deadline to trigger timeout
        );

        assertNotNull(state);
        assertEquals(SagaStatus.STARTED, state.getStatus());

        // ===== Step 0: Order Created =====
        state = sagaStateStore.recordStepCompleted(
                sagaId,
                SagaCompensationConfig.STEP_ORDER_CREATED,
                SagaCompensationConfig.ORDER_CREATED,
                SagaCompensationConfig.ORDER_SERVICE,
                "evt-order-created"
        );

        assertEquals(SagaStatus.IN_PROGRESS, state.getStatus());
        assertEquals(1, state.getCurrentStep());

        // ===== Simulate stuck service: no further steps complete =====
        // Wait for deadline to pass
        Thread.sleep(200);

        // ===== Verify saga is now past deadline =====
        Optional<SagaState> staleState = sagaStateStore.getSagaState(sagaId);
        assertTrue(staleState.isPresent());
        assertTrue(staleState.get().isTimedOut(), "Saga should be past its deadline");

        // ===== Verify findTimedOutSagas returns this saga =====
        List<SagaState> timedOutSagas = sagaStateStore.findTimedOutSagas();
        assertTrue(timedOutSagas.stream().anyMatch(s -> s.getSagaId().equals(sagaId)),
                "Timed-out saga should appear in findTimedOutSagas query");

        // ===== Trigger timeout detection =====
        timeoutDetector.performTimeoutCheck();

        // ===== Verify saga transitioned to TIMED_OUT =====
        Optional<SagaState> afterTimeout = sagaStateStore.getSagaState(sagaId);
        assertTrue(afterTimeout.isPresent());

        // The detector marks the saga as TIMED_OUT, then the compensator
        // marks it as COMPENSATING and eventually COMPENSATED
        SagaStatus finalStatus = afterTimeout.get().getStatus();
        assertTrue(
                finalStatus == SagaStatus.TIMED_OUT ||
                        finalStatus == SagaStatus.COMPENSATING ||
                        finalStatus == SagaStatus.COMPENSATED,
                "Saga should be TIMED_OUT, COMPENSATING, or COMPENSATED but was: " + finalStatus
        );
    }

    @Test
    @DisplayName("should record timeout metrics")
    @org.junit.jupiter.api.Order(2)
    void shouldRecordTimeoutMetrics() {
        // Verify timeout detection metrics were recorded
        double timeoutsDetected = meterRegistry.counter("saga.timeouts.detected").count();
        assertTrue(timeoutsDetected >= 1.0, "Should have detected at least 1 timeout");

        // Verify the detector tracked the timeout
        assertTrue(timeoutDetector.getTotalTimeoutsDetected() >= 1,
                "Detector should track total timeouts");
    }

    @Test
    @DisplayName("should record check duration metric")
    @org.junit.jupiter.api.Order(3)
    void shouldRecordCheckDurationMetric() {
        long checkCount = meterRegistry.timer("saga.timeout.check.duration").count();
        assertTrue(checkCount >= 1, "Should have recorded at least 1 check duration");
    }

    @Test
    @DisplayName("should no longer find timed-out saga as active")
    @org.junit.jupiter.api.Order(4)
    void shouldNoLongerFindTimedOutSagaAsActive() {
        List<SagaState> activeSagas = sagaStateStore.findActiveSagas();
        assertFalse(activeSagas.stream().anyMatch(s -> s.getSagaId().equals(sagaId)),
                "Timed-out saga should not appear as active");
    }

    @Test
    @DisplayName("should handle multiple concurrent timed-out sagas")
    @org.junit.jupiter.api.Order(5)
    void shouldHandleMultipleConcurrentTimedOutSagas() throws InterruptedException {
        // Start 3 sagas with short deadlines
        String sagaId1 = UUID.randomUUID().toString();
        String sagaId2 = UUID.randomUUID().toString();
        String sagaId3 = UUID.randomUUID().toString();

        for (String id : List.of(sagaId1, sagaId2, sagaId3)) {
            SagaState state = sagaStateStore.startSaga(
                    id,
                    SagaCompensationConfig.ORDER_FULFILLMENT_SAGA,
                    UUID.randomUUID().toString(),
                    4,
                    Duration.ofMillis(50)
            );

            // Complete step 0 only
            sagaStateStore.recordStepCompleted(
                    id,
                    SagaCompensationConfig.STEP_ORDER_CREATED,
                    SagaCompensationConfig.ORDER_CREATED,
                    SagaCompensationConfig.ORDER_SERVICE,
                    "evt-" + id
            );
        }

        // Wait for deadlines to pass
        Thread.sleep(150);

        // Trigger timeout detection
        long beforeCount = timeoutDetector.getTotalTimeoutsDetected();
        timeoutDetector.performTimeoutCheck();
        long afterCount = timeoutDetector.getTotalTimeoutsDetected();

        // Should have detected all 3 new timeouts
        assertTrue(afterCount - beforeCount >= 3,
                "Should detect at least 3 new timeouts, detected: " + (afterCount - beforeCount));
    }

    @Test
    @DisplayName("should respect max batch size for timeout processing")
    @org.junit.jupiter.api.Order(6)
    void shouldRespectMaxBatchSizeForTimeoutProcessing() throws InterruptedException {
        // Set a small batch size
        timeoutConfig.setMaxBatchSize(2);

        // Start 5 sagas with short deadlines
        for (int i = 0; i < 5; i++) {
            String id = UUID.randomUUID().toString();
            sagaStateStore.startSaga(
                    id,
                    SagaCompensationConfig.ORDER_FULFILLMENT_SAGA,
                    UUID.randomUUID().toString(),
                    4,
                    Duration.ofMillis(50)
            );
        }

        // Wait for deadlines to pass
        Thread.sleep(150);

        long beforeCount = timeoutDetector.getTotalTimeoutsDetected();
        timeoutDetector.performTimeoutCheck();
        long afterCount = timeoutDetector.getTotalTimeoutsDetected();

        // Should process at most 2 (max batch size)
        assertTrue(afterCount - beforeCount <= 2,
                "Should process at most 2 sagas per batch, processed: " + (afterCount - beforeCount));

        // Reset batch size
        timeoutConfig.setMaxBatchSize(100);
    }

    @Test
    @DisplayName("should not timeout completed sagas")
    @org.junit.jupiter.api.Order(7)
    void shouldNotTimeoutCompletedSagas() throws InterruptedException {
        // Start a saga with short deadline and complete it before timeout
        String completedSagaId = UUID.randomUUID().toString();
        sagaStateStore.startSaga(
                completedSagaId,
                SagaCompensationConfig.ORDER_FULFILLMENT_SAGA,
                UUID.randomUUID().toString(),
                4,
                Duration.ofMillis(100)
        );

        // Complete all steps quickly
        sagaStateStore.recordStepCompleted(completedSagaId, 0,
                SagaCompensationConfig.ORDER_CREATED, SagaCompensationConfig.ORDER_SERVICE, "evt-0");
        sagaStateStore.recordStepCompleted(completedSagaId, 1,
                SagaCompensationConfig.STOCK_RESERVED, SagaCompensationConfig.INVENTORY_SERVICE, "evt-1");
        sagaStateStore.recordStepCompleted(completedSagaId, 2,
                SagaCompensationConfig.PAYMENT_PROCESSED, SagaCompensationConfig.PAYMENT_SERVICE, "evt-2");
        sagaStateStore.recordStepCompleted(completedSagaId, 3,
                SagaCompensationConfig.ORDER_CONFIRMED, SagaCompensationConfig.ORDER_SERVICE, "evt-3");

        // Wait for what would be the deadline
        Thread.sleep(200);

        // Completed saga should not show as timed out
        List<SagaState> timedOut = sagaStateStore.findTimedOutSagas();
        assertFalse(timedOut.stream().anyMatch(s -> s.getSagaId().equals(completedSagaId)),
                "Completed saga should not be found as timed out");
    }

    @Test
    @DisplayName("should skip timeout check when disabled")
    @org.junit.jupiter.api.Order(8)
    void shouldSkipTimeoutCheckWhenDisabled() {
        timeoutConfig.setEnabled(false);

        long beforeCount = timeoutDetector.getTotalTimeoutsDetected();
        timeoutDetector.checkForTimedOutSagas();
        long afterCount = timeoutDetector.getTotalTimeoutsDetected();

        assertEquals(beforeCount, afterCount,
                "Should not process any timeouts when disabled");

        // Re-enable for subsequent tests
        timeoutConfig.setEnabled(true);
    }
}
