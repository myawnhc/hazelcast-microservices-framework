package com.theyawns.ecommerce.order.domain;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.ecommerce.common.domain.Product;
import com.theyawns.ecommerce.common.events.ProductCreatedEvent;
import com.theyawns.ecommerce.common.events.StockReleasedEvent;
import com.theyawns.ecommerce.common.events.StockReservedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.math.BigDecimal;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Unit tests for ProductAvailabilityViewUpdater.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@DisplayName("ProductAvailabilityViewUpdater")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class ProductAvailabilityViewUpdaterTest {

    private static final String DOMAIN_NAME = "ProductAvailabilityTest";

    private HazelcastInstance hazelcast;
    private HazelcastViewStore<String> viewStore;
    private ProductAvailabilityViewUpdater viewUpdater;

    @BeforeAll
    void setUpHazelcast() {
        Config config = new Config();
        config.setClusterName("product-availability-test-" + System.currentTimeMillis());
        hazelcast = Hazelcast.newHazelcastInstance(config);
        viewStore = new HazelcastViewStore<>(hazelcast, DOMAIN_NAME);
        viewUpdater = new ProductAvailabilityViewUpdater(viewStore);
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void clearView() {
        viewStore.clear();
    }

    @Nested
    @DisplayName("ProductCreatedEvent handling")
    class ProductCreatedEventTests {

        @Test
        @DisplayName("should create availability entry with all fields")
        void shouldCreateAvailabilityEntryWithAllFields() {
            String productId = UUID.randomUUID().toString();

            ProductCreatedEvent event = new ProductCreatedEvent(
                    productId,
                    "SKU-001",
                    "Test Widget",
                    new BigDecimal("29.99"),
                    100
            );
            event.setDescription("A test widget");
            event.setCategory("Electronics");

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertNotNull(result);
            assertEquals(productId, result.getString("productId"));
            assertEquals("SKU-001", result.getString("sku"));
            assertEquals("Test Widget", result.getString("name"));
            assertEquals("A test widget", result.getString("description"));
            assertEquals("29.99", result.getString("price"));
            assertEquals(100, result.getInt32("quantityOnHand"));
            assertEquals(0, result.getInt32("quantityReserved"));
            assertEquals("Electronics", result.getString("category"));
            assertEquals(Product.Status.ACTIVE.name(), result.getString("status"));
            assertTrue(result.getInt64("cachedAt") > 0);
        }

        @Test
        @DisplayName("should store entry in view store")
        void shouldStoreEntryInViewStore() {
            String productId = UUID.randomUUID().toString();

            ProductCreatedEvent event = new ProductCreatedEvent(
                    productId,
                    "SKU-002",
                    "Stored Product",
                    new BigDecimal("19.99"),
                    50
            );

            viewUpdater.update(event.toGenericRecord());

            Optional<GenericRecord> stored = viewStore.get(productId);
            assertTrue(stored.isPresent());
            assertEquals("Stored Product", stored.get().getString("name"));
        }

        @Test
        @DisplayName("should calculate available quantity correctly for new product")
        void shouldCalculateAvailableQuantityForNewProduct() {
            String productId = UUID.randomUUID().toString();

            ProductCreatedEvent event = new ProductCreatedEvent(
                    productId,
                    "SKU-003",
                    "Available Product",
                    new BigDecimal("9.99"),
                    75
            );

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            // Available = on hand - reserved = 75 - 0 = 75
            assertEquals(75, ProductAvailabilityViewUpdater.getAvailableQuantity(result));
        }
    }

    @Nested
    @DisplayName("StockReservedEvent handling")
    class StockReservedEventTests {

        @Test
        @DisplayName("should increase reserved quantity")
        void shouldIncreaseReservedQuantity() {
            String productId = createProduct(100);

            StockReservedEvent event = new StockReservedEvent(productId, 10, "order-123");

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertNotNull(result);
            assertEquals(100, result.getInt32("quantityOnHand"));
            assertEquals(10, result.getInt32("quantityReserved"));
            assertEquals(90, ProductAvailabilityViewUpdater.getAvailableQuantity(result));
        }

        @Test
        @DisplayName("should accumulate multiple reservations")
        void shouldAccumulateMultipleReservations() {
            String productId = createProduct(100);

            StockReservedEvent event1 = new StockReservedEvent(productId, 10, "order-1");
            viewUpdater.update(event1.toGenericRecord());

            StockReservedEvent event2 = new StockReservedEvent(productId, 15, "order-2");
            GenericRecord result = viewUpdater.update(event2.toGenericRecord());

            assertEquals(25, result.getInt32("quantityReserved"));
            assertEquals(75, ProductAvailabilityViewUpdater.getAvailableQuantity(result));
        }

        @Test
        @DisplayName("should return null for non-existent product")
        void shouldReturnNullForNonExistentProduct() {
            StockReservedEvent event = new StockReservedEvent("non-existent", 10, "order-1");

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertFalse(viewStore.containsKey("non-existent"));
        }
    }

    @Nested
    @DisplayName("StockReleasedEvent handling")
    class StockReleasedEventTests {

        @Test
        @DisplayName("should decrease reserved quantity")
        void shouldDecreaseReservedQuantity() {
            String productId = createProduct(100);

            // First reserve some stock
            StockReservedEvent reserveEvent = new StockReservedEvent(productId, 30, "order-1");
            viewUpdater.update(reserveEvent.toGenericRecord());

            // Then release some
            StockReleasedEvent releaseEvent = new StockReleasedEvent(
                    productId, 10, "order-1", "ORDER_CANCELLED"
            );

            GenericRecord result = viewUpdater.update(releaseEvent.toGenericRecord());

            assertNotNull(result);
            assertEquals(100, result.getInt32("quantityOnHand"));
            assertEquals(20, result.getInt32("quantityReserved"));
            assertEquals(80, ProductAvailabilityViewUpdater.getAvailableQuantity(result));
        }

        @Test
        @DisplayName("should not go below zero reserved")
        void shouldNotGoBelowZeroReserved() {
            String productId = createProduct(100);

            // Reserve 5
            StockReservedEvent reserveEvent = new StockReservedEvent(productId, 5, "order-1");
            viewUpdater.update(reserveEvent.toGenericRecord());

            // Try to release 10 (more than reserved)
            StockReleasedEvent releaseEvent = new StockReleasedEvent(
                    productId, 10, "order-1", "OVER_RELEASE"
            );

            GenericRecord result = viewUpdater.update(releaseEvent.toGenericRecord());

            assertEquals(0, result.getInt32("quantityReserved"));
        }

        @Test
        @DisplayName("should return null for non-existent product")
        void shouldReturnNullForNonExistentProduct() {
            StockReleasedEvent event = new StockReleasedEvent(
                    "non-existent", 10, "order-1", "TEST"
            );

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertFalse(viewStore.containsKey("non-existent"));
        }
    }

    @Nested
    @DisplayName("getAvailableQuantity helper")
    class GetAvailableQuantityTests {

        @Test
        @DisplayName("should return zero for null record")
        void shouldReturnZeroForNullRecord() {
            assertEquals(0, ProductAvailabilityViewUpdater.getAvailableQuantity(null));
        }

        @Test
        @DisplayName("should calculate correct available quantity")
        void shouldCalculateCorrectAvailableQuantity() {
            String productId = createProduct(100);

            StockReservedEvent event = new StockReservedEvent(productId, 25, "order-1");
            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            // 100 - 25 = 75
            assertEquals(75, ProductAvailabilityViewUpdater.getAvailableQuantity(result));
        }
    }

    /**
     * Helper method to create a product and return its ID.
     */
    private String createProduct(int initialQuantity) {
        String productId = UUID.randomUUID().toString();

        ProductCreatedEvent event = new ProductCreatedEvent(
                productId,
                "SKU-" + productId.substring(0, 8),
                "Test Product",
                new BigDecimal("9.99"),
                initialQuantity
        );

        viewUpdater.update(event.toGenericRecord());
        return productId;
    }
}
