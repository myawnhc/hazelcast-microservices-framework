package com.theyawns.ecommerce.order.domain;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.ecommerce.common.domain.Order;
import com.theyawns.ecommerce.common.domain.OrderLineItem;
import com.theyawns.ecommerce.common.events.CustomerCreatedEvent;
import com.theyawns.ecommerce.common.events.OrderCancelledEvent;
import com.theyawns.ecommerce.common.events.OrderConfirmedEvent;
import com.theyawns.ecommerce.common.events.OrderCreatedEvent;
import com.theyawns.ecommerce.common.events.ProductCreatedEvent;
import com.theyawns.ecommerce.common.events.StockReservedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.math.BigDecimal;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * End-to-end integration test for the complete order flow with all materialized views.
 *
 * <p>This test validates:
 * <ul>
 *   <li>Customer creation updates CustomerCache view</li>
 *   <li>Product creation updates ProductAvailability view</li>
 *   <li>Order creation updates Order, EnrichedOrder, and CustomerOrderSummary views</li>
 *   <li>Order confirmation updates all relevant views</li>
 *   <li>Order cancellation updates all relevant views</li>
 *   <li>Views contain correct denormalized data</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@DisplayName("Order Flow Integration Test")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class OrderFlowIntegrationTest {

    private HazelcastInstance hazelcast;

    // View stores
    private HazelcastViewStore<String> orderViewStore;
    private HazelcastViewStore<String> customerCacheViewStore;
    private HazelcastViewStore<String> productAvailabilityViewStore;
    private HazelcastViewStore<String> enrichedOrderViewStore;
    private HazelcastViewStore<String> customerOrderSummaryViewStore;

    // View updaters
    private OrderViewUpdater orderViewUpdater;
    private CustomerCacheViewUpdater customerCacheUpdater;
    private ProductAvailabilityViewUpdater productAvailabilityUpdater;
    private EnrichedOrderViewUpdater enrichedOrderUpdater;
    private CustomerOrderSummaryViewUpdater customerOrderSummaryUpdater;

    @BeforeAll
    void setUpHazelcast() {
        Config config = new Config();
        config.setClusterName("order-flow-test-" + System.currentTimeMillis());
        hazelcast = Hazelcast.newHazelcastInstance(config);

        // Initialize view stores
        orderViewStore = new HazelcastViewStore<>(hazelcast, "Order");
        customerCacheViewStore = new HazelcastViewStore<>(hazelcast, "CustomerCache");
        productAvailabilityViewStore = new HazelcastViewStore<>(hazelcast, "ProductAvailability");
        enrichedOrderViewStore = new HazelcastViewStore<>(hazelcast, "EnrichedOrder");
        customerOrderSummaryViewStore = new HazelcastViewStore<>(hazelcast, "CustomerOrderSummary");

        // Initialize view updaters
        orderViewUpdater = new OrderViewUpdater(orderViewStore);
        customerCacheUpdater = new CustomerCacheViewUpdater(customerCacheViewStore);
        productAvailabilityUpdater = new ProductAvailabilityViewUpdater(productAvailabilityViewStore);
        enrichedOrderUpdater = new EnrichedOrderViewUpdater(
                enrichedOrderViewStore,
                customerCacheViewStore,
                productAvailabilityViewStore
        );
        customerOrderSummaryUpdater = new CustomerOrderSummaryViewUpdater(customerOrderSummaryViewStore);
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void clearViews() {
        orderViewStore.clear();
        customerCacheViewStore.clear();
        productAvailabilityViewStore.clear();
        enrichedOrderViewStore.clear();
        customerOrderSummaryViewStore.clear();
    }

    @Nested
    @DisplayName("Happy Path - Complete Order Flow")
    class HappyPathTests {

        @Test
        @DisplayName("should process complete order flow from customer creation to order confirmation")
        void shouldProcessCompleteOrderFlow() {
            // Step 1: Create customer
            String customerId = UUID.randomUUID().toString();
            CustomerCreatedEvent customerEvent = new CustomerCreatedEvent(
                    customerId, "alice@example.com", "Alice Smith", "100 Tech Park"
            );
            customerEvent.setPhone("555-TECH");
            customerCacheUpdater.update(customerEvent.toGenericRecord());

            // Verify customer cache
            Optional<GenericRecord> customerCache = customerCacheViewStore.get(customerId);
            assertTrue(customerCache.isPresent());
            assertEquals("Alice Smith", customerCache.get().getString("name"));
            assertEquals("ACTIVE", customerCache.get().getString("status"));

            // Step 2: Create products
            String productId1 = UUID.randomUUID().toString();
            String productId2 = UUID.randomUUID().toString();

            ProductCreatedEvent product1Event = new ProductCreatedEvent(
                    productId1, "LAPTOP-001", "Gaming Laptop", new BigDecimal("999.99"), 50
            );
            ProductCreatedEvent product2Event = new ProductCreatedEvent(
                    productId2, "MOUSE-001", "Wireless Mouse", new BigDecimal("49.99"), 200
            );

            productAvailabilityUpdater.update(product1Event.toGenericRecord());
            productAvailabilityUpdater.update(product2Event.toGenericRecord());

            // Verify product availability
            Optional<GenericRecord> product1 = productAvailabilityViewStore.get(productId1);
            Optional<GenericRecord> product2 = productAvailabilityViewStore.get(productId2);
            assertTrue(product1.isPresent());
            assertTrue(product2.isPresent());
            assertEquals(50, ProductAvailabilityViewUpdater.getAvailableQuantity(product1.get()));
            assertEquals(200, ProductAvailabilityViewUpdater.getAvailableQuantity(product2.get()));

            // Step 3: Create order
            String orderId = UUID.randomUUID().toString();
            List<OrderLineItem> lineItems = Arrays.asList(
                    new OrderLineItem(productId1, "Gaming Laptop", "LAPTOP-001", 1, new BigDecimal("999.99")),
                    new OrderLineItem(productId2, "Wireless Mouse", "MOUSE-001", 2, new BigDecimal("49.99"))
            );

            OrderCreatedEvent orderEvent = new OrderCreatedEvent(
                    orderId, customerId, lineItems, "100 Tech Park"
            );
            orderEvent.setCustomerName("Alice Smith");
            orderEvent.setCustomerEmail("alice@example.com");

            // Update all order-related views
            orderViewUpdater.update(orderEvent.toGenericRecord());
            enrichedOrderUpdater.update(orderEvent.toGenericRecord());
            customerOrderSummaryUpdater.update(orderEvent.toGenericRecord());

            // Verify order view
            Optional<GenericRecord> orderView = orderViewStore.get(orderId);
            assertTrue(orderView.isPresent());
            assertEquals(Order.Status.PENDING.name(), orderView.get().getString("status"));

            // Verify enriched order view
            Optional<GenericRecord> enrichedOrder = enrichedOrderViewStore.get(orderId);
            assertTrue(enrichedOrder.isPresent());
            assertEquals("Alice Smith", enrichedOrder.get().getString("customerName"));
            assertEquals("ACTIVE", enrichedOrder.get().getString("customerStatus"));

            // Verify line items are enriched with availability
            GenericRecord[] enrichedItems = enrichedOrder.get().getArrayOfGenericRecord("lineItems");
            assertEquals(2, enrichedItems.length);
            assertEquals(50, enrichedItems[0].getInt32("availableQuantity"));
            assertEquals(200, enrichedItems[1].getInt32("availableQuantity"));

            // Verify customer order summary
            Optional<GenericRecord> summary = customerOrderSummaryViewStore.get(customerId);
            assertTrue(summary.isPresent());
            assertEquals(1, summary.get().getInt32("totalOrders"));
            assertEquals(1, summary.get().getInt32("pendingOrders"));
            assertEquals(0, summary.get().getInt32("confirmedOrders"));

            // Step 4: Reserve stock (simulating inventory service response)
            StockReservedEvent reserve1 = new StockReservedEvent(productId1, 1, orderId);
            StockReservedEvent reserve2 = new StockReservedEvent(productId2, 2, orderId);
            productAvailabilityUpdater.update(reserve1.toGenericRecord());
            productAvailabilityUpdater.update(reserve2.toGenericRecord());

            // Verify stock is reserved
            product1 = productAvailabilityViewStore.get(productId1);
            product2 = productAvailabilityViewStore.get(productId2);
            assertEquals(49, ProductAvailabilityViewUpdater.getAvailableQuantity(product1.get()));
            assertEquals(198, ProductAvailabilityViewUpdater.getAvailableQuantity(product2.get()));

            // Step 5: Confirm order
            OrderConfirmedEvent confirmEvent = new OrderConfirmedEvent(orderId, "CONF-" + orderId.substring(0, 8));
            orderViewUpdater.update(confirmEvent.toGenericRecord());
            enrichedOrderUpdater.update(confirmEvent.toGenericRecord());

            // Verify order is confirmed
            orderView = orderViewStore.get(orderId);
            enrichedOrder = enrichedOrderViewStore.get(orderId);
            assertEquals(Order.Status.CONFIRMED.name(), orderView.get().getString("status"));
            assertEquals(Order.Status.CONFIRMED.name(), enrichedOrder.get().getString("status"));
            assertNotNull(enrichedOrder.get().getString("confirmationNumber"));
        }

        @Test
        @DisplayName("should handle multiple orders for same customer")
        void shouldHandleMultipleOrdersForSameCustomer() {
            // Create customer
            String customerId = UUID.randomUUID().toString();
            CustomerCreatedEvent customerEvent = new CustomerCreatedEvent(
                    customerId, "bob@example.com", "Bob Jones", "200 Main St"
            );
            customerCacheUpdater.update(customerEvent.toGenericRecord());

            // Create product
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent productEvent = new ProductCreatedEvent(
                    productId, "WIDGET-001", "Super Widget", new BigDecimal("19.99"), 1000
            );
            productAvailabilityUpdater.update(productEvent.toGenericRecord());

            // Create 3 orders
            for (int i = 0; i < 3; i++) {
                String orderId = UUID.randomUUID().toString();
                List<OrderLineItem> lineItems = Arrays.asList(
                        new OrderLineItem(productId, "Super Widget", "WIDGET-001", i + 1, new BigDecimal("19.99"))
                );

                OrderCreatedEvent orderEvent = new OrderCreatedEvent(
                        orderId, customerId, lineItems, "200 Main St"
                );
                orderEvent.setCustomerName("Bob Jones");

                orderViewUpdater.update(orderEvent.toGenericRecord());
                enrichedOrderUpdater.update(orderEvent.toGenericRecord());
                customerOrderSummaryUpdater.update(orderEvent.toGenericRecord());
            }

            // Verify customer order summary
            Optional<GenericRecord> summary = customerOrderSummaryViewStore.get(customerId);
            assertTrue(summary.isPresent());
            assertEquals(3, summary.get().getInt32("totalOrders"));
            assertEquals(3, summary.get().getInt32("pendingOrders"));

            // Total spent should be sum of all orders
            // Order 1: 1 * 19.99 = 19.99 + tax
            // Order 2: 2 * 19.99 = 39.98 + tax
            // Order 3: 3 * 19.99 = 59.97 + tax
            // With 10% tax: (19.99 + 39.98 + 59.97) * 1.1 = 131.934
            String totalSpent = summary.get().getString("totalSpent");
            assertNotNull(totalSpent);
            assertTrue(new BigDecimal(totalSpent).compareTo(BigDecimal.ZERO) > 0);
        }
    }

    @Nested
    @DisplayName("Order Cancellation Flow")
    class CancellationFlowTests {

        @Test
        @DisplayName("should update all views on order cancellation")
        void shouldUpdateAllViewsOnOrderCancellation() {
            // Setup: Create customer, product, and order
            String customerId = UUID.randomUUID().toString();
            String productId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();

            CustomerCreatedEvent customerEvent = new CustomerCreatedEvent(
                    customerId, "cancel@example.com", "Cancel Test", "Cancel Address"
            );
            customerCacheUpdater.update(customerEvent.toGenericRecord());

            ProductCreatedEvent productEvent = new ProductCreatedEvent(
                    productId, "CANCEL-001", "Cancel Product", new BigDecimal("50.00"), 100
            );
            productAvailabilityUpdater.update(productEvent.toGenericRecord());

            List<OrderLineItem> lineItems = Arrays.asList(
                    new OrderLineItem(productId, "Cancel Product", "CANCEL-001", 5, new BigDecimal("50.00"))
            );

            OrderCreatedEvent orderEvent = new OrderCreatedEvent(
                    orderId, customerId, lineItems, "Cancel Address"
            );
            orderEvent.setCustomerName("Cancel Test");

            orderViewUpdater.update(orderEvent.toGenericRecord());
            enrichedOrderUpdater.update(orderEvent.toGenericRecord());
            customerOrderSummaryUpdater.update(orderEvent.toGenericRecord());

            // Reserve stock
            StockReservedEvent reserveEvent = new StockReservedEvent(productId, 5, orderId);
            productAvailabilityUpdater.update(reserveEvent.toGenericRecord());

            // Verify stock is reserved
            Optional<GenericRecord> productBefore = productAvailabilityViewStore.get(productId);
            assertEquals(95, ProductAvailabilityViewUpdater.getAvailableQuantity(productBefore.get()));

            // Cancel order
            OrderCancelledEvent cancelEvent = new OrderCancelledEvent(
                    orderId, "Customer changed mind", "customer"
            );

            orderViewUpdater.update(cancelEvent.toGenericRecord());
            enrichedOrderUpdater.update(cancelEvent.toGenericRecord());

            // Verify order views are updated
            Optional<GenericRecord> orderView = orderViewStore.get(orderId);
            Optional<GenericRecord> enrichedOrder = enrichedOrderViewStore.get(orderId);

            assertEquals(Order.Status.CANCELLED.name(), orderView.get().getString("status"));
            assertEquals(Order.Status.CANCELLED.name(), enrichedOrder.get().getString("status"));
            assertEquals("Customer changed mind", enrichedOrder.get().getString("cancellationReason"));
            assertEquals("customer", enrichedOrder.get().getString("cancelledBy"));
        }
    }

    @Nested
    @DisplayName("View Data Consistency")
    class DataConsistencyTests {

        @Test
        @DisplayName("should maintain consistent data across views")
        void shouldMaintainConsistentDataAcrossViews() {
            // Create customer
            String customerId = UUID.randomUUID().toString();
            CustomerCreatedEvent customerEvent = new CustomerCreatedEvent(
                    customerId, "consistent@example.com", "Consistent User", "123 Consistency Lane"
            );
            customerCacheUpdater.update(customerEvent.toGenericRecord());

            // Create product
            String productId = UUID.randomUUID().toString();
            ProductCreatedEvent productEvent = new ProductCreatedEvent(
                    productId, "CONSIST-001", "Consistent Product", new BigDecimal("75.00"), 150
            );
            productAvailabilityUpdater.update(productEvent.toGenericRecord());

            // Create order
            String orderId = UUID.randomUUID().toString();
            List<OrderLineItem> lineItems = Arrays.asList(
                    new OrderLineItem(productId, "Consistent Product", "CONSIST-001", 3, new BigDecimal("75.00"))
            );

            OrderCreatedEvent orderEvent = new OrderCreatedEvent(
                    orderId, customerId, lineItems, "123 Consistency Lane"
            );
            orderEvent.setCustomerName("Consistent User");
            orderEvent.setCustomerEmail("consistent@example.com");

            orderViewUpdater.update(orderEvent.toGenericRecord());
            enrichedOrderUpdater.update(orderEvent.toGenericRecord());
            customerOrderSummaryUpdater.update(orderEvent.toGenericRecord());

            // Verify data consistency
            Optional<GenericRecord> orderView = orderViewStore.get(orderId);
            Optional<GenericRecord> enrichedOrder = enrichedOrderViewStore.get(orderId);

            // Order ID should match
            assertEquals(orderId, orderView.get().getString("orderId"));
            assertEquals(orderId, enrichedOrder.get().getString("orderId"));

            // Customer ID should match
            assertEquals(customerId, orderView.get().getString("customerId"));
            assertEquals(customerId, enrichedOrder.get().getString("customerId"));

            // Status should match
            assertEquals(orderView.get().getString("status"), enrichedOrder.get().getString("status"));

            // Totals should match
            assertEquals(orderView.get().getString("total"), enrichedOrder.get().getString("total"));
        }

        @Test
        @DisplayName("should handle enrichment when cache is not yet populated")
        void shouldHandleEnrichmentWhenCacheNotPopulated() {
            // Create order WITHOUT first creating customer in cache
            String customerId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();

            List<OrderLineItem> lineItems = Arrays.asList(
                    new OrderLineItem("unknown-product", "Unknown Product", "UNK-001", 1, new BigDecimal("10.00"))
            );

            OrderCreatedEvent orderEvent = new OrderCreatedEvent(
                    orderId, customerId, lineItems, "No Cache Address"
            );
            orderEvent.setCustomerName("Provided Name");
            orderEvent.setCustomerEmail("provided@example.com");

            enrichedOrderUpdater.update(orderEvent.toGenericRecord());

            // Should still create enriched order with event data
            Optional<GenericRecord> enrichedOrder = enrichedOrderViewStore.get(orderId);
            assertTrue(enrichedOrder.isPresent());
            assertEquals("Provided Name", enrichedOrder.get().getString("customerName"));
            assertEquals("provided@example.com", enrichedOrder.get().getString("customerEmail"));
            assertEquals("UNKNOWN", enrichedOrder.get().getString("customerStatus"));

            // Line items should have UNKNOWN status for product
            GenericRecord[] items = enrichedOrder.get().getArrayOfGenericRecord("lineItems");
            assertEquals("UNKNOWN", items[0].getString("productStatus"));
            assertEquals(0, items[0].getInt32("availableQuantity"));
        }
    }
}
