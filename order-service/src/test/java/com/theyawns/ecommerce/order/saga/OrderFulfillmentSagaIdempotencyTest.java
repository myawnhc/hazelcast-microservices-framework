package com.theyawns.ecommerce.order.saga;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.theyawns.framework.saga.HazelcastSagaStateStore;
import com.theyawns.framework.saga.SagaCompensationConfig;
import com.theyawns.framework.saga.SagaState;
import com.theyawns.framework.saga.SagaStateStore;
import com.theyawns.framework.saga.SagaStatus;
import io.micrometer.core.instrument.simple.SimpleMeterRegistry;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.MethodOrderer;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.junit.jupiter.api.TestMethodOrder;

import java.time.Duration;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Integration test for saga step idempotency.
 *
 * <p>Validates that duplicate events do not corrupt saga state:
 * <ul>
 *   <li>Recording a step twice does not double-count progress</li>
 *   <li>Completing an already-completed saga produces a consistent state</li>
 *   <li>The saga maintains correct step count after duplicate processing</li>
 * </ul>
 *
 * <p>Idempotency is critical in choreographed sagas because services may
 * receive duplicate events due to at-least-once delivery guarantees in
 * distributed messaging.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("Order Fulfillment Saga - Idempotency Integration")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@TestMethodOrder(MethodOrderer.OrderAnnotation.class)
class OrderFulfillmentSagaIdempotencyTest {

    private HazelcastInstance hazelcast;
    private SagaStateStore sagaStateStore;

    // Test data
    private final String sagaId = UUID.randomUUID().toString();
    private final String correlationId = UUID.randomUUID().toString();

    @BeforeAll
    void setUp() {
        Config config = new Config();
        config.setClusterName("saga-idempotency-test-" + System.currentTimeMillis());
        hazelcast = Hazelcast.newHazelcastInstance(config);

        sagaStateStore = new HazelcastSagaStateStore(hazelcast, new SimpleMeterRegistry());
    }

    @AfterAll
    void tearDown() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @Test
    @DisplayName("should start saga and complete step 0")
    @org.junit.jupiter.api.Order(1)
    void shouldStartSagaAndCompleteStep0() {
        SagaState state = sagaStateStore.startSaga(
                sagaId,
                SagaCompensationConfig.ORDER_FULFILLMENT_SAGA,
                correlationId,
                4,
                Duration.ofSeconds(60)
        );

        assertNotNull(state);
        assertEquals(SagaStatus.STARTED, state.getStatus());

        // Record step 0 completed
        state = sagaStateStore.recordStepCompleted(
                sagaId,
                SagaCompensationConfig.STEP_ORDER_CREATED,
                SagaCompensationConfig.ORDER_CREATED,
                SagaCompensationConfig.ORDER_SERVICE,
                "evt-order-created-1"
        );

        assertEquals(SagaStatus.IN_PROGRESS, state.getStatus());
        assertEquals(1, state.getCurrentStep());
    }

    @Test
    @DisplayName("should handle duplicate step 0 completion without corruption")
    @org.junit.jupiter.api.Order(2)
    void shouldHandleDuplicateStepCompletion() {
        // Record step 0 completed AGAIN (duplicate event)
        SagaState state = sagaStateStore.recordStepCompleted(
                sagaId,
                SagaCompensationConfig.STEP_ORDER_CREATED,
                SagaCompensationConfig.ORDER_CREATED,
                SagaCompensationConfig.ORDER_SERVICE,
                "evt-order-created-duplicate"
        );

        // State should remain consistent - step 0 is updated (not duplicated),
        // currentStep stays at 1 (step 0 + 1)
        assertEquals(SagaStatus.IN_PROGRESS, state.getStatus());
        assertEquals(1, state.getCurrentStep());

        // Verify the step list has exactly the right number of entries
        // (updateOrAddStep replaces by stepNumber, so no duplicate step records)
        long step0Count = state.getSteps().stream()
                .filter(s -> s.getStepNumber() == SagaCompensationConfig.STEP_ORDER_CREATED)
                .count();
        assertEquals(1, step0Count, "Step 0 should appear exactly once in step records");
    }

    @Test
    @DisplayName("should complete remaining steps after duplicate processing")
    @org.junit.jupiter.api.Order(3)
    void shouldCompleteRemainingStepsAfterDuplicate() {
        // Step 1: Stock Reserved
        SagaState state = sagaStateStore.recordStepCompleted(
                sagaId,
                SagaCompensationConfig.STEP_STOCK_RESERVED,
                SagaCompensationConfig.STOCK_RESERVED,
                SagaCompensationConfig.INVENTORY_SERVICE,
                "evt-stock-reserved"
        );

        assertEquals(SagaStatus.IN_PROGRESS, state.getStatus());
        assertEquals(2, state.getCurrentStep());

        // Step 2: Payment Processed
        state = sagaStateStore.recordStepCompleted(
                sagaId,
                SagaCompensationConfig.STEP_PAYMENT_PROCESSED,
                SagaCompensationConfig.PAYMENT_PROCESSED,
                SagaCompensationConfig.PAYMENT_SERVICE,
                "evt-payment-processed"
        );

        assertEquals(SagaStatus.IN_PROGRESS, state.getStatus());
        assertEquals(3, state.getCurrentStep());

        // Step 3: Order Confirmed (final step)
        state = sagaStateStore.recordStepCompleted(
                sagaId,
                SagaCompensationConfig.STEP_ORDER_CONFIRMED,
                SagaCompensationConfig.ORDER_CONFIRMED,
                SagaCompensationConfig.ORDER_SERVICE,
                "evt-order-confirmed"
        );

        assertEquals(SagaStatus.COMPLETED, state.getStatus());
        assertNotNull(state.getCompletedAt());
    }

    @Test
    @DisplayName("should verify correct final state after duplicate processing")
    @org.junit.jupiter.api.Order(4)
    void shouldVerifyCorrectFinalState() {
        Optional<SagaState> sagaOpt = sagaStateStore.getSagaState(sagaId);
        assertTrue(sagaOpt.isPresent());

        SagaState finalState = sagaOpt.get();
        assertEquals(SagaStatus.COMPLETED, finalState.getStatus());
        assertTrue(finalState.getStatus().isTerminal());
        assertEquals(sagaId, finalState.getSagaId());
        assertEquals(SagaCompensationConfig.ORDER_FULFILLMENT_SAGA, finalState.getSagaType());

        // Should have exactly 4 step records despite duplicate step 0
        assertEquals(4, finalState.getSteps().size(),
                "Should have exactly 4 steps (duplicate replaced, not added)");
    }

    @Test
    @DisplayName("should handle completing an already-completed saga")
    @org.junit.jupiter.api.Order(5)
    void shouldHandleCompletingAlreadyCompletedSaga() {
        // Try to complete the saga again
        SagaState state = sagaStateStore.completeSaga(sagaId, SagaStatus.COMPLETED);

        // Should still be in completed state (idempotent completion)
        assertEquals(SagaStatus.COMPLETED, state.getStatus());
        assertTrue(state.getStatus().isTerminal());
        assertNotNull(state.getCompletedAt());
    }

    @Test
    @DisplayName("should not find completed saga as active")
    @org.junit.jupiter.api.Order(6)
    void shouldNotFindCompletedSagaAsActive() {
        assertTrue(sagaStateStore.findActiveSagas().stream()
                .noneMatch(s -> s.getSagaId().equals(sagaId)));
    }
}
