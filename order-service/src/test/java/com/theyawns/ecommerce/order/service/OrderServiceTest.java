package com.theyawns.ecommerce.order.service;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.ecommerce.common.domain.Order;
import com.theyawns.ecommerce.common.domain.OrderLineItem;
import com.theyawns.ecommerce.common.events.OrderCancelledEvent;
import com.theyawns.ecommerce.common.events.OrderConfirmedEvent;
import com.theyawns.ecommerce.common.events.OrderCreatedEvent;
import com.theyawns.ecommerce.order.domain.OrderViewUpdater;
import com.theyawns.framework.view.HazelcastViewStore;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.math.BigDecimal;
import java.util.Arrays;
import java.util.List;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Unit tests for OrderService.
 * Tests the view updater logic directly without the full pipeline.
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@DisplayName("OrderService - View Updater Logic")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class OrderServiceTest {

    private static final String DOMAIN_NAME = "OrderTest";

    private HazelcastInstance hazelcast;
    private HazelcastViewStore<String> viewStore;
    private OrderViewUpdater viewUpdater;

    @BeforeAll
    void setUpHazelcast() {
        Config config = new Config();
        config.setClusterName("order-service-test-" + System.currentTimeMillis());
        hazelcast = Hazelcast.newHazelcastInstance(config);
        viewStore = new HazelcastViewStore<>(hazelcast, DOMAIN_NAME);
        viewUpdater = new OrderViewUpdater(viewStore);
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void clearView() {
        viewStore.clear();
    }

    @Nested
    @DisplayName("Create order flow")
    class CreateOrderTests {

        @Test
        @DisplayName("should create order view from event")
        void shouldCreateOrderViewFromEvent() {
            String orderId = UUID.randomUUID().toString();
            String customerId = UUID.randomUUID().toString();

            List<OrderLineItem> lineItems = Arrays.asList(
                    new OrderLineItem("prod-1", "Widget A", "SKU-001", 2, new BigDecimal("10.00")),
                    new OrderLineItem("prod-2", "Widget B", "SKU-002", 1, new BigDecimal("25.00"))
            );

            OrderCreatedEvent event = new OrderCreatedEvent(
                    orderId,
                    customerId,
                    lineItems,
                    "123 Main St"
            );
            event.setCustomerName("John Doe");
            event.setCustomerEmail("john@example.com");

            GenericRecord eventRecord = event.toGenericRecord();
            GenericRecord result = viewUpdater.update(eventRecord);

            assertNotNull(result);
            assertEquals(orderId, result.getString("orderId"));
            assertEquals(customerId, result.getString("customerId"));
            assertEquals("John Doe", result.getString("customerName"));
            assertEquals("123 Main St", result.getString("shippingAddress"));
            assertEquals(Order.Status.PENDING.name(), result.getString("status"));

            // Verify stored in view
            Optional<GenericRecord> stored = viewStore.get(orderId);
            assertTrue(stored.isPresent());
            assertEquals(customerId, stored.get().getString("customerId"));
        }

        @Test
        @DisplayName("should calculate totals correctly")
        void shouldCalculateTotalsCorrectly() {
            String orderId = UUID.randomUUID().toString();

            List<OrderLineItem> lineItems = Arrays.asList(
                    new OrderLineItem("prod-1", "Widget A", "SKU-001", 2, new BigDecimal("10.00")),
                    new OrderLineItem("prod-2", "Widget B", "SKU-002", 1, new BigDecimal("25.00"))
            );

            OrderCreatedEvent event = new OrderCreatedEvent(
                    orderId,
                    "cust-1",
                    lineItems,
                    "123 Main St"
            );

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            // Subtotal: (2 * 10) + (1 * 25) = 45
            // Tax: 45 * 0.10 = 4.50
            // Total: 45 + 4.50 = 49.50
            assertEquals("45.00", result.getString("subtotal"));
            assertEquals("4.5000", result.getString("tax"));
            assertEquals("49.5000", result.getString("total"));
        }
    }

    @Nested
    @DisplayName("Confirm order flow")
    class ConfirmOrderTests {

        @Test
        @DisplayName("should confirm order from event")
        void shouldConfirmOrderFromEvent() {
            String orderId = createPendingOrder();

            OrderConfirmedEvent confirmEvent = new OrderConfirmedEvent(orderId, "CONF-12345");
            GenericRecord result = viewUpdater.update(confirmEvent.toGenericRecord());

            assertNotNull(result);
            assertEquals(Order.Status.CONFIRMED.name(), result.getString("status"));
        }

        @Test
        @DisplayName("should preserve order details on confirmation")
        void shouldPreserveOrderDetailsOnConfirmation() {
            String orderId = createPendingOrder();

            Optional<GenericRecord> before = viewStore.get(orderId);
            String originalCustomerId = before.get().getString("customerId");

            OrderConfirmedEvent confirmEvent = new OrderConfirmedEvent(orderId, "CONF-12345");
            GenericRecord result = viewUpdater.update(confirmEvent.toGenericRecord());

            assertEquals(originalCustomerId, result.getString("customerId"));
        }

        @Test
        @DisplayName("should fail to confirm non-existent order")
        void shouldFailToConfirmNonExistentOrder() {
            String orderId = UUID.randomUUID().toString();
            OrderConfirmedEvent confirmEvent = new OrderConfirmedEvent(orderId, "CONF-12345");

            // Should return null for non-existent order
            GenericRecord result = viewUpdater.update(confirmEvent.toGenericRecord());

            // View should not have entry
            Optional<GenericRecord> stored = viewStore.get(orderId);
            assertFalse(stored.isPresent());
        }
    }

    @Nested
    @DisplayName("Cancel order flow")
    class CancelOrderTests {

        @Test
        @DisplayName("should cancel order from event")
        void shouldCancelOrderFromEvent() {
            String orderId = createPendingOrder();

            OrderCancelledEvent cancelEvent = new OrderCancelledEvent(
                    orderId,
                    "Customer request",
                    "customer"
            );
            GenericRecord result = viewUpdater.update(cancelEvent.toGenericRecord());

            assertNotNull(result);
            assertEquals(Order.Status.CANCELLED.name(), result.getString("status"));
        }

        @Test
        @DisplayName("should cancel confirmed order")
        void shouldCancelConfirmedOrder() {
            String orderId = createPendingOrder();

            // First confirm
            OrderConfirmedEvent confirmEvent = new OrderConfirmedEvent(orderId, "CONF-12345");
            viewUpdater.update(confirmEvent.toGenericRecord());

            // Then cancel
            OrderCancelledEvent cancelEvent = new OrderCancelledEvent(
                    orderId,
                    "Out of stock",
                    "system"
            );
            GenericRecord result = viewUpdater.update(cancelEvent.toGenericRecord());

            assertEquals(Order.Status.CANCELLED.name(), result.getString("status"));
        }

        @Test
        @DisplayName("should fail to cancel non-existent order")
        void shouldFailToCancelNonExistentOrder() {
            String orderId = UUID.randomUUID().toString();
            OrderCancelledEvent cancelEvent = new OrderCancelledEvent(
                    orderId,
                    "Test",
                    "system"
            );

            // Should return null for non-existent order
            GenericRecord result = viewUpdater.update(cancelEvent.toGenericRecord());

            // View should not have entry
            Optional<GenericRecord> stored = viewStore.get(orderId);
            assertFalse(stored.isPresent());
        }
    }

    @Nested
    @DisplayName("Get order from view")
    class GetOrderTests {

        @Test
        @DisplayName("should return order from view")
        void shouldReturnOrderFromView() {
            String orderId = createPendingOrder();

            Optional<GenericRecord> result = viewStore.get(orderId);

            assertTrue(result.isPresent());
            assertEquals(Order.Status.PENDING.name(), result.get().getString("status"));
        }

        @Test
        @DisplayName("should return empty for non-existent order")
        void shouldReturnEmptyForNonExistentOrder() {
            Optional<GenericRecord> result = viewStore.get("nonexistent");
            assertFalse(result.isPresent());
        }
    }

    @Nested
    @DisplayName("Order exists check")
    class OrderExistsTests {

        @Test
        @DisplayName("should return true when order exists")
        void shouldReturnTrueWhenOrderExists() {
            String orderId = createPendingOrder();
            assertTrue(viewStore.containsKey(orderId));
        }

        @Test
        @DisplayName("should return false when order does not exist")
        void shouldReturnFalseWhenOrderDoesNotExist() {
            assertFalse(viewStore.containsKey("nonexistent"));
        }
    }

    /**
     * Helper method to create a pending order and return its ID.
     */
    private String createPendingOrder() {
        String orderId = UUID.randomUUID().toString();

        List<OrderLineItem> lineItems = Arrays.asList(
                new OrderLineItem("prod-1", "Test Product", "SKU-001", 1, new BigDecimal("29.99"))
        );

        OrderCreatedEvent event = new OrderCreatedEvent(
                orderId,
                "test-customer",
                lineItems,
                "Test Address"
        );
        event.setCustomerName("Test Customer");

        viewUpdater.update(event.toGenericRecord());
        return orderId;
    }
}
