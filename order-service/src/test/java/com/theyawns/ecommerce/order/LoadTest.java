package com.theyawns.ecommerce.order;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.ecommerce.common.domain.Order;
import com.theyawns.ecommerce.common.domain.OrderLineItem;
import com.theyawns.ecommerce.common.events.OrderCreatedEvent;
import com.theyawns.ecommerce.order.domain.OrderViewUpdater;
import com.theyawns.framework.view.HazelcastViewStore;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Tag;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.math.BigDecimal;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.UUID;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;
import java.util.concurrent.atomic.AtomicInteger;
import java.util.concurrent.atomic.AtomicLong;

import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Load tests for Order Service.
 *
 * <p>Verifies that the system can handle 100+ transactions per second.
 *
 * <p>Run with: mvn test -Dtest=LoadTest -pl order-service
 *
 * @author Generated by Claude Code
 * @since 1.0
 */
@DisplayName("Load Test - Order Processing Throughput")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
@Tag("load")
class LoadTest {

    private static final Logger logger = LoggerFactory.getLogger(LoadTest.class);

    private static final int TARGET_TPS = 100;
    private static final int TEST_DURATION_SECONDS = 10;
    private static final int THREAD_COUNT = 10;

    private HazelcastInstance hazelcast;
    private HazelcastViewStore<String> viewStore;
    private OrderViewUpdater viewUpdater;

    @BeforeAll
    void setUpHazelcast() {
        Config config = new Config();
        config.setClusterName("load-test-" + System.currentTimeMillis());
        config.getJetConfig().setEnabled(true);
        hazelcast = Hazelcast.newHazelcastInstance(config);
        viewStore = new HazelcastViewStore<>(hazelcast, "LoadTest_Orders");
        viewUpdater = new OrderViewUpdater(viewStore);
        logger.info("Load test setup complete");
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @Test
    @DisplayName("should handle 100+ order creations per second")
    void shouldHandle100OrdersPerSecond() throws InterruptedException {
        logger.info("Starting load test: target {} TPS for {} seconds with {} threads",
                TARGET_TPS, TEST_DURATION_SECONDS, THREAD_COUNT);

        AtomicInteger successCount = new AtomicInteger(0);
        AtomicInteger errorCount = new AtomicInteger(0);
        AtomicLong totalLatencyNanos = new AtomicLong(0);
        List<Long> latencies = Collections.synchronizedList(new ArrayList<>());

        ExecutorService executor = Executors.newFixedThreadPool(THREAD_COUNT);
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch completionLatch = new CountDownLatch(THREAD_COUNT);

        long testEndTime = System.currentTimeMillis() + (TEST_DURATION_SECONDS * 1000L);

        // Start worker threads
        for (int i = 0; i < THREAD_COUNT; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    startLatch.await();
                    while (System.currentTimeMillis() < testEndTime) {
                        long startNanos = System.nanoTime();
                        try {
                            processOrder(threadId);
                            long latencyNanos = System.nanoTime() - startNanos;
                            successCount.incrementAndGet();
                            totalLatencyNanos.addAndGet(latencyNanos);
                            latencies.add(latencyNanos);
                        } catch (Exception e) {
                            errorCount.incrementAndGet();
                            logger.warn("Error processing order: {}", e.getMessage());
                        }
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    completionLatch.countDown();
                }
            });
        }

        // Start the test
        long startTime = System.currentTimeMillis();
        startLatch.countDown();

        // Wait for completion
        completionLatch.await(TEST_DURATION_SECONDS + 5, TimeUnit.SECONDS);
        executor.shutdown();

        long actualDuration = System.currentTimeMillis() - startTime;
        double durationSeconds = actualDuration / 1000.0;
        int totalOperations = successCount.get();
        double tps = totalOperations / durationSeconds;
        double avgLatencyMs = totalOperations > 0 ?
                (totalLatencyNanos.get() / totalOperations) / 1_000_000.0 : 0;

        // Calculate percentiles
        List<Long> sortedLatencies = new ArrayList<>(latencies);
        Collections.sort(sortedLatencies);
        long p50 = sortedLatencies.isEmpty() ? 0 : sortedLatencies.get(sortedLatencies.size() / 2);
        long p95 = sortedLatencies.isEmpty() ? 0 : sortedLatencies.get((int) (sortedLatencies.size() * 0.95));
        long p99 = sortedLatencies.isEmpty() ? 0 : sortedLatencies.get((int) (sortedLatencies.size() * 0.99));

        // Print results
        logger.info("========================================");
        logger.info("Load Test Results");
        logger.info("========================================");
        logger.info("Duration: {} seconds", String.format("%.2f", durationSeconds));
        logger.info("Total Operations: {}", totalOperations);
        logger.info("Successful: {}", successCount.get());
        logger.info("Errors: {}", errorCount.get());
        logger.info("Throughput: {} TPS", String.format("%.2f", tps));
        logger.info("Average Latency: {} ms", String.format("%.2f", avgLatencyMs));
        logger.info("P50 Latency: {} ms", String.format("%.2f", p50 / 1_000_000.0));
        logger.info("P95 Latency: {} ms", String.format("%.2f", p95 / 1_000_000.0));
        logger.info("P99 Latency: {} ms", String.format("%.2f", p99 / 1_000_000.0));
        logger.info("========================================");

        // Assert we meet the target TPS
        assertTrue(tps >= TARGET_TPS,
                String.format("Expected at least %d TPS but got %.2f TPS", TARGET_TPS, tps));
    }

    @Test
    @DisplayName("should maintain low latency under load")
    void shouldMaintainLowLatency() throws InterruptedException {
        logger.info("Starting latency test: processing 1000 orders");

        List<Long> latencies = new ArrayList<>();
        int operationCount = 1000;

        for (int i = 0; i < operationCount; i++) {
            long startNanos = System.nanoTime();
            processOrder(0);
            long latencyNanos = System.nanoTime() - startNanos;
            latencies.add(latencyNanos);
        }

        Collections.sort(latencies);
        long p50 = latencies.get(latencies.size() / 2);
        long p95 = latencies.get((int) (latencies.size() * 0.95));
        long p99 = latencies.get((int) (latencies.size() * 0.99));
        double avgMs = latencies.stream().mapToLong(l -> l).average().orElse(0) / 1_000_000.0;

        logger.info("Latency results for {} operations:", operationCount);
        logger.info("  Average: {} ms", String.format("%.2f", avgMs));
        logger.info("  P50: {} ms", String.format("%.2f", p50 / 1_000_000.0));
        logger.info("  P95: {} ms", String.format("%.2f", p95 / 1_000_000.0));
        logger.info("  P99: {} ms", String.format("%.2f", p99 / 1_000_000.0));

        // Assert reasonable latency (under 100ms for P99)
        double p99Ms = p99 / 1_000_000.0;
        assertTrue(p99Ms < 100, String.format("P99 latency %.2f ms exceeds 100ms threshold", p99Ms));
    }

    @Test
    @DisplayName("should scale with concurrent threads")
    void shouldScaleWithConcurrentThreads() throws InterruptedException {
        int[] threadCounts = {1, 2, 4, 8};

        logger.info("Testing scalability across thread counts...");

        for (int threads : threadCounts) {
            viewStore.clear();
            double tps = measureThroughput(threads, 5);
            logger.info("  {} threads: {} TPS", threads, String.format("%.2f", tps));
        }

        // Verify 8 threads is faster than 1 thread
        viewStore.clear();
        double singleThreadTps = measureThroughput(1, 5);
        viewStore.clear();
        double multiThreadTps = measureThroughput(8, 5);

        logger.info("Scalability: {} TPS (1 thread) vs {} TPS (8 threads)",
                String.format("%.2f", singleThreadTps), String.format("%.2f", multiThreadTps));

        assertTrue(multiThreadTps > singleThreadTps,
                "Multi-threaded throughput should exceed single-threaded");
    }

    private double measureThroughput(int threads, int durationSeconds) throws InterruptedException {
        AtomicInteger count = new AtomicInteger(0);
        ExecutorService executor = Executors.newFixedThreadPool(threads);
        CountDownLatch startLatch = new CountDownLatch(1);
        CountDownLatch completionLatch = new CountDownLatch(threads);

        long endTime = System.currentTimeMillis() + (durationSeconds * 1000L);

        for (int i = 0; i < threads; i++) {
            final int threadId = i;
            executor.submit(() -> {
                try {
                    startLatch.await();
                    while (System.currentTimeMillis() < endTime) {
                        processOrder(threadId);
                        count.incrementAndGet();
                    }
                } catch (InterruptedException e) {
                    Thread.currentThread().interrupt();
                } finally {
                    completionLatch.countDown();
                }
            });
        }

        long startTime = System.currentTimeMillis();
        startLatch.countDown();
        completionLatch.await(durationSeconds + 2, TimeUnit.SECONDS);
        executor.shutdown();

        long actualDuration = System.currentTimeMillis() - startTime;
        return count.get() / (actualDuration / 1000.0);
    }

    private void processOrder(int threadId) {
        String orderId = UUID.randomUUID().toString();
        String customerId = "cust-" + threadId + "-" + (System.nanoTime() % 1000);

        List<OrderLineItem> items = List.of(
                new OrderLineItem("prod-1", "Widget", "SKU-001", 2, new BigDecimal("10.00")),
                new OrderLineItem("prod-2", "Gadget", "SKU-002", 1, new BigDecimal("25.00"))
        );

        OrderCreatedEvent event = new OrderCreatedEvent(orderId, customerId, items, "123 Main St");
        GenericRecord eventRecord = event.toGenericRecord();

        // Process through view updater (simulates the Jet pipeline processing)
        viewUpdater.update(eventRecord);
    }
}
