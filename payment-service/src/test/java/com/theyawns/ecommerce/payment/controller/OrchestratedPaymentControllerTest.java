package com.theyawns.ecommerce.payment.controller;

import com.theyawns.ecommerce.common.domain.Payment;
import com.theyawns.ecommerce.payment.exception.GlobalExceptionHandler;
import com.theyawns.ecommerce.payment.exception.InvalidPaymentStateException;
import com.theyawns.ecommerce.payment.service.PaymentOperations;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import java.math.BigDecimal;
import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.asyncDispatch;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.request;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Tests for {@link OrchestratedPaymentController}.
 *
 * @author Generated by Claude Code
 * @since 3.0
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("OrchestratedPaymentController - REST endpoints")
class OrchestratedPaymentControllerTest {

    private MockMvc mockMvc;

    @Mock
    private PaymentOperations paymentService;

    @BeforeEach
    void setUp() {
        OrchestratedPaymentController controller =
                new OrchestratedPaymentController(paymentService);
        mockMvc = MockMvcBuilders.standaloneSetup(controller)
                .setControllerAdvice(new GlobalExceptionHandler())
                .build();
    }

    @Nested
    @DisplayName("POST /api/saga/payment/process")
    class ProcessPayment {

        @Test
        @DisplayName("should return success response on successful payment")
        void shouldReturnSuccessOnPayment() throws Exception {
            Payment payment = createTestPayment(Payment.PaymentStatus.CAPTURED);
            when(paymentService.processPaymentOrchestrated(
                    eq("order-1"), eq("cust-1"), eq("99.99"), eq("USD"), eq("CREDIT_CARD")))
                    .thenReturn(CompletableFuture.completedFuture(payment));

            MvcResult mvcResult = mockMvc.perform(post("/api/saga/payment/process")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "orderId": "order-1",
                                        "customerId": "cust-1",
                                        "amount": "99.99",
                                        "currency": "USD",
                                        "method": "CREDIT_CARD"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.success").value(true))
                    .andExpect(jsonPath("$.data.paymentId").value("pay-1"));

            verify(paymentService).processPaymentOrchestrated(
                    "order-1", "cust-1", "99.99", "USD", "CREDIT_CARD");
        }

        @Test
        @DisplayName("should return failure response on declined payment")
        void shouldReturnFailureOnDeclinedPayment() throws Exception {
            Payment payment = createTestPayment(Payment.PaymentStatus.FAILED);
            payment.setFailureReason("Payment declined by processor");
            when(paymentService.processPaymentOrchestrated(
                    eq("order-1"), eq("cust-1"), eq("99.99"), eq("USD"), eq("CREDIT_CARD")))
                    .thenReturn(CompletableFuture.completedFuture(payment));

            MvcResult mvcResult = mockMvc.perform(post("/api/saga/payment/process")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "orderId": "order-1",
                                        "customerId": "cust-1",
                                        "amount": "99.99",
                                        "currency": "USD",
                                        "method": "CREDIT_CARD"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.success").value(false))
                    .andExpect(jsonPath("$.errorMessage").value("Payment declined by processor"));
        }
    }

    @Nested
    @DisplayName("POST /api/saga/payment/refund")
    class RefundPayment {

        @Test
        @DisplayName("should return success response on successful refund")
        void shouldReturnSuccessOnRefund() throws Exception {
            Payment payment = createTestPayment(Payment.PaymentStatus.REFUNDED);
            when(paymentService.refundPaymentOrchestrated(eq("pay-1"), eq("compensation")))
                    .thenReturn(CompletableFuture.completedFuture(payment));

            MvcResult mvcResult = mockMvc.perform(post("/api/saga/payment/refund")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "paymentId": "pay-1",
                                        "reason": "compensation"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.success").value(true))
                    .andExpect(jsonPath("$.data.paymentId").value("pay-1"));

            verify(paymentService).refundPaymentOrchestrated("pay-1", "compensation");
        }

        @Test
        @DisplayName("should return failure response on invalid state for refund")
        void shouldReturnFailureOnInvalidState() throws Exception {
            when(paymentService.refundPaymentOrchestrated(eq("pay-1"), eq("compensation")))
                    .thenThrow(new InvalidPaymentStateException("pay-1", "PENDING", "refund"));

            MvcResult mvcResult = mockMvc.perform(post("/api/saga/payment/refund")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "paymentId": "pay-1",
                                        "reason": "compensation"
                                    }
                                    """))
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.success").value(false));
        }
    }

    private Payment createTestPayment(Payment.PaymentStatus status) {
        Payment payment = new Payment();
        payment.setPaymentId("pay-1");
        payment.setOrderId("order-1");
        payment.setCustomerId("cust-1");
        payment.setAmount(new BigDecimal("99.99"));
        payment.setCurrency("USD");
        payment.setMethod(Payment.PaymentMethod.CREDIT_CARD);
        payment.setStatus(status);
        payment.setTransactionId("TXN-123");
        return payment;
    }
}
