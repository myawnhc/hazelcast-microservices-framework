package com.theyawns.ecommerce.payment.controller;

import com.theyawns.ecommerce.common.domain.Payment;
import com.theyawns.ecommerce.common.dto.PaymentDTO;
import com.theyawns.ecommerce.payment.exception.GlobalExceptionHandler;
import com.theyawns.ecommerce.payment.exception.InvalidPaymentStateException;
import com.theyawns.ecommerce.payment.exception.PaymentNotFoundException;
import com.theyawns.ecommerce.payment.service.PaymentOperations;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;
import org.springframework.http.MediaType;
import org.springframework.test.web.servlet.MockMvc;
import org.springframework.test.web.servlet.MvcResult;
import org.springframework.test.web.servlet.setup.MockMvcBuilders;

import java.math.BigDecimal;
import java.time.Instant;
import java.util.Optional;
import java.util.concurrent.CompletableFuture;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.when;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.asyncDispatch;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.request;
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;

/**
 * Integration tests for PaymentController REST endpoints.
 * Uses standalone MockMvc setup with interface mocking.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@ExtendWith(MockitoExtension.class)
@DisplayName("PaymentController Integration Tests")
class PaymentControllerIntegrationTest {

    private MockMvc mockMvc;

    @Mock
    private PaymentOperations paymentService;

    @InjectMocks
    private PaymentController paymentController;

    @BeforeEach
    void setUp() {
        mockMvc = MockMvcBuilders.standaloneSetup(paymentController)
                .setControllerAdvice(new GlobalExceptionHandler())
                .build();
    }

    @Nested
    @DisplayName("POST /api/payments")
    class ProcessPaymentEndpointTests {

        @Test
        @DisplayName("should process payment and return 201")
        void shouldProcessPaymentAndReturn201() throws Exception {
            Payment payment = createTestPayment("pay-123", "order-123",
                    Payment.PaymentStatus.CAPTURED);

            when(paymentService.processPayment(any(PaymentDTO.class)))
                    .thenReturn(CompletableFuture.completedFuture(payment));

            MvcResult mvcResult = mockMvc.perform(post("/api/payments")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "orderId": "order-123",
                                        "customerId": "cust-123",
                                        "amount": 99.99,
                                        "currency": "USD",
                                        "method": "CREDIT_CARD"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isCreated())
                    .andExpect(jsonPath("$.paymentId").value("pay-123"))
                    .andExpect(jsonPath("$.orderId").value("order-123"))
                    .andExpect(jsonPath("$.status").value("CAPTURED"));
        }

        @Test
        @DisplayName("should return 400 for invalid payment data")
        void shouldReturn400ForInvalidPaymentData() throws Exception {
            mockMvc.perform(post("/api/payments")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "orderId": "",
                                        "customerId": "",
                                        "amount": 0,
                                        "currency": ""
                                    }
                                    """))
                    .andExpect(status().isBadRequest());
        }

        @Test
        @DisplayName("should process failed payment and return 201")
        void shouldProcessFailedPaymentAndReturn201() throws Exception {
            Payment payment = createTestPayment("pay-456", "order-456",
                    Payment.PaymentStatus.FAILED);
            payment.setFailureReason("Insufficient funds");

            when(paymentService.processPayment(any(PaymentDTO.class)))
                    .thenReturn(CompletableFuture.completedFuture(payment));

            MvcResult mvcResult = mockMvc.perform(post("/api/payments")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "orderId": "order-456",
                                        "customerId": "cust-456",
                                        "amount": 15000.00,
                                        "currency": "USD",
                                        "method": "CREDIT_CARD"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isCreated())
                    .andExpect(jsonPath("$.paymentId").value("pay-456"))
                    .andExpect(jsonPath("$.status").value("FAILED"));
        }
    }

    @Nested
    @DisplayName("GET /api/payments/{paymentId}")
    class GetPaymentEndpointTests {

        @Test
        @DisplayName("should return payment when found")
        void shouldReturnPaymentWhenFound() throws Exception {
            Payment payment = createTestPayment("pay-123", "order-123",
                    Payment.PaymentStatus.CAPTURED);

            when(paymentService.getPayment("pay-123")).thenReturn(Optional.of(payment));

            mockMvc.perform(get("/api/payments/pay-123"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.paymentId").value("pay-123"))
                    .andExpect(jsonPath("$.orderId").value("order-123"))
                    .andExpect(jsonPath("$.status").value("CAPTURED"));
        }

        @Test
        @DisplayName("should return 404 when payment not found")
        void shouldReturn404WhenPaymentNotFound() throws Exception {
            when(paymentService.getPayment("nonexistent")).thenReturn(Optional.empty());

            mockMvc.perform(get("/api/payments/nonexistent"))
                    .andExpect(status().isNotFound());
        }
    }

    @Nested
    @DisplayName("GET /api/payments/order/{orderId}")
    class GetPaymentByOrderEndpointTests {

        @Test
        @DisplayName("should return payment for order")
        void shouldReturnPaymentForOrder() throws Exception {
            Payment payment = createTestPayment("pay-123", "order-123",
                    Payment.PaymentStatus.CAPTURED);

            when(paymentService.getPaymentByOrder("order-123")).thenReturn(Optional.of(payment));

            mockMvc.perform(get("/api/payments/order/order-123"))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.paymentId").value("pay-123"))
                    .andExpect(jsonPath("$.orderId").value("order-123"));
        }

        @Test
        @DisplayName("should return 404 when no payment for order")
        void shouldReturn404WhenNoPaymentForOrder() throws Exception {
            when(paymentService.getPaymentByOrder("no-order")).thenReturn(Optional.empty());

            mockMvc.perform(get("/api/payments/order/no-order"))
                    .andExpect(status().isNotFound());
        }
    }

    @Nested
    @DisplayName("POST /api/payments/{paymentId}/refund")
    class RefundPaymentEndpointTests {

        @Test
        @DisplayName("should refund payment and return 200")
        void shouldRefundPaymentAndReturn200() throws Exception {
            Payment refundedPayment = createTestPayment("pay-123", "order-123",
                    Payment.PaymentStatus.REFUNDED);

            when(paymentService.refundPayment(eq("pay-123"), eq("Customer request")))
                    .thenReturn(CompletableFuture.completedFuture(refundedPayment));

            MvcResult mvcResult = mockMvc.perform(post("/api/payments/pay-123/refund")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "reason": "Customer request"
                                    }
                                    """))
                    .andExpect(request().asyncStarted())
                    .andReturn();

            mockMvc.perform(asyncDispatch(mvcResult))
                    .andExpect(status().isOk())
                    .andExpect(jsonPath("$.paymentId").value("pay-123"))
                    .andExpect(jsonPath("$.status").value("REFUNDED"));
        }

        @Test
        @DisplayName("should return 404 when payment not found for refund")
        void shouldReturn404WhenPaymentNotFoundForRefund() throws Exception {
            when(paymentService.refundPayment(eq("nonexistent"), anyString()))
                    .thenThrow(new PaymentNotFoundException("nonexistent"));

            mockMvc.perform(post("/api/payments/nonexistent/refund")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "reason": "Test refund"
                                    }
                                    """))
                    .andExpect(status().isNotFound())
                    .andExpect(jsonPath("$.errorCode").value("PAYMENT_NOT_FOUND"));
        }

        @Test
        @DisplayName("should return 409 when payment cannot be refunded")
        void shouldReturn409WhenPaymentCannotBeRefunded() throws Exception {
            when(paymentService.refundPayment(eq("pay-123"), anyString()))
                    .thenThrow(new InvalidPaymentStateException("pay-123", "FAILED", "refund"));

            mockMvc.perform(post("/api/payments/pay-123/refund")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "reason": "Test refund"
                                    }
                                    """))
                    .andExpect(status().isConflict())
                    .andExpect(jsonPath("$.errorCode").value("INVALID_PAYMENT_STATE"));
        }

        @Test
        @DisplayName("should return 400 for invalid refund request")
        void shouldReturn400ForInvalidRefundRequest() throws Exception {
            mockMvc.perform(post("/api/payments/pay-123/refund")
                            .contentType(MediaType.APPLICATION_JSON)
                            .content("""
                                    {
                                        "reason": ""
                                    }
                                    """))
                    .andExpect(status().isBadRequest());
        }
    }

    /**
     * Helper method to create a test payment.
     */
    private Payment createTestPayment(String paymentId, String orderId,
                                       Payment.PaymentStatus status) {
        Payment payment = new Payment(
                paymentId, orderId, "cust-123",
                new BigDecimal("99.99"), "USD",
                Payment.PaymentMethod.CREDIT_CARD
        );
        payment.setStatus(status);
        payment.setTransactionId("TXN-" + paymentId);
        payment.setProcessedAt(Instant.now());
        return payment;
    }
}
