package com.theyawns.ecommerce.payment.service;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.ecommerce.common.domain.Payment;
import com.theyawns.ecommerce.common.events.PaymentFailedEvent;
import com.theyawns.ecommerce.common.events.PaymentProcessedEvent;
import com.theyawns.ecommerce.common.events.PaymentRefundedEvent;
import com.theyawns.ecommerce.payment.domain.PaymentViewUpdater;
import com.theyawns.framework.view.HazelcastViewStore;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.math.BigDecimal;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Unit tests for PaymentService.
 * Tests the view updater logic directly without the full pipeline.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("PaymentService - View Updater Logic")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class PaymentServiceTest {

    private static final String DOMAIN_NAME = "PaymentTest";

    private HazelcastInstance hazelcast;
    private HazelcastViewStore<String> viewStore;
    private PaymentViewUpdater viewUpdater;

    @BeforeAll
    void setUpHazelcast() {
        Config config = new Config();
        config.setClusterName("payment-service-test-" + System.currentTimeMillis());
        hazelcast = Hazelcast.newHazelcastInstance(config);
        viewStore = new HazelcastViewStore<>(hazelcast, DOMAIN_NAME);
        viewUpdater = new PaymentViewUpdater(viewStore);
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void clearView() {
        viewStore.clear();
    }

    @Nested
    @DisplayName("Process payment flow")
    class ProcessPaymentTests {

        @Test
        @DisplayName("should create captured payment view from event")
        void shouldCreateCapturedPaymentViewFromEvent() {
            String paymentId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();
            String customerId = UUID.randomUUID().toString();

            PaymentProcessedEvent event = new PaymentProcessedEvent(
                    paymentId, orderId, customerId,
                    new BigDecimal("99.99"), "USD",
                    "TXN-123456", "CREDIT_CARD"
            );

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertNotNull(result);
            assertEquals(paymentId, result.getString("paymentId"));
            assertEquals(orderId, result.getString("orderId"));
            assertEquals(customerId, result.getString("customerId"));
            assertEquals("99.99", result.getString("amount"));
            assertEquals("USD", result.getString("currency"));
            assertEquals("CREDIT_CARD", result.getString("method"));
            assertEquals(Payment.PaymentStatus.CAPTURED.name(), result.getString("status"));
            assertEquals("TXN-123456", result.getString("transactionId"));
            assertNull(result.getString("failureReason"));
        }

        @Test
        @DisplayName("should store captured payment in view")
        void shouldStoreCapturedPaymentInView() {
            String paymentId = UUID.randomUUID().toString();

            PaymentProcessedEvent event = new PaymentProcessedEvent(
                    paymentId, "order-1", "cust-1",
                    new BigDecimal("50.00"), "USD",
                    "TXN-789", "DEBIT_CARD"
            );

            viewUpdater.update(event.toGenericRecord());

            Optional<GenericRecord> stored = viewStore.get(paymentId);
            assertTrue(stored.isPresent());
            assertEquals(Payment.PaymentStatus.CAPTURED.name(), stored.get().getString("status"));
        }

        @Test
        @DisplayName("should set timestamps on processed payment")
        void shouldSetTimestampsOnProcessedPayment() {
            String paymentId = UUID.randomUUID().toString();

            PaymentProcessedEvent event = new PaymentProcessedEvent(
                    paymentId, "order-1", "cust-1",
                    new BigDecimal("25.00"), "USD",
                    "TXN-456", "CREDIT_CARD"
            );

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertTrue(result.getInt64("processedAt") > 0);
            assertTrue(result.getInt64("createdAt") > 0);
            assertTrue(result.getInt64("updatedAt") > 0);
        }
    }

    @Nested
    @DisplayName("Failed payment flow")
    class FailedPaymentTests {

        @Test
        @DisplayName("should create failed payment view from event")
        void shouldCreateFailedPaymentViewFromEvent() {
            String paymentId = UUID.randomUUID().toString();

            PaymentFailedEvent event = new PaymentFailedEvent(
                    paymentId, "order-1", "cust-1",
                    new BigDecimal("15000.00"), "USD",
                    "Insufficient funds", "CREDIT_CARD"
            );

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertNotNull(result);
            assertEquals(paymentId, result.getString("paymentId"));
            assertEquals(Payment.PaymentStatus.FAILED.name(), result.getString("status"));
            assertEquals("Insufficient funds", result.getString("failureReason"));
        }

        @Test
        @DisplayName("should store failed payment in view")
        void shouldStoreFailedPaymentInView() {
            String paymentId = UUID.randomUUID().toString();

            PaymentFailedEvent event = new PaymentFailedEvent(
                    paymentId, "order-1", "cust-1",
                    new BigDecimal("999.99"), "USD",
                    "Card declined", "DEBIT_CARD"
            );

            viewUpdater.update(event.toGenericRecord());

            Optional<GenericRecord> stored = viewStore.get(paymentId);
            assertTrue(stored.isPresent());
            assertEquals(Payment.PaymentStatus.FAILED.name(), stored.get().getString("status"));
        }
    }

    @Nested
    @DisplayName("Refund payment flow")
    class RefundPaymentTests {

        @Test
        @DisplayName("should refund captured payment")
        void shouldRefundCapturedPayment() {
            String paymentId = createCapturedPayment();

            PaymentRefundedEvent refundEvent = new PaymentRefundedEvent(
                    paymentId, "order-1",
                    "99.99", "Customer requested refund",
                    "REF-123456"
            );

            GenericRecord result = viewUpdater.update(refundEvent.toGenericRecord());

            assertNotNull(result);
            assertEquals(Payment.PaymentStatus.REFUNDED.name(), result.getString("status"));
        }

        @Test
        @DisplayName("should preserve payment details on refund")
        void shouldPreservePaymentDetailsOnRefund() {
            String paymentId = createCapturedPayment();

            Optional<GenericRecord> before = viewStore.get(paymentId);
            String originalOrderId = before.get().getString("orderId");
            String originalAmount = before.get().getString("amount");
            String originalTransactionId = before.get().getString("transactionId");

            PaymentRefundedEvent refundEvent = new PaymentRefundedEvent(
                    paymentId, "order-1",
                    "99.99", "Return",
                    "REF-789"
            );

            GenericRecord result = viewUpdater.update(refundEvent.toGenericRecord());

            assertEquals(originalOrderId, result.getString("orderId"));
            assertEquals(originalAmount, result.getString("amount"));
            assertEquals(originalTransactionId, result.getString("transactionId"));
        }

        @Test
        @DisplayName("should update timestamp on refund")
        void shouldUpdateTimestampOnRefund() {
            String paymentId = createCapturedPayment();

            Optional<GenericRecord> before = viewStore.get(paymentId);
            long originalUpdatedAt = before.get().getInt64("updatedAt");

            // Small delay to ensure timestamp difference
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }

            PaymentRefundedEvent refundEvent = new PaymentRefundedEvent(
                    paymentId, "order-1",
                    "99.99", "Refund",
                    "REF-999"
            );

            GenericRecord result = viewUpdater.update(refundEvent.toGenericRecord());

            assertTrue(result.getInt64("updatedAt") >= originalUpdatedAt);
        }

        @Test
        @DisplayName("should return null when refunding non-existent payment")
        void shouldReturnNullWhenRefundingNonExistentPayment() {
            String paymentId = UUID.randomUUID().toString();

            PaymentRefundedEvent refundEvent = new PaymentRefundedEvent(
                    paymentId, "order-1",
                    "50.00", "Error",
                    "REF-000"
            );

            GenericRecord result = viewUpdater.update(refundEvent.toGenericRecord());

            assertNull(result);
        }
    }

    @Nested
    @DisplayName("Get payment from view")
    class GetPaymentTests {

        @Test
        @DisplayName("should return payment from view")
        void shouldReturnPaymentFromView() {
            String paymentId = createCapturedPayment();

            Optional<GenericRecord> result = viewStore.get(paymentId);

            assertTrue(result.isPresent());
            assertEquals(Payment.PaymentStatus.CAPTURED.name(), result.get().getString("status"));
        }

        @Test
        @DisplayName("should return empty for non-existent payment")
        void shouldReturnEmptyForNonExistentPayment() {
            Optional<GenericRecord> result = viewStore.get("nonexistent");
            assertFalse(result.isPresent());
        }
    }

    @Nested
    @DisplayName("Payment exists check")
    class PaymentExistsTests {

        @Test
        @DisplayName("should return true when payment exists")
        void shouldReturnTrueWhenPaymentExists() {
            String paymentId = createCapturedPayment();
            assertTrue(viewStore.containsKey(paymentId));
        }

        @Test
        @DisplayName("should return false when payment does not exist")
        void shouldReturnFalseWhenPaymentDoesNotExist() {
            assertFalse(viewStore.containsKey("nonexistent"));
        }
    }

    @Nested
    @DisplayName("Domain object conversion")
    class DomainObjectConversionTests {

        @Test
        @DisplayName("should convert GenericRecord to Payment domain object")
        void shouldConvertGenericRecordToPayment() {
            String paymentId = createCapturedPayment();

            Optional<GenericRecord> record = viewStore.get(paymentId);
            assertTrue(record.isPresent());

            Payment payment = Payment.fromGenericRecord(record.get());

            assertNotNull(payment);
            assertEquals(paymentId, payment.getPaymentId());
            assertEquals("order-1", payment.getOrderId());
            assertEquals("cust-1", payment.getCustomerId());
            assertEquals(new BigDecimal("99.99"), payment.getAmount());
            assertEquals("USD", payment.getCurrency());
            assertEquals(Payment.PaymentMethod.CREDIT_CARD, payment.getMethod());
            assertEquals(Payment.PaymentStatus.CAPTURED, payment.getStatus());
            assertTrue(payment.canRefund());
        }

        @Test
        @DisplayName("should convert Payment to DTO")
        void shouldConvertPaymentToDTO() {
            String paymentId = createCapturedPayment();

            Optional<GenericRecord> record = viewStore.get(paymentId);
            Payment payment = Payment.fromGenericRecord(record.get());

            var dto = payment.toDTO();

            assertEquals(paymentId, dto.getPaymentId());
            assertEquals("order-1", dto.getOrderId());
            assertEquals(Payment.PaymentStatus.CAPTURED.name(), dto.getStatus());
        }
    }

    /**
     * Helper method to create a captured payment and return its ID.
     */
    private String createCapturedPayment() {
        String paymentId = UUID.randomUUID().toString();

        PaymentProcessedEvent event = new PaymentProcessedEvent(
                paymentId, "order-1", "cust-1",
                new BigDecimal("99.99"), "USD",
                "TXN-" + paymentId.substring(0, 8), "CREDIT_CARD"
        );

        viewUpdater.update(event.toGenericRecord());
        return paymentId;
    }
}
