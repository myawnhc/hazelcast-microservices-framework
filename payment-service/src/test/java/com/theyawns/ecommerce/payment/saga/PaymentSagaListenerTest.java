package com.theyawns.ecommerce.payment.saga;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.hazelcast.topic.Message;
import com.theyawns.ecommerce.common.domain.Payment;
import com.theyawns.ecommerce.payment.service.PaymentOperations;
import com.theyawns.framework.resilience.ResilienceException;
import com.theyawns.framework.resilience.ResilientOperations;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

import java.math.BigDecimal;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.function.Supplier;

import static org.mockito.ArgumentMatchers.any;
import static org.mockito.ArgumentMatchers.anyString;
import static org.mockito.ArgumentMatchers.eq;
import static org.mockito.Mockito.mock;
import static org.mockito.Mockito.never;
import static org.mockito.Mockito.verify;
import static org.mockito.Mockito.when;

/**
 * Unit tests for PaymentSagaListener.
 *
 * <p>Tests the two inner message listeners:
 * <ul>
 *   <li>{@code StockReservedListener} - processes payment when stock is reserved</li>
 *   <li>{@code PaymentRefundRequestedListener} - refunds payment during compensation</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("PaymentSagaListener")
@ExtendWith(MockitoExtension.class)
class PaymentSagaListenerTest {

    @Mock
    private PaymentOperations paymentService;

    @Mock
    private HazelcastInstance hazelcast;

    private PaymentSagaListener listener;

    @BeforeEach
    void setUp() {
        listener = new PaymentSagaListener(paymentService, hazelcast);
    }

    @Nested
    @DisplayName("StockReserved event handling")
    class StockReservedTests {

        @Test
        @DisplayName("should process payment when StockReserved saga event is received")
        void shouldProcessPaymentForSagaEvent() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();
            String customerId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord stockReservedRecord = GenericRecordBuilder.compact("StockReservedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "StockReserved")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Inventory")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", UUID.randomUUID().toString())
                    .setString("correlationId", correlationId)
                    .setString("sagaId", sagaId)
                    .setString("sagaType", "OrderFulfillment")
                    .setInt32("stepNumber", 1)
                    .setBoolean("isCompensating", false)
                    .setString("orderId", orderId)
                    .setString("customerId", customerId)
                    .setString("amount", "22.00")
                    .setString("currency", "USD")
                    .setString("method", "CREDIT_CARD")
                    .build();

            Payment mockPayment = new Payment("pay-1", orderId, customerId,
                    new BigDecimal("22.00"), "USD", Payment.PaymentMethod.CREDIT_CARD);
            mockPayment.setStatus(Payment.PaymentStatus.CAPTURED);

            when(paymentService.processPaymentForOrder(
                    anyString(), anyString(), anyString(), anyString(),
                    anyString(), anyString(), anyString()))
                    .thenReturn(CompletableFuture.completedFuture(mockPayment));

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(stockReservedRecord);

            // Act
            listener.new StockReservedListener().onMessage(message);

            // Assert
            verify(paymentService).processPaymentForOrder(
                    eq(orderId),
                    eq(customerId),
                    eq("22.00"),
                    eq("USD"),
                    eq("CREDIT_CARD"),
                    eq(sagaId),
                    eq(correlationId)
            );
        }

        @Test
        @DisplayName("should ignore StockReserved events without sagaId")
        void shouldIgnoreNonSagaEvents() {
            // Arrange
            GenericRecord record = GenericRecordBuilder.compact("StockReservedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "StockReserved")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Inventory")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", UUID.randomUUID().toString())
                    .setString("correlationId", UUID.randomUUID().toString())
                    .setString("sagaId", null)
                    .setString("sagaType", null)
                    .setInt32("stepNumber", 1)
                    .setBoolean("isCompensating", false)
                    .setString("orderId", "order-1")
                    .setString("customerId", "cust-1")
                    .setString("amount", "10.00")
                    .setString("currency", "USD")
                    .setString("method", "CREDIT_CARD")
                    .build();

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(record);

            // Act
            listener.new StockReservedListener().onMessage(message);

            // Assert - should not call any service method
            verify(paymentService, never()).processPaymentForOrder(
                    anyString(), anyString(), anyString(), anyString(),
                    anyString(), anyString(), anyString());
        }

        @Test
        @DisplayName("should handle service exception gracefully")
        void shouldHandleServiceExceptionGracefully() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord record = GenericRecordBuilder.compact("StockReservedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "StockReserved")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Inventory")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", UUID.randomUUID().toString())
                    .setString("correlationId", correlationId)
                    .setString("sagaId", sagaId)
                    .setString("sagaType", "OrderFulfillment")
                    .setInt32("stepNumber", 1)
                    .setBoolean("isCompensating", false)
                    .setString("orderId", orderId)
                    .setString("customerId", "cust-1")
                    .setString("amount", "10.00")
                    .setString("currency", "USD")
                    .setString("method", "CREDIT_CARD")
                    .build();

            when(paymentService.processPaymentForOrder(
                    anyString(), anyString(), anyString(), anyString(),
                    anyString(), anyString(), anyString()))
                    .thenThrow(new RuntimeException("Payment gateway unavailable"));

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(record);

            // Act - should not throw
            listener.new StockReservedListener().onMessage(message);

            // Assert - exception was caught internally
            verify(paymentService).processPaymentForOrder(
                    eq(orderId), eq("cust-1"), eq("10.00"), eq("USD"),
                    eq("CREDIT_CARD"), eq(sagaId), eq(correlationId));
        }
    }

    @Nested
    @DisplayName("PaymentRefundRequested event handling - Compensation")
    class PaymentRefundRequestedTests {

        @Test
        @DisplayName("should refund payment when PaymentRefundRequested saga event is received")
        void shouldRefundPaymentForSagaEvent() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String paymentId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord refundRecord = GenericRecordBuilder.compact("PaymentRefundRequestedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "PaymentRefundRequested")
                    .setString("paymentId", paymentId)
                    .setString("sagaId", sagaId)
                    .setString("correlationId", correlationId)
                    .setString("reason", "Order cancelled by customer")
                    .build();

            Payment mockPayment = new Payment(paymentId, "order-1", "cust-1",
                    new BigDecimal("22.00"), "USD", Payment.PaymentMethod.CREDIT_CARD);
            mockPayment.setStatus(Payment.PaymentStatus.REFUNDED);

            when(paymentService.refundPaymentForSaga(
                    anyString(), anyString(), anyString(), anyString()))
                    .thenReturn(CompletableFuture.completedFuture(mockPayment));

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(refundRecord);

            // Act
            listener.new PaymentRefundRequestedListener().onMessage(message);

            // Assert
            verify(paymentService).refundPaymentForSaga(
                    eq(paymentId),
                    eq("Order cancelled by customer"),
                    eq(sagaId),
                    eq(correlationId)
            );
        }

        @Test
        @DisplayName("should use default reason when reason is null")
        void shouldUseDefaultReasonWhenNull() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String paymentId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord refundRecord = GenericRecordBuilder.compact("PaymentRefundRequestedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "PaymentRefundRequested")
                    .setString("paymentId", paymentId)
                    .setString("sagaId", sagaId)
                    .setString("correlationId", correlationId)
                    .setString("reason", null)
                    .build();

            Payment mockPayment = new Payment(paymentId, "order-1", "cust-1",
                    new BigDecimal("15.00"), "USD", Payment.PaymentMethod.CREDIT_CARD);
            mockPayment.setStatus(Payment.PaymentStatus.REFUNDED);

            when(paymentService.refundPaymentForSaga(
                    anyString(), anyString(), anyString(), anyString()))
                    .thenReturn(CompletableFuture.completedFuture(mockPayment));

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(refundRecord);

            // Act
            listener.new PaymentRefundRequestedListener().onMessage(message);

            // Assert - should use default "Saga compensation" reason
            verify(paymentService).refundPaymentForSaga(
                    eq(paymentId),
                    eq("Saga compensation"),
                    eq(sagaId),
                    eq(correlationId)
            );
        }

        @Test
        @DisplayName("should handle service exception gracefully during refund")
        void shouldHandleServiceExceptionGracefully() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String paymentId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord refundRecord = GenericRecordBuilder.compact("PaymentRefundRequestedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "PaymentRefundRequested")
                    .setString("paymentId", paymentId)
                    .setString("sagaId", sagaId)
                    .setString("correlationId", correlationId)
                    .setString("reason", "Timeout compensation")
                    .build();

            when(paymentService.refundPaymentForSaga(
                    anyString(), anyString(), anyString(), anyString()))
                    .thenThrow(new RuntimeException("Payment not found"));

            @SuppressWarnings("unchecked")
            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(refundRecord);

            // Act - should not throw
            listener.new PaymentRefundRequestedListener().onMessage(message);

            // Assert - exception was caught internally
            verify(paymentService).refundPaymentForSaga(
                    eq(paymentId), eq("Timeout compensation"),
                    eq(sagaId), eq(correlationId));
        }
    }

    @Nested
    @DisplayName("Circuit breaker behavior")
    class CircuitBreakerTests {

        @Mock
        private ResilientOperations resilientServiceInvoker;

        private PaymentSagaListener resilientListener;

        @BeforeEach
        void setUp() {
            resilientListener = new PaymentSagaListener(paymentService, hazelcast);
            resilientListener.setResilientOperations(resilientServiceInvoker);
        }

        @Test
        @DisplayName("should route payment processing through circuit breaker when invoker is set")
        @SuppressWarnings("unchecked")
        void shouldRoutePaymentThroughCircuitBreaker() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord record = GenericRecordBuilder.compact("StockReservedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "StockReserved")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Inventory")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", UUID.randomUUID().toString())
                    .setString("correlationId", correlationId)
                    .setString("sagaId", sagaId)
                    .setString("sagaType", "OrderFulfillment")
                    .setInt32("stepNumber", 1)
                    .setBoolean("isCompensating", false)
                    .setString("orderId", orderId)
                    .setString("customerId", "cust-1")
                    .setString("amount", "22.00")
                    .setString("currency", "USD")
                    .setString("method", "CREDIT_CARD")
                    .build();

            Payment mockPayment = new Payment("pay-1", orderId, "cust-1",
                    new BigDecimal("22.00"), "USD", Payment.PaymentMethod.CREDIT_CARD);
            mockPayment.setStatus(Payment.PaymentStatus.CAPTURED);

            when(resilientServiceInvoker.executeAsync(eq("payment-processing"), any(Supplier.class)))
                    .thenAnswer(invocation -> {
                        Supplier<CompletableFuture<?>> supplier = invocation.getArgument(1);
                        return supplier.get();
                    });
            when(paymentService.processPaymentForOrder(
                    anyString(), anyString(), anyString(), anyString(),
                    anyString(), anyString(), anyString()))
                    .thenReturn(CompletableFuture.completedFuture(mockPayment));

            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(record);

            // Act
            resilientListener.new StockReservedListener().onMessage(message);

            // Assert
            verify(resilientServiceInvoker).executeAsync(eq("payment-processing"), any(Supplier.class));
            verify(paymentService).processPaymentForOrder(
                    eq(orderId), eq("cust-1"), eq("22.00"), eq("USD"),
                    eq("CREDIT_CARD"), eq(sagaId), eq(correlationId));
        }

        @Test
        @DisplayName("should handle circuit breaker open for payment processing gracefully")
        @SuppressWarnings("unchecked")
        void shouldHandleCircuitBreakerOpenForPayment() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String orderId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord record = GenericRecordBuilder.compact("StockReservedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "StockReserved")
                    .setString("eventVersion", "1.0")
                    .setString("source", "Inventory")
                    .setInt64("timestamp", System.currentTimeMillis())
                    .setString("key", UUID.randomUUID().toString())
                    .setString("correlationId", correlationId)
                    .setString("sagaId", sagaId)
                    .setString("sagaType", "OrderFulfillment")
                    .setInt32("stepNumber", 1)
                    .setBoolean("isCompensating", false)
                    .setString("orderId", orderId)
                    .setString("customerId", "cust-1")
                    .setString("amount", "22.00")
                    .setString("currency", "USD")
                    .setString("method", "CREDIT_CARD")
                    .build();

            when(resilientServiceInvoker.executeAsync(eq("payment-processing"), any(Supplier.class)))
                    .thenReturn(CompletableFuture.failedFuture(
                            new ResilienceException("Circuit breaker open", "payment-processing")));

            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(record);

            // Act - should not throw
            resilientListener.new StockReservedListener().onMessage(message);

            // Assert - service was NOT called
            verify(paymentService, never()).processPaymentForOrder(
                    anyString(), anyString(), anyString(), anyString(),
                    anyString(), anyString(), anyString());
        }

        @Test
        @DisplayName("should handle circuit breaker open for refund gracefully")
        @SuppressWarnings("unchecked")
        void shouldHandleCircuitBreakerOpenForRefund() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String paymentId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord record = GenericRecordBuilder.compact("PaymentRefundRequestedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "PaymentRefundRequested")
                    .setString("paymentId", paymentId)
                    .setString("sagaId", sagaId)
                    .setString("correlationId", correlationId)
                    .setString("reason", "Order cancelled")
                    .build();

            when(resilientServiceInvoker.executeAsync(eq("payment-refund"), any(Supplier.class)))
                    .thenReturn(CompletableFuture.failedFuture(
                            new ResilienceException("Circuit breaker open", "payment-refund")));

            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(record);

            // Act - should not throw
            resilientListener.new PaymentRefundRequestedListener().onMessage(message);

            // Assert - service was NOT called
            verify(paymentService, never()).refundPaymentForSaga(
                    anyString(), anyString(), anyString(), anyString());
        }

        @Test
        @DisplayName("should route refund through circuit breaker when invoker is set")
        @SuppressWarnings("unchecked")
        void shouldRouteRefundThroughCircuitBreaker() {
            // Arrange
            String sagaId = UUID.randomUUID().toString();
            String paymentId = UUID.randomUUID().toString();
            String correlationId = UUID.randomUUID().toString();

            GenericRecord record = GenericRecordBuilder.compact("PaymentRefundRequestedEvent")
                    .setString("eventId", UUID.randomUUID().toString())
                    .setString("eventType", "PaymentRefundRequested")
                    .setString("paymentId", paymentId)
                    .setString("sagaId", sagaId)
                    .setString("correlationId", correlationId)
                    .setString("reason", "Order cancelled")
                    .build();

            Payment mockPayment = new Payment(paymentId, "order-1", "cust-1",
                    new BigDecimal("22.00"), "USD", Payment.PaymentMethod.CREDIT_CARD);
            mockPayment.setStatus(Payment.PaymentStatus.REFUNDED);

            when(resilientServiceInvoker.executeAsync(eq("payment-refund"), any(Supplier.class)))
                    .thenAnswer(invocation -> {
                        Supplier<CompletableFuture<?>> supplier = invocation.getArgument(1);
                        return supplier.get();
                    });
            when(paymentService.refundPaymentForSaga(anyString(), anyString(), anyString(), anyString()))
                    .thenReturn(CompletableFuture.completedFuture(mockPayment));

            Message<GenericRecord> message = mock(Message.class);
            when(message.getMessageObject()).thenReturn(record);

            // Act
            resilientListener.new PaymentRefundRequestedListener().onMessage(message);

            // Assert
            verify(resilientServiceInvoker).executeAsync(eq("payment-refund"), any(Supplier.class));
            verify(paymentService).refundPaymentForSaga(
                    eq(paymentId), eq("Order cancelled"), eq(sagaId), eq(correlationId));
        }
    }
}
