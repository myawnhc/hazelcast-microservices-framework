package com.theyawns.ecommerce.payment.domain;

import com.hazelcast.config.Config;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.theyawns.ecommerce.common.domain.Payment;
import com.theyawns.ecommerce.common.events.PaymentFailedEvent;
import com.theyawns.ecommerce.common.events.PaymentProcessedEvent;
import com.theyawns.ecommerce.common.events.PaymentRefundedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import org.junit.jupiter.api.AfterAll;
import org.junit.jupiter.api.BeforeAll;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Nested;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.TestInstance;

import java.math.BigDecimal;
import java.util.Optional;
import java.util.UUID;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.junit.jupiter.api.Assertions.assertFalse;
import static org.junit.jupiter.api.Assertions.assertNotNull;
import static org.junit.jupiter.api.Assertions.assertNull;
import static org.junit.jupiter.api.Assertions.assertTrue;

/**
 * Unit tests for PaymentViewUpdater.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@DisplayName("PaymentViewUpdater")
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class PaymentViewUpdaterTest {

    private static final String DOMAIN_NAME = "PaymentViewTest";

    private HazelcastInstance hazelcast;
    private HazelcastViewStore<String> viewStore;
    private PaymentViewUpdater viewUpdater;

    @BeforeAll
    void setUpHazelcast() {
        Config config = new Config();
        config.setClusterName("payment-view-test-" + System.currentTimeMillis());
        hazelcast = Hazelcast.newHazelcastInstance(config);
        viewStore = new HazelcastViewStore<>(hazelcast, DOMAIN_NAME);
        viewUpdater = new PaymentViewUpdater(viewStore);
    }

    @AfterAll
    void tearDownHazelcast() {
        if (hazelcast != null) {
            hazelcast.shutdown();
        }
    }

    @BeforeEach
    void clearView() {
        viewStore.clear();
    }

    @Nested
    @DisplayName("PaymentProcessedEvent handling")
    class PaymentProcessedEventTests {

        @Test
        @DisplayName("should create view entry with CAPTURED status")
        void shouldCreateViewEntryWithCapturedStatus() {
            String paymentId = UUID.randomUUID().toString();
            PaymentProcessedEvent event = new PaymentProcessedEvent(
                    paymentId, "order-001", "cust-001",
                    new BigDecimal("49.99"), "USD",
                    "txn-ext-001", "CREDIT_CARD");

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertNotNull(result);
            assertEquals(paymentId, result.getString("paymentId"));
            assertEquals("order-001", result.getString("orderId"));
            assertEquals("cust-001", result.getString("customerId"));
            assertEquals("49.99", result.getString("amount"));
            assertEquals("USD", result.getString("currency"));
            assertEquals("CREDIT_CARD", result.getString("method"));
            assertEquals(Payment.PaymentStatus.CAPTURED.name(), result.getString("status"));
            assertEquals("txn-ext-001", result.getString("transactionId"));
            assertNull(result.getString("failureReason"));
            assertTrue(result.getInt64("processedAt") > 0);
            assertTrue(result.getInt64("createdAt") > 0);
            assertTrue(result.getInt64("updatedAt") > 0);
        }

        @Test
        @DisplayName("should store entry in view store")
        void shouldStoreEntryInViewStore() {
            String paymentId = UUID.randomUUID().toString();
            PaymentProcessedEvent event = new PaymentProcessedEvent(
                    paymentId, "order-002", "cust-002",
                    new BigDecimal("29.99"), "USD",
                    "txn-ext-002", "DEBIT_CARD");

            viewUpdater.update(event.toGenericRecord());

            Optional<GenericRecord> stored = viewStore.get(paymentId);
            assertTrue(stored.isPresent());
            assertEquals("order-002", stored.get().getString("orderId"));
        }
    }

    @Nested
    @DisplayName("PaymentFailedEvent handling")
    class PaymentFailedEventTests {

        @Test
        @DisplayName("should create view entry with FAILED status")
        void shouldCreateViewEntryWithFailedStatus() {
            String paymentId = UUID.randomUUID().toString();
            PaymentFailedEvent event = new PaymentFailedEvent(
                    paymentId, "order-003", "cust-003",
                    new BigDecimal("199.99"), "USD",
                    "Insufficient funds", "CREDIT_CARD");

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertNotNull(result);
            assertEquals(paymentId, result.getString("paymentId"));
            assertEquals("order-003", result.getString("orderId"));
            assertEquals(Payment.PaymentStatus.FAILED.name(), result.getString("status"));
            assertEquals("Insufficient funds", result.getString("failureReason"));
            assertNull(result.getString("transactionId"));
        }

        @Test
        @DisplayName("should store failed entry in view store")
        void shouldStoreFailedEntryInViewStore() {
            String paymentId = UUID.randomUUID().toString();
            PaymentFailedEvent event = new PaymentFailedEvent(
                    paymentId, "order-004", "cust-004",
                    new BigDecimal("99.99"), "EUR",
                    "Card expired", "CREDIT_CARD");

            viewUpdater.update(event.toGenericRecord());

            Optional<GenericRecord> stored = viewStore.get(paymentId);
            assertTrue(stored.isPresent());
            assertEquals(Payment.PaymentStatus.FAILED.name(), stored.get().getString("status"));
        }
    }

    @Nested
    @DisplayName("PaymentRefundedEvent handling")
    class PaymentRefundedEventTests {

        @Test
        @DisplayName("should update status to REFUNDED")
        void shouldUpdateStatusToRefunded() {
            String paymentId = createCapturedPayment("order-005", "cust-005",
                    new BigDecimal("75.00"), "USD");

            PaymentRefundedEvent event = new PaymentRefundedEvent(
                    paymentId, "order-005", "75.00",
                    "SAGA_COMPENSATION", "refund-txn-001");

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertNotNull(result);
            assertEquals(Payment.PaymentStatus.REFUNDED.name(), result.getString("status"));
            assertEquals("SAGA_COMPENSATION", result.getString("failureReason"));
        }

        @Test
        @DisplayName("should preserve payment details on refund")
        void shouldPreservePaymentDetailsOnRefund() {
            String paymentId = createCapturedPayment("order-006", "cust-006",
                    new BigDecimal("50.00"), "USD");

            PaymentRefundedEvent event = new PaymentRefundedEvent(
                    paymentId, "order-006", "50.00",
                    "Customer request", "refund-txn-002");

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertEquals(paymentId, result.getString("paymentId"));
            assertEquals("order-006", result.getString("orderId"));
            assertEquals("cust-006", result.getString("customerId"));
            assertEquals("50.00", result.getString("amount"));
            assertEquals("USD", result.getString("currency"));
        }

        @Test
        @DisplayName("should return null for non-existent payment")
        void shouldReturnNullForNonExistentPayment() {
            PaymentRefundedEvent event = new PaymentRefundedEvent(
                    "non-existent", "order-999", "99.99",
                    "TEST", "refund-txn-999");

            viewUpdater.update(event.toGenericRecord());

            assertFalse(viewStore.containsKey("non-existent"));
        }

        @Test
        @DisplayName("should update updatedAt timestamp on refund")
        void shouldUpdateTimestampOnRefund() {
            String paymentId = createCapturedPayment("order-007", "cust-007",
                    new BigDecimal("25.00"), "USD");

            Optional<GenericRecord> before = viewStore.get(paymentId);
            long originalCreatedAt = before.get().getInt64("createdAt");

            // Small delay to ensure different timestamp
            try {
                Thread.sleep(10);
            } catch (InterruptedException e) {
                Thread.currentThread().interrupt();
            }

            PaymentRefundedEvent event = new PaymentRefundedEvent(
                    paymentId, "order-007", "25.00",
                    "Refund", "refund-txn-003");

            GenericRecord result = viewUpdater.update(event.toGenericRecord());

            assertEquals(originalCreatedAt, result.getInt64("createdAt"));
            assertTrue(result.getInt64("updatedAt") >= originalCreatedAt);
        }
    }

    @Nested
    @DisplayName("Unknown event type handling")
    class UnknownEventTypeTests {

        @Test
        @DisplayName("should not create entry for unknown event type on existing payment")
        void shouldNotCreateEntryForUnknownEvent() {
            // The view updater returns currentState for unknown events
            // With no existing state, this means the view store should not have an entry
            String paymentId = createCapturedPayment("order-unk", "cust-unk",
                    new BigDecimal("10.00"), "USD");

            Optional<GenericRecord> existing = viewStore.get(paymentId);
            assertTrue(existing.isPresent());
            // Existing entry should remain unchanged if unknown event is processed
        }
    }

    /**
     * Helper method to create a captured payment and return its ID.
     */
    private String createCapturedPayment(String orderId, String customerId,
                                          BigDecimal amount, String currency) {
        String paymentId = UUID.randomUUID().toString();
        PaymentProcessedEvent event = new PaymentProcessedEvent(
                paymentId, orderId, customerId,
                amount, currency,
                "txn-" + paymentId, "CREDIT_CARD");
        viewUpdater.update(event.toGenericRecord());
        return paymentId;
    }
}
