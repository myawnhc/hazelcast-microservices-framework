package com.theyawns.ecommerce.payment.domain;

import com.hazelcast.nio.serialization.genericrecord.GenericRecord;
import com.hazelcast.nio.serialization.genericrecord.GenericRecordBuilder;
import com.theyawns.ecommerce.common.domain.Payment;
import com.theyawns.ecommerce.common.events.PaymentFailedEvent;
import com.theyawns.ecommerce.common.events.PaymentProcessedEvent;
import com.theyawns.ecommerce.common.events.PaymentRefundedEvent;
import com.theyawns.framework.view.HazelcastViewStore;
import com.theyawns.framework.view.ViewUpdater;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.time.Instant;

/**
 * ViewUpdater implementation for the Payment domain.
 * Handles applying payment events to the materialized view.
 *
 * <p>Supported events:
 * <ul>
 *   <li>{@link PaymentProcessedEvent} - Creates a CAPTURED payment entry</li>
 *   <li>{@link PaymentFailedEvent} - Creates a FAILED payment entry</li>
 *   <li>{@link PaymentRefundedEvent} - Updates payment status to REFUNDED</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
public class PaymentViewUpdater extends ViewUpdater<String> {

    private static final Logger logger = LoggerFactory.getLogger(PaymentViewUpdater.class);

    /**
     * Creates a new PaymentViewUpdater.
     *
     * @param viewStore the view store to update
     */
    public PaymentViewUpdater(HazelcastViewStore<String> viewStore) {
        super(viewStore);
    }

    @Override
    protected String extractKey(GenericRecord eventRecord) {
        return getStringField(eventRecord, "key");
    }

    @Override
    protected GenericRecord applyEvent(GenericRecord eventRecord, GenericRecord currentState) {
        String eventType = getEventType(eventRecord);

        logger.debug("Applying event type: {} to payment view", eventType);

        return switch (eventType) {
            case PaymentProcessedEvent.EVENT_TYPE -> applyPaymentProcessed(eventRecord);
            case PaymentFailedEvent.EVENT_TYPE -> applyPaymentFailed(eventRecord);
            case PaymentRefundedEvent.EVENT_TYPE -> applyPaymentRefunded(eventRecord, currentState);
            default -> {
                logger.warn("Unknown event type: {}", eventType);
                yield currentState;
            }
        };
    }

    /**
     * Applies a PaymentProcessedEvent to create a CAPTURED payment view entry.
     *
     * @param eventRecord the event record
     * @return the new payment view state
     */
    private GenericRecord applyPaymentProcessed(GenericRecord eventRecord) {
        Instant now = Instant.now();
        return GenericRecordBuilder.compact(Payment.SCHEMA_NAME)
                .setString("paymentId", getStringField(eventRecord, "key"))
                .setString("orderId", getStringField(eventRecord, "orderId"))
                .setString("customerId", getStringField(eventRecord, "customerId"))
                .setString("amount", getStringField(eventRecord, "amount"))
                .setString("currency", getStringField(eventRecord, "currency"))
                .setString("method", getStringField(eventRecord, "method"))
                .setString("status", Payment.PaymentStatus.CAPTURED.name())
                .setString("transactionId", getStringField(eventRecord, "transactionId"))
                .setInt64("processedAt", now.toEpochMilli())
                .setString("failureReason", null)
                .setInt64("createdAt", now.toEpochMilli())
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a PaymentFailedEvent to create a FAILED payment view entry.
     *
     * @param eventRecord the event record
     * @return the new payment view state
     */
    private GenericRecord applyPaymentFailed(GenericRecord eventRecord) {
        Instant now = Instant.now();
        return GenericRecordBuilder.compact(Payment.SCHEMA_NAME)
                .setString("paymentId", getStringField(eventRecord, "key"))
                .setString("orderId", getStringField(eventRecord, "orderId"))
                .setString("customerId", getStringField(eventRecord, "customerId"))
                .setString("amount", getStringField(eventRecord, "amount"))
                .setString("currency", getStringField(eventRecord, "currency"))
                .setString("method", getStringField(eventRecord, "method"))
                .setString("status", Payment.PaymentStatus.FAILED.name())
                .setString("transactionId", null)
                .setInt64("processedAt", now.toEpochMilli())
                .setString("failureReason", getStringField(eventRecord, "failureReason"))
                .setInt64("createdAt", now.toEpochMilli())
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }

    /**
     * Applies a PaymentRefundedEvent to update payment status to REFUNDED.
     *
     * @param eventRecord the event record
     * @param currentState the current payment state
     * @return the updated payment view state
     */
    private GenericRecord applyPaymentRefunded(GenericRecord eventRecord, GenericRecord currentState) {
        if (currentState == null) {
            logger.error("Cannot refund non-existent payment: {}",
                    getStringField(eventRecord, "key"));
            return null;
        }

        Instant now = Instant.now();
        return GenericRecordBuilder.compact(Payment.SCHEMA_NAME)
                .setString("paymentId", currentState.getString("paymentId"))
                .setString("orderId", currentState.getString("orderId"))
                .setString("customerId", currentState.getString("customerId"))
                .setString("amount", currentState.getString("amount"))
                .setString("currency", currentState.getString("currency"))
                .setString("method", currentState.getString("method"))
                .setString("status", Payment.PaymentStatus.REFUNDED.name())
                .setString("transactionId", currentState.getString("transactionId"))
                .setInt64("processedAt", currentState.getInt64("processedAt"))
                .setString("failureReason", getStringField(eventRecord, "reason"))
                .setInt64("createdAt", currentState.getInt64("createdAt"))
                .setInt64("updatedAt", now.toEpochMilli())
                .build();
    }
}
