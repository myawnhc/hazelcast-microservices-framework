package com.theyawns.ecommerce.payment.config;

import com.hazelcast.client.HazelcastClient;
import com.hazelcast.client.config.ClientConfig;
import com.hazelcast.config.Config;
import com.hazelcast.config.EventJournalConfig;
import com.hazelcast.config.EvictionPolicy;
import com.hazelcast.config.MapConfig;
import com.hazelcast.config.MapStoreConfig;
import com.hazelcast.config.MaxSizePolicy;
import com.hazelcast.core.Hazelcast;
import com.hazelcast.core.HazelcastInstance;
import com.theyawns.ecommerce.common.domain.Payment;
import com.theyawns.ecommerce.payment.domain.PaymentViewUpdater;
import com.theyawns.framework.config.EmbeddedClusteringConfigurer;
import com.theyawns.framework.config.HazelcastClientConfigCustomizer;
import com.theyawns.framework.config.HazelcastConfigCustomizer;
import com.theyawns.framework.controller.EventSourcingController;
import com.theyawns.framework.event.DomainEvent;
import com.theyawns.framework.outbox.OutboxPublisher;
import com.theyawns.framework.outbox.OutboxStore;
import com.theyawns.framework.persistence.PersistenceProperties;
import com.theyawns.framework.persistence.mapstore.EventStoreMapStore;
import com.theyawns.framework.persistence.mapstore.ViewStoreMapStore;
import com.theyawns.framework.security.identity.EventAuthenticator;
import com.theyawns.framework.saga.HazelcastSagaStateStore;
import com.theyawns.framework.saga.SagaStateStore;
import com.theyawns.framework.store.HazelcastEventStore;
import com.theyawns.framework.view.HazelcastViewStore;
import io.micrometer.core.instrument.MeterRegistry;
import jakarta.annotation.PreDestroy;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.ObjectProvider;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.DependsOn;
import org.springframework.context.annotation.Primary;

import java.util.List;

/**
 * Spring configuration for the Payment Service.
 *
 * <p>Configures:
 * <ul>
 *   <li>Hazelcast instance with event journal</li>
 *   <li>Event store for payment events</li>
 *   <li>View store and updater for payment materialized view</li>
 *   <li>Saga state store for saga tracking</li>
 *   <li>Event sourcing controller</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@Configuration
public class PaymentServiceConfig {

    private static final Logger logger = LoggerFactory.getLogger(PaymentServiceConfig.class);

    private static final String DOMAIN_NAME = "Payment";

    @Value("${hazelcast.embedded.cluster-name:payment-local}")
    private String embeddedClusterName;

    @Value("${hazelcast.cluster.name:ecommerce-cluster}")
    private String clusterName;

    @Value("${hazelcast.cluster.members:}")
    private String clusterMembers;

    @Value("${hazelcast.event-journal.capacity:10000}")
    private int eventJournalCapacity;

    @Value("${hazelcast.embedded.clustering.enabled:false}")
    private boolean embeddedClusteringEnabled;

    @Value("${hazelcast.embedded.clustering.discovery-mode:dns}")
    private String embeddedClusteringDiscoveryMode;

    @Value("${hazelcast.embedded.clustering.service-dns:}")
    private String embeddedClusteringServiceDns;

    @Value("${hazelcast.embedded.clustering.port:5801}")
    private int embeddedClusteringPort;

    @Autowired(required = false)
    private List<HazelcastConfigCustomizer> configCustomizers;

    @Autowired(required = false)
    private List<HazelcastClientConfigCustomizer> clientConfigCustomizers;

    private EventSourcingController<Payment, String, DomainEvent<Payment, String>> controller;

    /**
     * Creates the Hazelcast instance for the Payment Service.
     *
     * <p>Uses a service-specific cluster name (default: {@code payment-local}) to distinguish
     * this embedded instance from the shared cluster in Management Center.
     *
     * <p>MapStore persistence is NOT configured here because hazelcast-spring's
     * {@code BeanFactoryPostProcessor} forces early creation of this bean, before
     * auto-configuration beans (MapStore, PersistenceProperties) are available.
     * MapStore is attached later by the {@link #persistenceAttacher} bean.
     *
     * @return the configured Hazelcast instance
     */
    @Primary
    @Bean
    public HazelcastInstance hazelcastInstance() {
        Config config = new Config();

        // Resolve embedded cluster name: @Value → env var → default
        String effectiveEmbeddedName = embeddedClusterName;
        if (effectiveEmbeddedName == null || effectiveEmbeddedName.isEmpty()) {
            effectiveEmbeddedName = System.getenv("HAZELCAST_EMBEDDED_CLUSTER_NAME");
        }
        if (effectiveEmbeddedName == null || effectiveEmbeddedName.isEmpty()) {
            effectiveEmbeddedName = "payment-local";
        }
        config.setClusterName(effectiveEmbeddedName);
        logger.info("Embedded cluster name: '{}'", effectiveEmbeddedName);

        // Resolve cluster members: @Value → env var → empty
        String effectiveClusterMembers = clusterMembers;
        if (effectiveClusterMembers == null || effectiveClusterMembers.isEmpty()) {
            effectiveClusterMembers = System.getenv("HAZELCAST_CLUSTER_MEMBERS");
        }

        // Enable event journal for pending events map (required for Jet streaming)
        int effectiveCapacity = eventJournalCapacity > 0 ? eventJournalCapacity : 10000;

        // Configure pending maps for ALL domains with event journal (required for cluster-wide consistency)
        for (String domain : new String[]{"Customer", "Product", "Order", "Payment"}) {
            MapConfig pendingMapConfig = new MapConfig(domain + "_PENDING")
                    .setEventJournalConfig(new EventJournalConfig()
                            .setEnabled(true)
                            .setCapacity(effectiveCapacity));
            config.addMapConfig(pendingMapConfig);
        }

        // Configure view and event store maps (MapStore attached later by persistenceAttacher)
        config.addMapConfig(new MapConfig(DOMAIN_NAME + "_VIEW"));
        config.addMapConfig(new MapConfig(DOMAIN_NAME + "_ES"));

        // Configure embedded clustering (standalone by default, K8s DNS discovery when enabled)
        EmbeddedClusteringConfigurer.configure(config, embeddedClusteringEnabled,
                embeddedClusteringDiscoveryMode, embeddedClusteringServiceDns,
                embeddedClusteringPort);

        // Enable Jet for stream processing pipeline
        config.getJetConfig().setEnabled(true);
        config.getJetConfig().setResourceUploadEnabled(true);

        // Apply framework-level customizers (e.g., HD Memory, TPC)
        if (configCustomizers != null) {
            configCustomizers.forEach(c -> c.customize(config));
        }

        logger.info("Creating standalone Hazelcast instance for local Jet processing (cluster: {})",
                embeddedClusterName);
        return Hazelcast.newHazelcastInstance(config);
    }

    /**
     * Creates a Hazelcast client that connects to the external shared cluster.
     *
     * <p>This client is used for cross-service communication:
     * <ul>
     *   <li>ITopic pub/sub for saga event propagation</li>
     *   <li>Shared saga state IMap</li>
     * </ul>
     *
     * @return the Hazelcast client instance, or null if no cluster members configured
     */
    @Bean(name = "hazelcastClient")
    public HazelcastInstance hazelcastClient() {
        // Resolve cluster members: @Value → env var
        String effectiveClusterMembers = clusterMembers;
        if (effectiveClusterMembers == null || effectiveClusterMembers.isEmpty()) {
            effectiveClusterMembers = System.getenv("HAZELCAST_CLUSTER_MEMBERS");
        }

        if (effectiveClusterMembers == null || effectiveClusterMembers.isBlank()) {
            logger.info("No cluster members configured - shared Hazelcast client not created");
            return null;
        }

        // Resolve cluster name
        String effectiveClusterName = clusterName;
        if (effectiveClusterName == null || effectiveClusterName.isEmpty()) {
            effectiveClusterName = System.getenv("HAZELCAST_CLUSTER_NAME");
        }
        if (effectiveClusterName == null || effectiveClusterName.isEmpty()) {
            effectiveClusterName = "ecommerce-cluster";
        }

        ClientConfig clientConfig = new ClientConfig();
        clientConfig.setClusterName(effectiveClusterName);
        for (String member : effectiveClusterMembers.split(",")) {
            clientConfig.getNetworkConfig().addAddress(member.trim());
        }

        // Apply framework-level client customizers (e.g., TPC)
        if (clientConfigCustomizers != null) {
            clientConfigCustomizers.forEach(c -> c.customize(clientConfig));
        }

        logger.info("Creating Hazelcast client for shared cluster: {} with members: {}",
                effectiveClusterName, effectiveClusterMembers);
        return HazelcastClient.newHazelcastClient(clientConfig);
    }

    /**
     * Attaches MapStore persistence to event store and view maps.
     *
     * <p>This bean runs during normal Spring bean creation (after auto-configuration
     * beans are available), modifying the live Hazelcast config to add MapStore
     * before any {@code getMap()} calls. The {@code hazelcastInstance()} bean is
     * forced early by hazelcast-spring's BeanFactoryPostProcessor, before persistence
     * beans exist — so MapStore must be attached in this separate phase.
     *
     * @param hazelcastInstance the embedded Hazelcast instance
     * @param esMapStoreProvider optional event store MapStore
     * @param viewMapStoreProvider optional view store MapStore
     * @param propsProvider optional persistence properties
     * @return marker object (bean exists to enforce ordering via @DependsOn)
     */
    @Bean
    public Object persistenceAttacher(
            HazelcastInstance hazelcastInstance,
            ObjectProvider<EventStoreMapStore> esMapStoreProvider,
            ObjectProvider<ViewStoreMapStore> viewMapStoreProvider,
            ObjectProvider<PersistenceProperties> propsProvider) {

        EventStoreMapStore esMapStore = esMapStoreProvider.getIfAvailable();
        ViewStoreMapStore viewMapStore = viewMapStoreProvider.getIfAvailable();
        PersistenceProperties props = propsProvider.getIfAvailable();

        if (esMapStore != null && viewMapStore != null && props != null) {
            // Attach MapStore to event store map
            MapConfig esConfig = hazelcastInstance.getConfig().getMapConfig(DOMAIN_NAME + "_ES");
            esConfig.setMapStoreConfig(new MapStoreConfig()
                    .setImplementation(esMapStore)
                    .setEnabled(true)
                    .setWriteDelaySeconds(props.getWriteDelaySeconds())
                    .setWriteBatchSize(props.getWriteBatchSize())
                    .setWriteCoalescing(false)
                    .setInitialLoadMode(MapStoreConfig.InitialLoadMode.LAZY));
            logger.info("Persistence enabled for {}_ES map (write-behind)", DOMAIN_NAME);

            PersistenceProperties.EvictionConfig esEviction = props.getEventStoreEviction();
            if (esEviction.isEnabled()) {
                esConfig.getEvictionConfig()
                        .setEvictionPolicy(EvictionPolicy.valueOf(esEviction.getEvictionPolicy()))
                        .setMaxSizePolicy(MaxSizePolicy.valueOf(esEviction.getMaxSizePolicy()))
                        .setSize(esEviction.getMaxSize());
                if (esEviction.getMaxIdleSeconds() > 0) {
                    esConfig.setMaxIdleSeconds(esEviction.getMaxIdleSeconds());
                }
                logger.info("Eviction enabled for {}_ES (maxSize={}, policy={})",
                        DOMAIN_NAME, esEviction.getMaxSize(), esEviction.getEvictionPolicy());
            }

            // Attach MapStore to view map
            MapConfig viewConfig = hazelcastInstance.getConfig().getMapConfig(DOMAIN_NAME + "_VIEW");
            viewConfig.setMapStoreConfig(new MapStoreConfig()
                    .setImplementation(viewMapStore)
                    .setEnabled(true)
                    .setWriteDelaySeconds(props.getWriteDelaySeconds())
                    .setWriteBatchSize(props.getWriteBatchSize())
                    .setWriteCoalescing(true)
                    .setInitialLoadMode(MapStoreConfig.InitialLoadMode.LAZY));
            logger.info("Persistence enabled for {}_VIEW map (write-behind)", DOMAIN_NAME);

            PersistenceProperties.EvictionConfig viewEviction = props.getViewStoreEviction();
            if (viewEviction.isEnabled()) {
                viewConfig.getEvictionConfig()
                        .setEvictionPolicy(EvictionPolicy.valueOf(viewEviction.getEvictionPolicy()))
                        .setMaxSizePolicy(MaxSizePolicy.valueOf(viewEviction.getMaxSizePolicy()))
                        .setSize(viewEviction.getMaxSize());
                if (viewEviction.getMaxIdleSeconds() > 0) {
                    viewConfig.setMaxIdleSeconds(viewEviction.getMaxIdleSeconds());
                }
                logger.info("Eviction enabled for {}_VIEW (maxSize={}, policy={}, maxIdle={}s)",
                        DOMAIN_NAME, viewEviction.getMaxSize(), viewEviction.getEvictionPolicy(),
                        viewEviction.getMaxIdleSeconds());
            }
        } else {
            logger.info("Persistence not available — {}_ES and {}_VIEW maps will use in-memory only",
                    DOMAIN_NAME, DOMAIN_NAME);
        }

        return "persistence-attached";
    }

    /**
     * Creates the event store for payment events.
     *
     * @param hazelcast the Hazelcast instance
     * @return the event store
     */
    @Bean
    @DependsOn("persistenceAttacher")
    public HazelcastEventStore<Payment, String, DomainEvent<Payment, String>> paymentEventStore(
            HazelcastInstance hazelcast) {
        return new HazelcastEventStore<>(hazelcast, DOMAIN_NAME);
    }

    /**
     * Creates the view store for the payment materialized view.
     *
     * @param hazelcast the Hazelcast instance
     * @return the view store
     */
    @Bean
    @DependsOn("persistenceAttacher")
    public HazelcastViewStore<String> paymentViewStore(HazelcastInstance hazelcast) {
        return new HazelcastViewStore<>(hazelcast, DOMAIN_NAME);
    }

    /**
     * Creates the view updater that applies payment events to the view.
     *
     * @param paymentViewStore the view store
     * @return the view updater
     */
    @Bean
    public PaymentViewUpdater paymentViewUpdater(HazelcastViewStore<String> paymentViewStore) {
        return new PaymentViewUpdater(paymentViewStore);
    }

    /**
     * Creates the saga state store for saga tracking.
     *
     * @param hazelcastInstance the Hazelcast instance
     * @param meterRegistry the metrics registry
     * @return the saga state store
     */
    @Bean
    public SagaStateStore sagaStateStore(
            @org.springframework.beans.factory.annotation.Qualifier("hazelcastClient")
            @org.springframework.beans.factory.annotation.Autowired(required = false)
            HazelcastInstance hazelcastClient,
            HazelcastInstance hazelcastInstance,
            MeterRegistry meterRegistry) {
        // Use shared cluster for saga state if available, otherwise fall back to embedded
        HazelcastInstance hz = hazelcastClient != null ? hazelcastClient : hazelcastInstance;
        return new HazelcastSagaStateStore(hz, meterRegistry);
    }

    /**
     * Creates the event sourcing controller for payment operations.
     *
     * @param hazelcastInstance the embedded Hazelcast instance
     * @param hazelcastClient the shared Hazelcast client (optional)
     * @param eventStore the event store
     * @param viewUpdater the view updater
     * @param meterRegistry the metrics registry
     * @return the event sourcing controller
     */
    @Bean
    public EventSourcingController<Payment, String, DomainEvent<Payment, String>> paymentEventSourcingController(
            HazelcastInstance hazelcastInstance,
            @org.springframework.beans.factory.annotation.Qualifier("hazelcastClient")
            @org.springframework.beans.factory.annotation.Autowired(required = false)
            HazelcastInstance hazelcastClient,
            HazelcastEventStore<Payment, String, DomainEvent<Payment, String>> eventStore,
            PaymentViewUpdater viewUpdater,
            MeterRegistry meterRegistry,
            @org.springframework.beans.factory.annotation.Autowired(required = false)
            OutboxStore outboxStore,
            @org.springframework.beans.factory.annotation.Autowired(required = false)
            OutboxPublisher outboxPublisher,
            @org.springframework.beans.factory.annotation.Autowired(required = false)
            EventAuthenticator eventAuthenticator) {

        controller = EventSourcingController.<Payment, String, DomainEvent<Payment, String>>builder()
                .hazelcast(hazelcastInstance)
                .sharedHazelcast(hazelcastClient)
                .domainName(DOMAIN_NAME)
                .eventStore(eventStore)
                .viewUpdater(viewUpdater)
                .viewUpdaterClass(PaymentViewUpdater.class)
                .meterRegistry(meterRegistry)
                .outboxStore(outboxStore)
                .outboxPublisher(outboxPublisher)
                .eventAuthenticator(eventAuthenticator)
                .build();

        // Start the pipeline immediately after building the controller
        logger.info("Starting Payment event sourcing pipeline");
        controller.start();

        return controller;
    }

    /**
     * Stops the event sourcing pipeline on shutdown.
     */
    @PreDestroy
    public void stopPipeline() {
        if (controller != null && controller.isRunning()) {
            logger.info("Stopping Payment event sourcing pipeline");
            controller.stop();
        }
    }
}
