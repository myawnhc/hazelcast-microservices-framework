package com.theyawns.ecommerce.payment.service;

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.map.IMap;
import com.theyawns.ecommerce.common.domain.Payment;
import com.theyawns.ecommerce.common.dto.PaymentDTO;
import com.theyawns.ecommerce.common.events.PaymentFailedEvent;
import com.theyawns.ecommerce.common.events.PaymentProcessedEvent;
import com.theyawns.ecommerce.common.events.PaymentRefundedEvent;
import com.theyawns.ecommerce.payment.exception.InvalidPaymentStateException;
import com.theyawns.ecommerce.payment.exception.PaymentNotFoundException;
import com.theyawns.framework.controller.EventSourcingController;
import com.theyawns.framework.controller.SagaMetadata;
import com.theyawns.framework.event.DomainEvent;
import com.theyawns.framework.saga.SagaCompensationConfig;
import com.theyawns.framework.saga.SagaStateStore;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.stereotype.Service;

import java.math.BigDecimal;
import java.util.Optional;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;

/**
 * Business logic service for payment management.
 *
 * <p>All operations use the event sourcing controller to:
 * <ul>
 *   <li>Publish domain events</li>
 *   <li>Update the materialized view</li>
 *   <li>Return async completion futures</li>
 * </ul>
 *
 * <p>Read operations use the materialized view for fast lookups.
 *
 * <p>Payment processing is simulated for demonstration purposes.
 * In production, this would integrate with an external payment gateway.
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@Service
public class PaymentService implements PaymentOperations {

    private static final Logger logger = LoggerFactory.getLogger(PaymentService.class);

    private final EventSourcingController<Payment, String, DomainEvent<Payment, String>> controller;
    private final HazelcastInstance hazelcast;
    private final SagaStateStore sagaStateStore;

    /**
     * Creates a new PaymentService.
     *
     * @param controller the event sourcing controller for payment events
     * @param hazelcast the Hazelcast instance
     * @param sagaStateStore the saga state store for tracking distributed transactions
     */
    public PaymentService(
            EventSourcingController<Payment, String, DomainEvent<Payment, String>> controller,
            HazelcastInstance hazelcast,
            SagaStateStore sagaStateStore) {
        this.controller = controller;
        this.hazelcast = hazelcast;
        this.sagaStateStore = sagaStateStore;
    }

    /**
     * Processes a payment for an order.
     *
     * @param dto the payment data
     * @return a future that completes with the processed payment
     */
    @Override
    public CompletableFuture<Payment> processPayment(PaymentDTO dto) {
        String paymentId = UUID.randomUUID().toString();
        logger.info("Processing payment with ID: {} for order: {}", paymentId, dto.getOrderId());

        String method = dto.getMethod() != null ? dto.getMethod() : Payment.PaymentMethod.CREDIT_CARD.name();

        // Simulate payment processing
        boolean paymentSucceeded = simulatePaymentProcessing(dto.getAmount(), method);

        if (paymentSucceeded) {
            String transactionId = generateTransactionId();

            PaymentProcessedEvent event = new PaymentProcessedEvent(
                    paymentId,
                    dto.getOrderId(),
                    dto.getCustomerId(),
                    dto.getAmount(),
                    dto.getCurrency(),
                    transactionId,
                    method
            );

            return controller.handleEvent(event)
                    .thenApply(completionInfo -> {
                        logger.debug("Payment processed event completed: {}", completionInfo.getEventId());

                        // Index payment by order for getPaymentByOrder
                        indexPaymentByOrder(dto.getOrderId(), paymentId);

                        return getPaymentOrThrow(paymentId);
                    });
        } else {
            PaymentFailedEvent event = new PaymentFailedEvent(
                    paymentId,
                    dto.getOrderId(),
                    dto.getCustomerId(),
                    dto.getAmount(),
                    dto.getCurrency(),
                    "Payment declined by processor",
                    method
            );

            return controller.handleEvent(event)
                    .thenApply(completionInfo -> {
                        logger.debug("Payment failed event completed: {}", completionInfo.getEventId());
                        return getPaymentOrThrow(paymentId);
                    });
        }
    }

    /**
     * Processes a payment as part of a saga flow.
     *
     * @param orderId the order ID
     * @param customerId the customer ID
     * @param amount the payment amount as string
     * @param currency the currency code
     * @param method the payment method
     * @param sagaId the saga ID
     * @param correlationId the correlation ID
     * @return a future that completes with the processed payment
     */
    @Override
    public CompletableFuture<Payment> processPaymentForOrder(String orderId, String customerId,
                                                               String amount, String currency,
                                                               String method, String sagaId,
                                                               String correlationId) {
        String paymentId = UUID.randomUUID().toString();
        logger.info("Processing saga payment with ID: {} for order: {} (sagaId: {})",
                paymentId, orderId, sagaId);

        BigDecimal amountDecimal = new BigDecimal(amount);
        String paymentMethod = method != null ? method : Payment.PaymentMethod.CREDIT_CARD.name();

        boolean paymentSucceeded = simulatePaymentProcessing(amountDecimal, paymentMethod);

        SagaMetadata sagaMetadata = SagaMetadata.builder()
                .sagaId(sagaId)
                .sagaType(SagaCompensationConfig.ORDER_FULFILLMENT_SAGA)
                .stepNumber(SagaCompensationConfig.STEP_PAYMENT_PROCESSED)
                .build();

        if (paymentSucceeded) {
            String transactionId = generateTransactionId();

            PaymentProcessedEvent event = new PaymentProcessedEvent(
                    paymentId, orderId, customerId,
                    amountDecimal, currency, transactionId, paymentMethod
            );
            event.setSagaId(sagaId);
            event.setCorrelationId(correlationId);

            return controller.handleEvent(event, UUID.fromString(correlationId), sagaMetadata)
                    .thenApply(completionInfo -> {
                        logger.info("Saga payment processed: paymentId={}, orderId={}, sagaId={}",
                                paymentId, orderId, sagaId);

                        // Record step 2 completed in saga state store
                        sagaStateStore.recordStepCompleted(
                                sagaId,
                                SagaCompensationConfig.STEP_PAYMENT_PROCESSED,
                                SagaCompensationConfig.PAYMENT_PROCESSED,
                                SagaCompensationConfig.PAYMENT_SERVICE,
                                completionInfo.getEventId()
                        );

                        indexPaymentByOrder(orderId, paymentId);
                        return getPaymentOrThrow(paymentId);
                    });
        } else {
            PaymentFailedEvent event = new PaymentFailedEvent(
                    paymentId, orderId, customerId,
                    amountDecimal, currency, "Payment declined by processor", paymentMethod
            );
            event.setSagaId(sagaId);
            event.setCorrelationId(correlationId);

            return controller.handleEvent(event, UUID.fromString(correlationId), sagaMetadata)
                    .thenApply(completionInfo -> {
                        logger.warn("Saga payment failed: paymentId={}, orderId={}, sagaId={}",
                                paymentId, orderId, sagaId);

                        // Record step 2 failed - triggers compensation
                        sagaStateStore.recordStepFailed(
                                sagaId,
                                SagaCompensationConfig.STEP_PAYMENT_PROCESSED,
                                SagaCompensationConfig.PAYMENT_FAILED,
                                SagaCompensationConfig.PAYMENT_SERVICE,
                                "Payment declined by processor"
                        );

                        return getPaymentOrThrow(paymentId);
                    });
        }
    }

    /**
     * Retrieves a payment by ID from the materialized view.
     *
     * @param paymentId the payment ID
     * @return the payment, or empty if not found
     */
    @Override
    public Optional<Payment> getPayment(String paymentId) {
        logger.debug("Getting payment: {}", paymentId);
        return controller.getViewState(paymentId)
                .map(Payment::fromGenericRecord);
    }

    /**
     * Retrieves the payment for a given order.
     *
     * @param orderId the order ID
     * @return the payment, or empty if not found
     */
    @Override
    public Optional<Payment> getPaymentByOrder(String orderId) {
        logger.debug("Getting payment for order: {}", orderId);

        IMap<String, String> orderPaymentIndex = hazelcast.getMap("OrderPayments");
        String paymentId = orderPaymentIndex.get(orderId);

        if (paymentId == null) {
            return Optional.empty();
        }

        return getPayment(paymentId);
    }

    /**
     * Refunds a previously captured payment.
     *
     * @param paymentId the payment ID
     * @param reason the refund reason
     * @return a future that completes with the refunded payment
     * @throws PaymentNotFoundException if payment does not exist
     * @throws InvalidPaymentStateException if payment cannot be refunded
     */
    @Override
    public CompletableFuture<Payment> refundPayment(String paymentId, String reason) {
        logger.info("Refunding payment: {} (reason: {})", paymentId, reason);

        Payment payment = getPaymentOrThrow(paymentId);

        if (!payment.canRefund()) {
            throw new InvalidPaymentStateException(paymentId, payment.getStatus().name(), "refund");
        }

        String refundTransactionId = generateRefundTransactionId();

        PaymentRefundedEvent event = new PaymentRefundedEvent(
                paymentId,
                payment.getOrderId(),
                payment.getAmount() != null ? payment.getAmount().toString() : null,
                reason,
                refundTransactionId
        );

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.debug("Payment refunded event processed: {}", completionInfo.getEventId());
                    return getPaymentOrThrow(paymentId);
                });
    }

    /**
     * Refunds a payment as part of saga compensation.
     *
     * @param paymentId the payment ID
     * @param reason the refund reason
     * @param sagaId the saga ID
     * @param correlationId the correlation ID
     * @return a future that completes with the refunded payment
     */
    @Override
    public CompletableFuture<Payment> refundPaymentForSaga(String paymentId, String reason,
                                                              String sagaId, String correlationId) {
        logger.info("Saga refunding payment: {} (sagaId: {}, reason: {})", paymentId, sagaId, reason);

        Payment payment = getPaymentOrThrow(paymentId);

        if (!payment.canRefund()) {
            logger.warn("Cannot refund payment {} in status {} for saga {}",
                    paymentId, payment.getStatus(), sagaId);
            throw new InvalidPaymentStateException(paymentId, payment.getStatus().name(), "refund");
        }

        String refundTransactionId = generateRefundTransactionId();

        PaymentRefundedEvent event = new PaymentRefundedEvent(
                paymentId,
                payment.getOrderId(),
                payment.getAmount() != null ? payment.getAmount().toString() : null,
                reason,
                refundTransactionId
        );
        event.setSagaId(sagaId);
        event.setCorrelationId(correlationId);
        event.setIsCompensating(true);

        return controller.handleEvent(event)
                .thenApply(completionInfo -> {
                    logger.info("Saga payment refunded: paymentId={}, sagaId={}", paymentId, sagaId);
                    return getPaymentOrThrow(paymentId);
                });
    }

    /**
     * Checks if a payment exists in the materialized view.
     *
     * @param paymentId the payment ID
     * @return true if the payment exists
     */
    @Override
    public boolean paymentExists(String paymentId) {
        return controller.getViewStore().containsKey(paymentId);
    }

    /**
     * Gets a payment or throws an exception if not found.
     *
     * @param paymentId the payment ID
     * @return the payment
     * @throws PaymentNotFoundException if payment does not exist
     */
    private Payment getPaymentOrThrow(String paymentId) {
        return getPayment(paymentId)
                .orElseThrow(() -> new PaymentNotFoundException(paymentId));
    }

    /**
     * Indexes a payment by order ID for efficient lookup.
     *
     * @param orderId the order ID
     * @param paymentId the payment ID
     */
    private void indexPaymentByOrder(String orderId, String paymentId) {
        IMap<String, String> orderPaymentIndex = hazelcast.getMap("OrderPayments");
        orderPaymentIndex.put(orderId, paymentId);
    }

    /**
     * Simulates payment processing.
     * In production, this would call an external payment gateway.
     *
     * <p>For demo purposes, payments are always successful unless the amount
     * exceeds 10,000 or the method is unknown.
     *
     * @param amount the payment amount
     * @param method the payment method
     * @return true if the payment succeeded
     */
    private boolean simulatePaymentProcessing(BigDecimal amount, String method) {
        // Simulate failure for very large amounts (demo/testing)
        if (amount != null && amount.compareTo(new BigDecimal("10000")) > 0) {
            logger.info("Simulating payment decline for amount: {}", amount);
            return false;
        }

        // Validate payment method
        try {
            Payment.PaymentMethod.valueOf(method);
        } catch (IllegalArgumentException e) {
            logger.info("Simulating payment decline for unknown method: {}", method);
            return false;
        }

        return true;
    }

    /**
     * Generates a simulated external transaction ID.
     *
     * @return the transaction ID
     */
    private String generateTransactionId() {
        return "TXN-" + System.currentTimeMillis() + "-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }

    /**
     * Generates a simulated refund transaction ID.
     *
     * @return the refund transaction ID
     */
    private String generateRefundTransactionId() {
        return "REF-" + System.currentTimeMillis() + "-" + UUID.randomUUID().toString().substring(0, 8).toUpperCase();
    }

    /**
     * Returns the event sourcing controller for advanced operations.
     *
     * @return the controller
     */
    public EventSourcingController<Payment, String, DomainEvent<Payment, String>> getController() {
        return controller;
    }
}
