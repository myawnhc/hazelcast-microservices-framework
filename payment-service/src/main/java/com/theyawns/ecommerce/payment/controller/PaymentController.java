package com.theyawns.ecommerce.payment.controller;

import com.theyawns.ecommerce.common.dto.PaymentDTO;
import com.theyawns.ecommerce.payment.service.PaymentOperations;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.media.Content;
import io.swagger.v3.oas.annotations.media.Schema;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import io.swagger.v3.oas.annotations.tags.Tag;
import jakarta.validation.Valid;
import jakarta.validation.constraints.NotBlank;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PathVariable;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * REST controller for payment management.
 *
 * <p>Endpoints:
 * <ul>
 *   <li>POST /api/payments - Process a payment</li>
 *   <li>GET /api/payments/{paymentId} - Get payment by ID</li>
 *   <li>GET /api/payments/order/{orderId} - Get payment for an order</li>
 *   <li>POST /api/payments/{paymentId}/refund - Refund a payment</li>
 *   <li>GET /api/payments - List all payments</li>
 *   <li>GET /api/payments/{id}/events - Get payment event history</li>
 * </ul>
 *
 * @author Generated by Claude Code
 * @since 2.0
 */
@RestController
@RequestMapping("/api/payments")
@Tag(name = "Payment Management", description = "APIs for processing and managing payments")
public class PaymentController {

    private static final Logger logger = LoggerFactory.getLogger(PaymentController.class);

    private final PaymentOperations paymentService;

    /**
     * Creates a new PaymentController.
     *
     * @param paymentService the payment service
     */
    public PaymentController(PaymentOperations paymentService) {
        this.paymentService = paymentService;
    }

    /**
     * Processes a payment.
     *
     * @param dto the payment data
     * @return the processed payment
     */
    @PostMapping
    @Operation(summary = "Process payment", description = "Processes a payment for an order")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "201", description = "Payment processed successfully",
                    content = @Content(schema = @Schema(implementation = PaymentDTO.class))),
            @ApiResponse(responseCode = "400", description = "Invalid payment data")
    })
    public CompletableFuture<ResponseEntity<PaymentDTO>> processPayment(@Valid @RequestBody PaymentDTO dto) {
        logger.info("REST: Processing payment for order: {}", dto.getOrderId());

        return paymentService.processPayment(dto)
                .thenApply(payment -> {
                    PaymentDTO response = payment.toDTO();
                    logger.info("REST: Payment processed with ID: {}, status: {}",
                            response.getPaymentId(), response.getStatus());
                    return ResponseEntity.status(HttpStatus.CREATED).body(response);
                });
    }

    /**
     * Retrieves a payment by ID.
     *
     * @param paymentId the payment ID
     * @return the payment, or 404 if not found
     */
    @GetMapping("/{paymentId}")
    @Operation(summary = "Get payment by ID", description = "Retrieves payment details by payment ID")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Payment found",
                    content = @Content(schema = @Schema(implementation = PaymentDTO.class))),
            @ApiResponse(responseCode = "404", description = "Payment not found")
    })
    public ResponseEntity<PaymentDTO> getPayment(
            @Parameter(description = "Payment ID", required = true) @PathVariable String paymentId) {
        logger.debug("REST: Getting payment: {}", paymentId);

        return paymentService.getPayment(paymentId)
                .map(payment -> {
                    PaymentDTO dto = payment.toDTO();
                    return ResponseEntity.ok(dto);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * Retrieves the payment for an order.
     *
     * @param orderId the order ID
     * @return the payment, or 404 if not found
     */
    @GetMapping("/order/{orderId}")
    @Operation(summary = "Get payment for order", description = "Retrieves the payment associated with an order")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Payment found",
                    content = @Content(schema = @Schema(implementation = PaymentDTO.class))),
            @ApiResponse(responseCode = "404", description = "Payment not found for order")
    })
    public ResponseEntity<PaymentDTO> getPaymentByOrder(
            @Parameter(description = "Order ID", required = true) @PathVariable String orderId) {
        logger.debug("REST: Getting payment for order: {}", orderId);

        return paymentService.getPaymentByOrder(orderId)
                .map(payment -> {
                    PaymentDTO dto = payment.toDTO();
                    return ResponseEntity.ok(dto);
                })
                .orElse(ResponseEntity.notFound().build());
    }

    /**
     * Refunds a payment.
     *
     * @param paymentId the payment ID
     * @param request the refund request
     * @return the refunded payment
     */
    @PostMapping("/{paymentId}/refund")
    @Operation(summary = "Refund payment", description = "Refunds a previously captured payment")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Payment refunded successfully",
                    content = @Content(schema = @Schema(implementation = PaymentDTO.class))),
            @ApiResponse(responseCode = "404", description = "Payment not found"),
            @ApiResponse(responseCode = "409", description = "Payment cannot be refunded in current state")
    })
    public CompletableFuture<ResponseEntity<PaymentDTO>> refundPayment(
            @Parameter(description = "Payment ID", required = true) @PathVariable String paymentId,
            @Valid @RequestBody RefundRequest request) {
        logger.info("REST: Refunding payment: {} (reason: {})", paymentId, request.reason());

        return paymentService.refundPayment(paymentId, request.reason())
                .thenApply(payment -> {
                    PaymentDTO response = payment.toDTO();
                    logger.info("REST: Payment refunded: {}, status: {}",
                            paymentId, response.getStatus());
                    return ResponseEntity.ok(response);
                });
    }

    /**
     * Lists all payments, up to the specified limit.
     *
     * @param limit the maximum number of payments to return (default: 10)
     * @return list of payments
     */
    @GetMapping
    @Operation(summary = "List payments", description = "Lists all payments from the materialized view")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Payments retrieved")
    })
    public ResponseEntity<List<PaymentDTO>> listPayments(
            @Parameter(description = "Maximum number of results") @RequestParam(defaultValue = "10") int limit) {
        logger.debug("REST: Listing payments (limit: {})", limit);

        List<PaymentDTO> payments = paymentService.listAll(limit).stream()
                .map(payment -> payment.toDTO())
                .collect(Collectors.toList());

        return ResponseEntity.ok(payments);
    }

    /**
     * Retrieves event history for a payment.
     *
     * @param paymentId the payment ID
     * @param limit the maximum number of events to return (default: 20)
     * @return list of events
     */
    @GetMapping("/{paymentId}/events")
    @Operation(summary = "Get payment event history",
            description = "Retrieves the event history for a payment from the event store")
    @ApiResponses(value = {
            @ApiResponse(responseCode = "200", description = "Event history retrieved")
    })
    public ResponseEntity<List<Map<String, Object>>> getEventHistory(
            @Parameter(description = "Payment ID", required = true) @PathVariable String paymentId,
            @Parameter(description = "Maximum number of events") @RequestParam(defaultValue = "20") int limit) {
        logger.debug("REST: Getting event history for payment: {} (limit: {})", paymentId, limit);

        List<Map<String, Object>> events = paymentService.getEventHistory(paymentId, limit);
        return ResponseEntity.ok(events);
    }

    /**
     * Request body for payment refund.
     *
     * @param reason the refund reason
     */
    public record RefundRequest(
            @NotBlank(message = "Reason is required")
            String reason
    ) {
    }
}
